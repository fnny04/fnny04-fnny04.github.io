"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/focusManager.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/focusManager.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusManager: () => (/* binding */ FocusManager),\n/* harmony export */   focusManager: () => (/* binding */ focusManager)\n/* harmony export */ });\n/* harmony import */ var _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/subscribable.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n\n\nclass FocusManager extends _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n    constructor(){\n        super();\n        this.setup = (onFocus)=>{\n            // addEventListener does not exist in React Native, but window does\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n                const listener = ()=>onFocus(); // Listen to visibillitychange and focus\n                window.addEventListener(\"visibilitychange\", listener, false);\n                window.addEventListener(\"focus\", listener, false);\n                return ()=>{\n                    // Be sure to unsubscribe if a new handler is set\n                    window.removeEventListener(\"visibilitychange\", listener);\n                    window.removeEventListener(\"focus\", listener);\n                };\n            }\n            return;\n        };\n    }\n    onSubscribe() {\n        if (!this.cleanup) {\n            this.setEventListener(this.setup);\n        }\n    }\n    onUnsubscribe() {\n        if (!this.hasListeners()) {\n            var _this$cleanup;\n            (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n            this.cleanup = undefined;\n        }\n    }\n    setEventListener(setup) {\n        var _this$cleanup2;\n        this.setup = setup;\n        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n        this.cleanup = setup((focused)=>{\n            if (typeof focused === \"boolean\") {\n                this.setFocused(focused);\n            } else {\n                this.onFocus();\n            }\n        });\n    }\n    setFocused(focused) {\n        const changed = this.focused !== focused;\n        if (changed) {\n            this.focused = focused;\n            this.onFocus();\n        }\n    }\n    onFocus() {\n        this.listeners.forEach(({ listener })=>{\n            listener();\n        });\n    }\n    isFocused() {\n        if (typeof this.focused === \"boolean\") {\n            return this.focused;\n        } // document global can be unavailable in react native\n        if (typeof document === \"undefined\") {\n            return true;\n        }\n        return [\n            undefined,\n            \"visible\",\n            \"prerender\"\n        ].includes(document.visibilityState);\n    }\n}\nconst focusManager = new FocusManager();\n //# sourceMappingURL=focusManager.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL2ZvY3VzTWFuYWdlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrRDtBQUNYO0FBRXZDLE1BQU1FLHFCQUFxQkYsMkRBQVlBO0lBQ3JDRyxhQUFjO1FBQ1osS0FBSztRQUVMLElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxDQUFBQTtZQUNYLG1FQUFtRTtZQUNuRSx1RUFBdUU7WUFDdkUsSUFBSSxDQUFDSixnREFBUUEsSUFBSUssT0FBT0MsZ0JBQWdCLEVBQUU7Z0JBQ3hDLE1BQU1DLFdBQVcsSUFBTUgsV0FBVyx3Q0FBd0M7Z0JBRzFFQyxPQUFPQyxnQkFBZ0IsQ0FBQyxvQkFBb0JDLFVBQVU7Z0JBQ3RERixPQUFPQyxnQkFBZ0IsQ0FBQyxTQUFTQyxVQUFVO2dCQUMzQyxPQUFPO29CQUNMLGlEQUFpRDtvQkFDakRGLE9BQU9HLG1CQUFtQixDQUFDLG9CQUFvQkQ7b0JBQy9DRixPQUFPRyxtQkFBbUIsQ0FBQyxTQUFTRDtnQkFDdEM7WUFDRjtZQUVBO1FBQ0Y7SUFDRjtJQUVBRSxjQUFjO1FBQ1osSUFBSSxDQUFDLElBQUksQ0FBQ0MsT0FBTyxFQUFFO1lBQ2pCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDUixLQUFLO1FBQ2xDO0lBQ0Y7SUFFQVMsZ0JBQWdCO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ0MsWUFBWSxJQUFJO1lBQ3hCLElBQUlDO1lBRUhBLENBQUFBLGdCQUFnQixJQUFJLENBQUNKLE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSUksY0FBY0MsSUFBSSxDQUFDLElBQUk7WUFDekUsSUFBSSxDQUFDTCxPQUFPLEdBQUdNO1FBQ2pCO0lBQ0Y7SUFFQUwsaUJBQWlCUixLQUFLLEVBQUU7UUFDdEIsSUFBSWM7UUFFSixJQUFJLENBQUNkLEtBQUssR0FBR0E7UUFDWmMsQ0FBQUEsaUJBQWlCLElBQUksQ0FBQ1AsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJTyxlQUFlRixJQUFJLENBQUMsSUFBSTtRQUMzRSxJQUFJLENBQUNMLE9BQU8sR0FBR1AsTUFBTWUsQ0FBQUE7WUFDbkIsSUFBSSxPQUFPQSxZQUFZLFdBQVc7Z0JBQ2hDLElBQUksQ0FBQ0MsVUFBVSxDQUFDRDtZQUNsQixPQUFPO2dCQUNMLElBQUksQ0FBQ2QsT0FBTztZQUNkO1FBQ0Y7SUFDRjtJQUVBZSxXQUFXRCxPQUFPLEVBQUU7UUFDbEIsTUFBTUUsVUFBVSxJQUFJLENBQUNGLE9BQU8sS0FBS0E7UUFFakMsSUFBSUUsU0FBUztZQUNYLElBQUksQ0FBQ0YsT0FBTyxHQUFHQTtZQUNmLElBQUksQ0FBQ2QsT0FBTztRQUNkO0lBQ0Y7SUFFQUEsVUFBVTtRQUNSLElBQUksQ0FBQ2lCLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLENBQUMsRUFDdEJmLFFBQVEsRUFDVDtZQUNDQTtRQUNGO0lBQ0Y7SUFFQWdCLFlBQVk7UUFDVixJQUFJLE9BQU8sSUFBSSxDQUFDTCxPQUFPLEtBQUssV0FBVztZQUNyQyxPQUFPLElBQUksQ0FBQ0EsT0FBTztRQUNyQixFQUFFLHFEQUFxRDtRQUd2RCxJQUFJLE9BQU9NLGFBQWEsYUFBYTtZQUNuQyxPQUFPO1FBQ1Q7UUFFQSxPQUFPO1lBQUNSO1lBQVc7WUFBVztTQUFZLENBQUNTLFFBQVEsQ0FBQ0QsU0FBU0UsZUFBZTtJQUM5RTtBQUVGO0FBQ0EsTUFBTUMsZUFBZSxJQUFJMUI7QUFFYSxDQUN0Qyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL2ZvY3VzTWFuYWdlci5tanM/MDhmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tICcuL3N1YnNjcmliYWJsZS5tanMnO1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNsYXNzIEZvY3VzTWFuYWdlciBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnNldHVwID0gb25Gb2N1cyA9PiB7XG4gICAgICAvLyBhZGRFdmVudExpc3RlbmVyIGRvZXMgbm90IGV4aXN0IGluIFJlYWN0IE5hdGl2ZSwgYnV0IHdpbmRvdyBkb2VzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgaWYgKCFpc1NlcnZlciAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IG9uRm9jdXMoKTsgLy8gTGlzdGVuIHRvIHZpc2liaWxsaXR5Y2hhbmdlIGFuZCBmb2N1c1xuXG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIC8vIEJlIHN1cmUgdG8gdW5zdWJzY3JpYmUgaWYgYSBuZXcgaGFuZGxlciBpcyBzZXRcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG5cbiAgb25TdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmNsZWFudXApIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRMaXN0ZW5lcih0aGlzLnNldHVwKTtcbiAgICB9XG4gIH1cblxuICBvblVuc3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgdmFyIF90aGlzJGNsZWFudXA7XG5cbiAgICAgIChfdGhpcyRjbGVhbnVwID0gdGhpcy5jbGVhbnVwKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2xlYW51cC5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHNldEV2ZW50TGlzdGVuZXIoc2V0dXApIHtcbiAgICB2YXIgX3RoaXMkY2xlYW51cDI7XG5cbiAgICB0aGlzLnNldHVwID0gc2V0dXA7XG4gICAgKF90aGlzJGNsZWFudXAyID0gdGhpcy5jbGVhbnVwKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2xlYW51cDIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmNsZWFudXAgPSBzZXR1cChmb2N1c2VkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZm9jdXNlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXNlZChmb2N1c2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25Gb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0Rm9jdXNlZChmb2N1c2VkKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuZm9jdXNlZCAhPT0gZm9jdXNlZDtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmZvY3VzZWQgPSBmb2N1c2VkO1xuICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgb25Gb2N1cygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCh7XG4gICAgICBsaXN0ZW5lclxuICAgIH0pID0+IHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gIH1cblxuICBpc0ZvY3VzZWQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZvY3VzZWQgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZDtcbiAgICB9IC8vIGRvY3VtZW50IGdsb2JhbCBjYW4gYmUgdW5hdmFpbGFibGUgaW4gcmVhY3QgbmF0aXZlXG5cblxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgJ3Zpc2libGUnLCAncHJlcmVuZGVyJ10uaW5jbHVkZXMoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgfVxuXG59XG5jb25zdCBmb2N1c01hbmFnZXIgPSBuZXcgRm9jdXNNYW5hZ2VyKCk7XG5cbmV4cG9ydCB7IEZvY3VzTWFuYWdlciwgZm9jdXNNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c01hbmFnZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlN1YnNjcmliYWJsZSIsImlzU2VydmVyIiwiRm9jdXNNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJzZXR1cCIsIm9uRm9jdXMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25TdWJzY3JpYmUiLCJjbGVhbnVwIiwic2V0RXZlbnRMaXN0ZW5lciIsIm9uVW5zdWJzY3JpYmUiLCJoYXNMaXN0ZW5lcnMiLCJfdGhpcyRjbGVhbnVwIiwiY2FsbCIsInVuZGVmaW5lZCIsIl90aGlzJGNsZWFudXAyIiwiZm9jdXNlZCIsInNldEZvY3VzZWQiLCJjaGFuZ2VkIiwibGlzdGVuZXJzIiwiZm9yRWFjaCIsImlzRm9jdXNlZCIsImRvY3VtZW50IiwiaW5jbHVkZXMiLCJ2aXNpYmlsaXR5U3RhdGUiLCJmb2N1c01hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/focusManager.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNextPageParam: () => (/* binding */ getNextPageParam),\n/* harmony export */   getPreviousPageParam: () => (/* binding */ getPreviousPageParam),\n/* harmony export */   hasNextPage: () => (/* binding */ hasNextPage),\n/* harmony export */   hasPreviousPage: () => (/* binding */ hasPreviousPage),\n/* harmony export */   infiniteQueryBehavior: () => (/* binding */ infiniteQueryBehavior)\n/* harmony export */ });\nfunction infiniteQueryBehavior() {\n    return {\n        onFetch: (context)=>{\n            context.fetchFn = ()=>{\n                var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n                const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n                const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n                const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n                const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === \"forward\";\n                const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === \"backward\";\n                const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n                const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n                let newPageParams = oldPageParams;\n                let cancelled = false;\n                const addSignalProperty = (object)=>{\n                    Object.defineProperty(object, \"signal\", {\n                        enumerable: true,\n                        get: ()=>{\n                            var _context$signal;\n                            if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                                cancelled = true;\n                            } else {\n                                var _context$signal2;\n                                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener(\"abort\", ()=>{\n                                    cancelled = true;\n                                });\n                            }\n                            return context.signal;\n                        }\n                    });\n                }; // Get query function\n                const queryFn = context.options.queryFn || (()=>Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n                const buildNewPages = (pages, param, page, previous)=>{\n                    newPageParams = previous ? [\n                        param,\n                        ...newPageParams\n                    ] : [\n                        ...newPageParams,\n                        param\n                    ];\n                    return previous ? [\n                        page,\n                        ...pages\n                    ] : [\n                        ...pages,\n                        page\n                    ];\n                }; // Create function to fetch a page\n                const fetchPage = (pages, manual, param, previous)=>{\n                    if (cancelled) {\n                        return Promise.reject(\"Cancelled\");\n                    }\n                    if (typeof param === \"undefined\" && !manual && pages.length) {\n                        return Promise.resolve(pages);\n                    }\n                    const queryFnContext = {\n                        queryKey: context.queryKey,\n                        pageParam: param,\n                        meta: context.options.meta\n                    };\n                    addSignalProperty(queryFnContext);\n                    const queryFnResult = queryFn(queryFnContext);\n                    const promise = Promise.resolve(queryFnResult).then((page)=>buildNewPages(pages, param, page, previous));\n                    return promise;\n                };\n                let promise; // Fetch first page?\n                if (!oldPages.length) {\n                    promise = fetchPage([]);\n                } else if (isFetchingNextPage) {\n                    const manual = typeof pageParam !== \"undefined\";\n                    const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n                    promise = fetchPage(oldPages, manual, param);\n                } else if (isFetchingPreviousPage) {\n                    const manual = typeof pageParam !== \"undefined\";\n                    const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n                    promise = fetchPage(oldPages, manual, param, true);\n                } else {\n                    newPageParams = [];\n                    const manual = typeof context.options.getNextPageParam === \"undefined\";\n                    const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n                    promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n                    for(let i = 1; i < oldPages.length; i++){\n                        promise = promise.then((pages)=>{\n                            const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n                            if (shouldFetchNextPage) {\n                                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                                return fetchPage(pages, manual, param);\n                            }\n                            return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n                        });\n                    }\n                }\n                const finalPromise = promise.then((pages)=>({\n                        pages,\n                        pageParams: newPageParams\n                    }));\n                return finalPromise;\n            };\n        }\n    };\n}\nfunction getNextPageParam(options, pages) {\n    return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n    return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */ function hasNextPage(options, pages) {\n    if (options.getNextPageParam && Array.isArray(pages)) {\n        const nextPageParam = getNextPageParam(options, pages);\n        return typeof nextPageParam !== \"undefined\" && nextPageParam !== null && nextPageParam !== false;\n    }\n    return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */ function hasPreviousPage(options, pages) {\n    if (options.getPreviousPageParam && Array.isArray(pages)) {\n        const previousPageParam = getPreviousPageParam(options, pages);\n        return typeof previousPageParam !== \"undefined\" && previousPageParam !== null && previousPageParam !== false;\n    }\n    return;\n}\n //# sourceMappingURL=infiniteQueryBehavior.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL2luZmluaXRlUXVlcnlCZWhhdmlvci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxTQUFTQTtJQUNQLE9BQU87UUFDTEMsU0FBU0MsQ0FBQUE7WUFDUEEsUUFBUUMsT0FBTyxHQUFHO2dCQUNoQixJQUFJQyx1QkFBdUJDLHdCQUF3QkMsd0JBQXdCQyx3QkFBd0JDLHFCQUFxQkM7Z0JBRXhILE1BQU1DLGNBQWMsQ0FBQ04sd0JBQXdCRixRQUFRUyxZQUFZLEtBQUssT0FBTyxLQUFLLElBQUksQ0FBQ04seUJBQXlCRCxzQkFBc0JRLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSVAsdUJBQXVCSyxXQUFXO2dCQUNqTSxNQUFNRyxZQUFZLENBQUNQLHlCQUF5QkosUUFBUVMsWUFBWSxLQUFLLE9BQU8sS0FBSyxJQUFJLENBQUNKLHlCQUF5QkQsdUJBQXVCTSxJQUFJLEtBQUssT0FBTyxLQUFLLElBQUlMLHVCQUF1Qk0sU0FBUztnQkFDL0wsTUFBTUMsWUFBWUQsYUFBYSxPQUFPLEtBQUssSUFBSUEsVUFBVUMsU0FBUztnQkFDbEUsTUFBTUMscUJBQXFCLENBQUNGLGFBQWEsT0FBTyxLQUFLLElBQUlBLFVBQVVHLFNBQVMsTUFBTTtnQkFDbEYsTUFBTUMseUJBQXlCLENBQUNKLGFBQWEsT0FBTyxLQUFLLElBQUlBLFVBQVVHLFNBQVMsTUFBTTtnQkFDdEYsTUFBTUUsV0FBVyxDQUFDLENBQUNWLHNCQUFzQk4sUUFBUWlCLEtBQUssQ0FBQ0MsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJWixvQkFBb0JhLEtBQUssS0FBSyxFQUFFO2dCQUNoSCxNQUFNQyxnQkFBZ0IsQ0FBQyxDQUFDYix1QkFBdUJQLFFBQVFpQixLQUFLLENBQUNDLElBQUksS0FBSyxPQUFPLEtBQUssSUFBSVgscUJBQXFCYyxVQUFVLEtBQUssRUFBRTtnQkFDNUgsSUFBSUMsZ0JBQWdCRjtnQkFDcEIsSUFB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QUFDQTs7O0NBR0MsR0FFRCxTQUFTd0MsWUFBWXZCLE9BQU8sRUFBRWpCLEtBQUs7SUFDakMsSUFBSWlCLFFBQVFpQixnQkFBZ0IsSUFBSU8sTUFBTUMsT0FBTyxDQUFDMUMsUUFBUTtRQUNwRCxNQUFNMkMsZ0JBQWdCVCxpQkFBaUJqQixTQUFTakI7UUFDaEQsT0FBTyxPQUFPMkMsa0JBQWtCLGVBQWVBLGtCQUFrQixRQUFRQSxrQkFBa0I7SUFDN0Y7SUFFQTtBQUNGO0FBQ0E7OztDQUdDLEdBRUQsU0FBU0MsZ0JBQWdCM0IsT0FBTyxFQUFFakIsS0FBSztJQUNyQyxJQUFJaUIsUUFBUWtCLG9CQUFvQixJQUFJTSxNQUFNQyxPQUFPLENBQUMxQyxRQUFRO1FBQ3hELE1BQU02QyxvQkFBb0JWLHFCQUFxQmxCLFNBQVNqQjtRQUN4RCxPQUFPLE9BQU82QyxzQkFBc0IsZUFBZUEsc0JBQXNCLFFBQVFBLHNCQUFzQjtJQUN6RztJQUVBO0FBQ0Y7QUFFdUcsQ0FDdkcsa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dDEzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IubWpzP2FlODUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaW5maW5pdGVRdWVyeUJlaGF2aW9yKCkge1xuICByZXR1cm4ge1xuICAgIG9uRmV0Y2g6IGNvbnRleHQgPT4ge1xuICAgICAgY29udGV4dC5mZXRjaEZuID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2NvbnRleHQkZmV0Y2hPcHRpb25zLCBfY29udGV4dCRmZXRjaE9wdGlvbnMyLCBfY29udGV4dCRmZXRjaE9wdGlvbnMzLCBfY29udGV4dCRmZXRjaE9wdGlvbnM0LCBfY29udGV4dCRzdGF0ZSRkYXRhLCBfY29udGV4dCRzdGF0ZSRkYXRhMjtcblxuICAgICAgICBjb25zdCByZWZldGNoUGFnZSA9IChfY29udGV4dCRmZXRjaE9wdGlvbnMgPSBjb250ZXh0LmZldGNoT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IChfY29udGV4dCRmZXRjaE9wdGlvbnMyID0gX2NvbnRleHQkZmV0Y2hPcHRpb25zLm1ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRmZXRjaE9wdGlvbnMyLnJlZmV0Y2hQYWdlO1xuICAgICAgICBjb25zdCBmZXRjaE1vcmUgPSAoX2NvbnRleHQkZmV0Y2hPcHRpb25zMyA9IGNvbnRleHQuZmV0Y2hPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogKF9jb250ZXh0JGZldGNoT3B0aW9uczQgPSBfY29udGV4dCRmZXRjaE9wdGlvbnMzLm1ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRmZXRjaE9wdGlvbnM0LmZldGNoTW9yZTtcbiAgICAgICAgY29uc3QgcGFnZVBhcmFtID0gZmV0Y2hNb3JlID09IG51bGwgPyB2b2lkIDAgOiBmZXRjaE1vcmUucGFnZVBhcmFtO1xuICAgICAgICBjb25zdCBpc0ZldGNoaW5nTmV4dFBhZ2UgPSAoZmV0Y2hNb3JlID09IG51bGwgPyB2b2lkIDAgOiBmZXRjaE1vcmUuZGlyZWN0aW9uKSA9PT0gJ2ZvcndhcmQnO1xuICAgICAgICBjb25zdCBpc0ZldGNoaW5nUHJldmlvdXNQYWdlID0gKGZldGNoTW9yZSA9PSBudWxsID8gdm9pZCAwIDogZmV0Y2hNb3JlLmRpcmVjdGlvbikgPT09ICdiYWNrd2FyZCc7XG4gICAgICAgIGNvbnN0IG9sZFBhZ2VzID0gKChfY29udGV4dCRzdGF0ZSRkYXRhID0gY29udGV4dC5zdGF0ZS5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkc3RhdGUkZGF0YS5wYWdlcykgfHwgW107XG4gICAgICAgIGNvbnN0IG9sZFBhZ2VQYXJhbXMgPSAoKF9jb250ZXh0JHN0YXRlJGRhdGEyID0gY29udGV4dC5zdGF0ZS5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkc3RhdGUkZGF0YTIucGFnZVBhcmFtcykgfHwgW107XG4gICAgICAgIGxldCBuZXdQYWdlUGFyYW1zID0gb2xkUGFnZVBhcmFtcztcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGFkZFNpZ25hbFByb3BlcnR5ID0gb2JqZWN0ID0+IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2lnbmFsJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2NvbnRleHQkc2lnbmFsO1xuXG4gICAgICAgICAgICAgIGlmICgoX2NvbnRleHQkc2lnbmFsID0gY29udGV4dC5zaWduYWwpICE9IG51bGwgJiYgX2NvbnRleHQkc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfY29udGV4dCRzaWduYWwyO1xuXG4gICAgICAgICAgICAgICAgKF9jb250ZXh0JHNpZ25hbDIgPSBjb250ZXh0LnNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JHNpZ25hbDIuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuc2lnbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9OyAvLyBHZXQgcXVlcnkgZnVuY3Rpb25cblxuXG4gICAgICAgIGNvbnN0IHF1ZXJ5Rm4gPSBjb250ZXh0Lm9wdGlvbnMucXVlcnlGbiB8fCAoKCkgPT4gUHJvbWlzZS5yZWplY3QoXCJNaXNzaW5nIHF1ZXJ5Rm4gZm9yIHF1ZXJ5S2V5ICdcIiArIGNvbnRleHQub3B0aW9ucy5xdWVyeUhhc2ggKyBcIidcIikpO1xuXG4gICAgICAgIGNvbnN0IGJ1aWxkTmV3UGFnZXMgPSAocGFnZXMsIHBhcmFtLCBwYWdlLCBwcmV2aW91cykgPT4ge1xuICAgICAgICAgIG5ld1BhZ2VQYXJhbXMgPSBwcmV2aW91cyA/IFtwYXJhbSwgLi4ubmV3UGFnZVBhcmFtc10gOiBbLi4ubmV3UGFnZVBhcmFtcywgcGFyYW1dO1xuICAgICAgICAgIHJldHVybiBwcmV2aW91cyA/IFtwYWdlLCAuLi5wYWdlc10gOiBbLi4ucGFnZXMsIHBhZ2VdO1xuICAgICAgICB9OyAvLyBDcmVhdGUgZnVuY3Rpb24gdG8gZmV0Y2ggYSBwYWdlXG5cblxuICAgICAgICBjb25zdCBmZXRjaFBhZ2UgPSAocGFnZXMsIG1hbnVhbCwgcGFyYW0sIHByZXZpb3VzKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxsZWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAndW5kZWZpbmVkJyAmJiAhbWFudWFsICYmIHBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcXVlcnlGbkNvbnRleHQgPSB7XG4gICAgICAgICAgICBxdWVyeUtleTogY29udGV4dC5xdWVyeUtleSxcbiAgICAgICAgICAgIHBhZ2VQYXJhbTogcGFyYW0sXG4gICAgICAgICAgICBtZXRhOiBjb250ZXh0Lm9wdGlvbnMubWV0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWRkU2lnbmFsUHJvcGVydHkocXVlcnlGbkNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5Rm5SZXN1bHQgPSBxdWVyeUZuKHF1ZXJ5Rm5Db250ZXh0KTtcbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5Rm5SZXN1bHQpLnRoZW4ocGFnZSA9PiBidWlsZE5ld1BhZ2VzKHBhZ2VzLCBwYXJhbSwgcGFnZSwgcHJldmlvdXMpKTtcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgcHJvbWlzZTsgLy8gRmV0Y2ggZmlyc3QgcGFnZT9cblxuICAgICAgICBpZiAoIW9sZFBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHByb21pc2UgPSBmZXRjaFBhZ2UoW10pO1xuICAgICAgICB9IC8vIEZldGNoIG5leHQgcGFnZT9cbiAgICAgICAgZWxzZSBpZiAoaXNGZXRjaGluZ05leHRQYWdlKSB7XG4gICAgICAgICAgY29uc3QgbWFudWFsID0gdHlwZW9mIHBhZ2VQYXJhbSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgY29uc3QgcGFyYW0gPSBtYW51YWwgPyBwYWdlUGFyYW0gOiBnZXROZXh0UGFnZVBhcmFtKGNvbnRleHQub3B0aW9ucywgb2xkUGFnZXMpO1xuICAgICAgICAgIHByb21pc2UgPSBmZXRjaFBhZ2Uob2xkUGFnZXMsIG1hbnVhbCwgcGFyYW0pO1xuICAgICAgICB9IC8vIEZldGNoIHByZXZpb3VzIHBhZ2U/XG4gICAgICAgIGVsc2UgaWYgKGlzRmV0Y2hpbmdQcmV2aW91c1BhZ2UpIHtcbiAgICAgICAgICBjb25zdCBtYW51YWwgPSB0eXBlb2YgcGFnZVBhcmFtICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICBjb25zdCBwYXJhbSA9IG1hbnVhbCA/IHBhZ2VQYXJhbSA6IGdldFByZXZpb3VzUGFnZVBhcmFtKGNvbnRleHQub3B0aW9ucywgb2xkUGFnZXMpO1xuICAgICAgICAgIHByb21pc2UgPSBmZXRjaFBhZ2Uob2xkUGFnZXMsIG1hbnVhbCwgcGFyYW0sIHRydWUpO1xuICAgICAgICB9IC8vIFJlZmV0Y2ggcGFnZXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3UGFnZVBhcmFtcyA9IFtdO1xuICAgICAgICAgIGNvbnN0IG1hbnVhbCA9IHR5cGVvZiBjb250ZXh0Lm9wdGlvbnMuZ2V0TmV4dFBhZ2VQYXJhbSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hGaXJzdFBhZ2UgPSByZWZldGNoUGFnZSAmJiBvbGRQYWdlc1swXSA/IHJlZmV0Y2hQYWdlKG9sZFBhZ2VzWzBdLCAwLCBvbGRQYWdlcykgOiB0cnVlOyAvLyBGZXRjaCBmaXJzdCBwYWdlXG5cbiAgICAgICAgICBwcm9taXNlID0gc2hvdWxkRmV0Y2hGaXJzdFBhZ2UgPyBmZXRjaFBhZ2UoW10sIG1hbnVhbCwgb2xkUGFnZVBhcmFtc1swXSkgOiBQcm9taXNlLnJlc29sdmUoYnVpbGROZXdQYWdlcyhbXSwgb2xkUGFnZVBhcmFtc1swXSwgb2xkUGFnZXNbMF0pKTsgLy8gRmV0Y2ggcmVtYWluaW5nIHBhZ2VzXG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9sZFBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHBhZ2VzID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hOZXh0UGFnZSA9IHJlZmV0Y2hQYWdlICYmIG9sZFBhZ2VzW2ldID8gcmVmZXRjaFBhZ2Uob2xkUGFnZXNbaV0sIGksIG9sZFBhZ2VzKSA6IHRydWU7XG5cbiAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoTmV4dFBhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbSA9IG1hbnVhbCA/IG9sZFBhZ2VQYXJhbXNbaV0gOiBnZXROZXh0UGFnZVBhcmFtKGNvbnRleHQub3B0aW9ucywgcGFnZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFBhZ2UocGFnZXMsIG1hbnVhbCwgcGFyYW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShidWlsZE5ld1BhZ2VzKHBhZ2VzLCBvbGRQYWdlUGFyYW1zW2ldLCBvbGRQYWdlc1tpXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmluYWxQcm9taXNlID0gcHJvbWlzZS50aGVuKHBhZ2VzID0+ICh7XG4gICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgcGFnZVBhcmFtczogbmV3UGFnZVBhcmFtc1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmaW5hbFByb21pc2U7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE5leHRQYWdlUGFyYW0ob3B0aW9ucywgcGFnZXMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZ2V0TmV4dFBhZ2VQYXJhbSA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXROZXh0UGFnZVBhcmFtKHBhZ2VzW3BhZ2VzLmxlbmd0aCAtIDFdLCBwYWdlcyk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCBwYWdlcykge1xuICByZXR1cm4gb3B0aW9ucy5nZXRQcmV2aW91c1BhZ2VQYXJhbSA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRQcmV2aW91c1BhZ2VQYXJhbShwYWdlc1swXSwgcGFnZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlcmUgaXMgYSBuZXh0IHBhZ2UuXG4gKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIGl0IGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICovXG5cbmZ1bmN0aW9uIGhhc05leHRQYWdlKG9wdGlvbnMsIHBhZ2VzKSB7XG4gIGlmIChvcHRpb25zLmdldE5leHRQYWdlUGFyYW0gJiYgQXJyYXkuaXNBcnJheShwYWdlcykpIHtcbiAgICBjb25zdCBuZXh0UGFnZVBhcmFtID0gZ2V0TmV4dFBhZ2VQYXJhbShvcHRpb25zLCBwYWdlcyk7XG4gICAgcmV0dXJuIHR5cGVvZiBuZXh0UGFnZVBhcmFtICE9PSAndW5kZWZpbmVkJyAmJiBuZXh0UGFnZVBhcmFtICE9PSBudWxsICYmIG5leHRQYWdlUGFyYW0gIT09IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlcmUgaXMgYSBwcmV2aW91cyBwYWdlLlxuICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBpdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNQcmV2aW91c1BhZ2Uob3B0aW9ucywgcGFnZXMpIHtcbiAgaWYgKG9wdGlvbnMuZ2V0UHJldmlvdXNQYWdlUGFyYW0gJiYgQXJyYXkuaXNBcnJheShwYWdlcykpIHtcbiAgICBjb25zdCBwcmV2aW91c1BhZ2VQYXJhbSA9IGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnMsIHBhZ2VzKTtcbiAgICByZXR1cm4gdHlwZW9mIHByZXZpb3VzUGFnZVBhcmFtICE9PSAndW5kZWZpbmVkJyAmJiBwcmV2aW91c1BhZ2VQYXJhbSAhPT0gbnVsbCAmJiBwcmV2aW91c1BhZ2VQYXJhbSAhPT0gZmFsc2U7XG4gIH1cblxuICByZXR1cm47XG59XG5cbmV4cG9ydCB7IGdldE5leHRQYWdlUGFyYW0sIGdldFByZXZpb3VzUGFnZVBhcmFtLCBoYXNOZXh0UGFnZSwgaGFzUHJldmlvdXNQYWdlLCBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmluaXRlUXVlcnlCZWhhdmlvci5tanMubWFwXG4iXSwibmFtZXMiOlsiaW5maW5pdGVRdWVyeUJlaGF2aW9yIiwib25GZXRjaCIsImNvbnRleHQiLCJmZXRjaEZuIiwiX2NvbnRleHQkZmV0Y2hPcHRpb25zIiwiX2NvbnRleHQkZmV0Y2hPcHRpb25zMiIsIl9jb250ZXh0JGZldGNoT3B0aW9uczMiLCJfY29udGV4dCRmZXRjaE9wdGlvbnM0IiwiX2NvbnRleHQkc3RhdGUkZGF0YSIsIl9jb250ZXh0JHN0YXRlJGRhdGEyIiwicmVmZXRjaFBhZ2UiLCJmZXRjaE9wdGlvbnMiLCJtZXRhIiwiZmV0Y2hNb3JlIiwicGFnZVBhcmFtIiwiaXNGZXRjaGluZ05leHRQYWdlIiwiZGlyZWN0aW9uIiwiaXNGZXRjaGluZ1ByZXZpb3VzUGFnZSIsIm9sZFBhZ2VzIiwic3RhdGUiLCJkYXRhIiwicGFnZXMiLCJvbGRQYWdlUGFyYW1zIiwicGFnZVBhcmFtcyIsIm5ld1BhZ2VQYXJhbXMiLCJjYW5jZWxsZWQiLCJhZGRTaWduYWxQcm9wZXJ0eSIsIm9iamVjdCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIl9jb250ZXh0JHNpZ25hbCIsInNpZ25hbCIsImFib3J0ZWQiLCJfY29udGV4dCRzaWduYWwyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInF1ZXJ5Rm4iLCJvcHRpb25zIiwiUHJvbWlzZSIsInJlamVjdCIsInF1ZXJ5SGFzaCIsImJ1aWxkTmV3UGFnZXMiLCJwYXJhbSIsInBhZ2UiLCJwcmV2aW91cyIsImZldGNoUGFnZSIsIm1hbnVhbCIsImxlbmd0aCIsInJlc29sdmUiLCJxdWVyeUZuQ29udGV4dCIsInF1ZXJ5S2V5IiwicXVlcnlGblJlc3VsdCIsInByb21pc2UiLCJ0aGVuIiwiZ2V0TmV4dFBhZ2VQYXJhbSIsImdldFByZXZpb3VzUGFnZVBhcmFtIiwic2hvdWxkRmV0Y2hGaXJzdFBhZ2UiLCJpIiwic2hvdWxkRmV0Y2hOZXh0UGFnZSIsImZpbmFsUHJvbWlzZSIsImhhc05leHRQYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwibmV4dFBhZ2VQYXJhbSIsImhhc1ByZXZpb3VzUGFnZSIsInByZXZpb3VzUGFnZVBhcmFtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/logger.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/logger.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultLogger: () => (/* binding */ defaultLogger)\n/* harmony export */ });\nconst defaultLogger = console;\n //# sourceMappingURL=logger.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL2xvZ2dlci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGdCQUFnQkM7QUFFRyxDQUN6QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL2xvZ2dlci5tanM/NDAwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWZhdWx0TG9nZ2VyID0gY29uc29sZTtcblxuZXhwb3J0IHsgZGVmYXVsdExvZ2dlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWZhdWx0TG9nZ2VyIiwiY29uc29sZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/logger.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/mutation.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/mutation.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mutation: () => (/* binding */ Mutation),\n/* harmony export */   getDefaultState: () => (/* binding */ getDefaultState)\n/* harmony export */ });\n/* harmony import */ var _logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/logger.mjs\");\n/* harmony import */ var _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs\");\n/* harmony import */ var _removable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/removable.mjs\");\n/* harmony import */ var _retryer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retryer.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/retryer.mjs\");\n\n\n\n\n// CLASS\nclass Mutation extends _removable_mjs__WEBPACK_IMPORTED_MODULE_0__.Removable {\n    constructor(config){\n        super();\n        this.defaultOptions = config.defaultOptions;\n        this.mutationId = config.mutationId;\n        this.mutationCache = config.mutationCache;\n        this.logger = config.logger || _logger_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultLogger;\n        this.observers = [];\n        this.state = config.state || getDefaultState();\n        this.setOptions(config.options);\n        this.scheduleGc();\n    }\n    setOptions(options) {\n        this.options = {\n            ...this.defaultOptions,\n            ...options\n        };\n        this.updateCacheTime(this.options.cacheTime);\n    }\n    get meta() {\n        return this.options.meta;\n    }\n    setState(state) {\n        this.dispatch({\n            type: \"setState\",\n            state\n        });\n    }\n    addObserver(observer) {\n        if (!this.observers.includes(observer)) {\n            this.observers.push(observer); // Stop the mutation from being garbage collected\n            this.clearGcTimeout();\n            this.mutationCache.notify({\n                type: \"observerAdded\",\n                mutation: this,\n                observer\n            });\n        }\n    }\n    removeObserver(observer) {\n        this.observers = this.observers.filter((x)=>x !== observer);\n        this.scheduleGc();\n        this.mutationCache.notify({\n            type: \"observerRemoved\",\n            mutation: this,\n            observer\n        });\n    }\n    optionalRemove() {\n        if (!this.observers.length) {\n            if (this.state.status === \"loading\") {\n                this.scheduleGc();\n            } else {\n                this.mutationCache.remove(this);\n            }\n        }\n    }\n    continue() {\n        var _this$retryer$continu, _this$retryer;\n        return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n    }\n    async execute() {\n        const executeMutation = ()=>{\n            var _this$options$retry;\n            this.retryer = (0,_retryer_mjs__WEBPACK_IMPORTED_MODULE_2__.createRetryer)({\n                fn: ()=>{\n                    if (!this.options.mutationFn) {\n                        return Promise.reject(\"No mutationFn found\");\n                    }\n                    return this.options.mutationFn(this.state.variables);\n                },\n                onFail: (failureCount, error)=>{\n                    this.dispatch({\n                        type: \"failed\",\n                        failureCount,\n                        error\n                    });\n                },\n                onPause: ()=>{\n                    this.dispatch({\n                        type: \"pause\"\n                    });\n                },\n                onContinue: ()=>{\n                    this.dispatch({\n                        type: \"continue\"\n                    });\n                },\n                retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n                retryDelay: this.options.retryDelay,\n                networkMode: this.options.networkMode\n            });\n            return this.retryer.promise;\n        };\n        const restored = this.state.status === \"loading\";\n        try {\n            var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n            if (!restored) {\n                var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n                this.dispatch({\n                    type: \"loading\",\n                    variables: this.options.variables\n                }); // Notify cache callback\n                await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n                const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n                if (context !== this.state.context) {\n                    this.dispatch({\n                        type: \"loading\",\n                        context,\n                        variables: this.state.variables\n                    });\n                }\n            }\n            const data = await executeMutation(); // Notify cache callback\n            await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n            await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n            await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n            await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n            this.dispatch({\n                type: \"success\",\n                data\n            });\n            return data;\n        } catch (error) {\n            try {\n                var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n                // Notify cache callback\n                await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n                if (true) {\n                    this.logger.error(error);\n                }\n                await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n                await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n                await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n                throw error;\n            } finally{\n                this.dispatch({\n                    type: \"error\",\n                    error: error\n                });\n            }\n        }\n    }\n    dispatch(action) {\n        const reducer = (state)=>{\n            switch(action.type){\n                case \"failed\":\n                    return {\n                        ...state,\n                        failureCount: action.failureCount,\n                        failureReason: action.error\n                    };\n                case \"pause\":\n                    return {\n                        ...state,\n                        isPaused: true\n                    };\n                case \"continue\":\n                    return {\n                        ...state,\n                        isPaused: false\n                    };\n                case \"loading\":\n                    return {\n                        ...state,\n                        context: action.context,\n                        data: undefined,\n                        failureCount: 0,\n                        failureReason: null,\n                        error: null,\n                        isPaused: !(0,_retryer_mjs__WEBPACK_IMPORTED_MODULE_2__.canFetch)(this.options.networkMode),\n                        status: \"loading\",\n                        variables: action.variables\n                    };\n                case \"success\":\n                    return {\n                        ...state,\n                        data: action.data,\n                        failureCount: 0,\n                        failureReason: null,\n                        error: null,\n                        status: \"success\",\n                        isPaused: false\n                    };\n                case \"error\":\n                    return {\n                        ...state,\n                        data: undefined,\n                        error: action.error,\n                        failureCount: state.failureCount + 1,\n                        failureReason: action.error,\n                        isPaused: false,\n                        status: \"error\"\n                    };\n                case \"setState\":\n                    return {\n                        ...state,\n                        ...action.state\n                    };\n            }\n        };\n        this.state = reducer(this.state);\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(()=>{\n            this.observers.forEach((observer)=>{\n                observer.onMutationUpdate(action);\n            });\n            this.mutationCache.notify({\n                mutation: this,\n                type: \"updated\",\n                action\n            });\n        });\n    }\n}\nfunction getDefaultState() {\n    return {\n        context: undefined,\n        data: undefined,\n        error: null,\n        failureCount: 0,\n        failureReason: null,\n        isPaused: false,\n        status: \"idle\",\n        variables: undefined\n    };\n}\n //# sourceMappingURL=mutation.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL211dGF0aW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNkM7QUFDTztBQUNSO0FBQ1k7QUFFeEQsUUFBUTtBQUNSLE1BQU1LLGlCQUFpQkgscURBQVNBO0lBQzlCSSxZQUFZQyxNQUFNLENBQUU7UUFDbEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsY0FBYyxHQUFHRCxPQUFPQyxjQUFjO1FBQzNDLElBQUksQ0FBQ0MsVUFBVSxHQUFHRixPQUFPRSxVQUFVO1FBQ25DLElBQUksQ0FBQ0MsYUFBYSxHQUFHSCxPQUFPRyxhQUFhO1FBQ3pDLElBQUksQ0FBQ0MsTUFBTSxHQUFHSixPQUFPSSxNQUFNLElBQUlYLHNEQUFhQTtRQUM1QyxJQUFJLENBQUNZLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHTixPQUFPTSxLQUFLLElBQUlDO1FBQzdCLElBQUksQ0FBQ0MsVUFBVSxDQUFDUixPQUFPUyxPQUFPO1FBQzlCLElBQUksQ0FBQ0MsVUFBVTtJQUNqQjtJQUVBRixXQUFXQyxPQUFPLEVBQUU7UUFDbEIsSUFBSSxDQUFDQSxPQUFPLEdBQUc7WUFBRSxHQUFHLElBQUksQ0FBQ1IsY0FBYztZQUNyQyxHQUFHUSxPQUFPO1FBQ1o7UUFDQSxJQUFJLENBQUNFLGVBQWUsQ0FBQyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0csU0FBUztJQUM3QztJQUVBLElBQUlDLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ0osT0FBTyxDQUFDSSxJQUFJO0lBQzFCO0lBRUFDLFNBQVNSLEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQ1MsUUFBUSxDQUFDO1lBQ1pDLE1BQU07WUFDTlY7UUFDRjtJQUNGO0lBRUFXLFlBQVlDLFFBQVEsRUFBRTtRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDYixTQUFTLENBQUNjLFFBQVEsQ0FBQ0QsV0FBVztZQUN0QyxJQUFJLENBQUNiLFNBQVMs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QWM7UUFDZHdDLGVBQWU7UUFDZkMsVUFBVTtRQUNWeEQsUUFBUTtRQUNSYSxXQUFXdUM7SUFDYjtBQUNGO0FBRXFDLENBQ3JDLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQxMy1ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9saWIvbXV0YXRpb24ubWpzPzk3ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdExvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLm1qcyc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBSZW1vdmFibGUgfSBmcm9tICcuL3JlbW92YWJsZS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlUmV0cnllciwgY2FuRmV0Y2ggfSBmcm9tICcuL3JldHJ5ZXIubWpzJztcblxuLy8gQ0xBU1NcbmNsYXNzIE11dGF0aW9uIGV4dGVuZHMgUmVtb3ZhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMubXV0YXRpb25JZCA9IGNvbmZpZy5tdXRhdGlvbklkO1xuICAgIHRoaXMubXV0YXRpb25DYWNoZSA9IGNvbmZpZy5tdXRhdGlvbkNhY2hlO1xuICAgIHRoaXMubG9nZ2VyID0gY29uZmlnLmxvZ2dlciB8fCBkZWZhdWx0TG9nZ2VyO1xuICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IGNvbmZpZy5zdGF0ZSB8fCBnZXREZWZhdWx0U3RhdGUoKTtcbiAgICB0aGlzLnNldE9wdGlvbnMoY29uZmlnLm9wdGlvbnMpO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVDYWNoZVRpbWUodGhpcy5vcHRpb25zLmNhY2hlVGltZSk7XG4gIH1cblxuICBnZXQgbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1ldGE7XG4gIH1cblxuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ3NldFN0YXRlJyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gIH1cblxuICBhZGRPYnNlcnZlcihvYnNlcnZlcikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMuaW5jbHVkZXMob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTsgLy8gU3RvcCB0aGUgbXV0YXRpb24gZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZFxuXG4gICAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gICAgICB0aGlzLm11dGF0aW9uQ2FjaGUubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ29ic2VydmVyQWRkZWQnLFxuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgb2JzZXJ2ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycy5maWx0ZXIoeCA9PiB4ICE9PSBvYnNlcnZlcik7XG4gICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gICAgdGhpcy5tdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICB0eXBlOiAnb2JzZXJ2ZXJSZW1vdmVkJyxcbiAgICAgIG11dGF0aW9uOiB0aGlzLFxuICAgICAgb2JzZXJ2ZXJcbiAgICB9KTtcbiAgfVxuXG4gIG9wdGlvbmFsUmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdsb2FkaW5nJykge1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29udGludWUoKSB7XG4gICAgdmFyIF90aGlzJHJldHJ5ZXIkY29udGludSwgX3RoaXMkcmV0cnllcjtcblxuICAgIHJldHVybiAoX3RoaXMkcmV0cnllciRjb250aW51ID0gKF90aGlzJHJldHJ5ZXIgPSB0aGlzLnJldHJ5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRyZXRyeWVyLmNvbnRpbnVlKCkpICE9IG51bGwgPyBfdGhpcyRyZXRyeWVyJGNvbnRpbnUgOiB0aGlzLmV4ZWN1dGUoKTtcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgY29uc3QgZXhlY3V0ZU11dGF0aW9uID0gKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMkcmV0cnk7XG5cbiAgICAgIHRoaXMucmV0cnllciA9IGNyZWF0ZVJldHJ5ZXIoe1xuICAgICAgICBmbjogKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11dGF0aW9uRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTm8gbXV0YXRpb25GbiBmb3VuZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubXV0YXRpb25Gbih0aGlzLnN0YXRlLnZhcmlhYmxlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRmFpbDogKGZhaWx1cmVDb3VudCwgZXJyb3IpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdmYWlsZWQnLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ3BhdXNlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbnRpbnVlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnY29udGludWUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJldHJ5OiAoX3RoaXMkb3B0aW9ucyRyZXRyeSA9IHRoaXMub3B0aW9ucy5yZXRyeSkgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnMkcmV0cnkgOiAwLFxuICAgICAgICByZXRyeURlbGF5OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheSxcbiAgICAgICAgbmV0d29ya01vZGU6IHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5yZXRyeWVyLnByb21pc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3RvcmVkID0gdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdsb2FkaW5nJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkbXV0YXRpb25DYWNoZSRjMywgX3RoaXMkbXV0YXRpb25DYWNoZSRjNCwgX3RoaXMkb3B0aW9ucyRvblN1Y2NlLCBfdGhpcyRvcHRpb25zMiwgX3RoaXMkbXV0YXRpb25DYWNoZSRjNSwgX3RoaXMkbXV0YXRpb25DYWNoZSRjNiwgX3RoaXMkb3B0aW9ucyRvblNldHRsLCBfdGhpcyRvcHRpb25zMztcblxuICAgICAgaWYgKCFyZXN0b3JlZCkge1xuICAgICAgICB2YXIgX3RoaXMkbXV0YXRpb25DYWNoZSRjLCBfdGhpcyRtdXRhdGlvbkNhY2hlJGMyLCBfdGhpcyRvcHRpb25zJG9uTXV0YXQsIF90aGlzJG9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ2xvYWRpbmcnLFxuICAgICAgICAgIHZhcmlhYmxlczogdGhpcy5vcHRpb25zLnZhcmlhYmxlc1xuICAgICAgICB9KTsgLy8gTm90aWZ5IGNhY2hlIGNhbGxiYWNrXG5cbiAgICAgICAgYXdhaXQgKChfdGhpcyRtdXRhdGlvbkNhY2hlJGMgPSAoX3RoaXMkbXV0YXRpb25DYWNoZSRjMiA9IHRoaXMubXV0YXRpb25DYWNoZS5jb25maWcpLm9uTXV0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25DYWNoZSRjLmNhbGwoX3RoaXMkbXV0YXRpb25DYWNoZSRjMiwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMpKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0ICgoX3RoaXMkb3B0aW9ucyRvbk11dGF0ID0gKF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMpLm9uTXV0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRvbk11dGF0LmNhbGwoX3RoaXMkb3B0aW9ucywgdGhpcy5zdGF0ZS52YXJpYWJsZXMpKTtcblxuICAgICAgICBpZiAoY29udGV4dCAhPT0gdGhpcy5zdGF0ZS5jb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnbG9hZGluZycsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnN0YXRlLnZhcmlhYmxlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBleGVjdXRlTXV0YXRpb24oKTsgLy8gTm90aWZ5IGNhY2hlIGNhbGxiYWNrXG5cbiAgICAgIGF3YWl0ICgoX3RoaXMkbXV0YXRpb25DYWNoZSRjMyA9IChfdGhpcyRtdXRhdGlvbkNhY2hlJGM0ID0gdGhpcy5tdXRhdGlvbkNhY2hlLmNvbmZpZykub25TdWNjZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25DYWNoZSRjMy5jYWxsKF90aGlzJG11dGF0aW9uQ2FjaGUkYzQsIGRhdGEsIHRoaXMuc3RhdGUudmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQsIHRoaXMpKTtcbiAgICAgIGF3YWl0ICgoX3RoaXMkb3B0aW9ucyRvblN1Y2NlID0gKF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zKS5vblN1Y2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zJG9uU3VjY2UuY2FsbChfdGhpcyRvcHRpb25zMiwgZGF0YSwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCkpOyAvLyBOb3RpZnkgY2FjaGUgY2FsbGJhY2tcblxuICAgICAgYXdhaXQgKChfdGhpcyRtdXRhdGlvbkNhY2hlJGM1ID0gKF90aGlzJG11dGF0aW9uQ2FjaGUkYzYgPSB0aGlzLm11dGF0aW9uQ2FjaGUuY29uZmlnKS5vblNldHRsZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbkNhY2hlJGM1LmNhbGwoX3RoaXMkbXV0YXRpb25DYWNoZSRjNiwgZGF0YSwgbnVsbCwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCwgdGhpcykpO1xuICAgICAgYXdhaXQgKChfdGhpcyRvcHRpb25zJG9uU2V0dGwgPSAoX3RoaXMkb3B0aW9uczMgPSB0aGlzLm9wdGlvbnMpLm9uU2V0dGxlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMkb25TZXR0bC5jYWxsKF90aGlzJG9wdGlvbnMzLCBkYXRhLCBudWxsLCB0aGlzLnN0YXRlLnZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KSk7XG4gICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX3RoaXMkbXV0YXRpb25DYWNoZSRjNywgX3RoaXMkbXV0YXRpb25DYWNoZSRjOCwgX3RoaXMkb3B0aW9ucyRvbkVycm9yLCBfdGhpcyRvcHRpb25zNCwgX3RoaXMkbXV0YXRpb25DYWNoZSRjOSwgX3RoaXMkbXV0YXRpb25DYWNoZSRjMTAsIF90aGlzJG9wdGlvbnMkb25TZXR0bDIsIF90aGlzJG9wdGlvbnM1O1xuXG4gICAgICAgIC8vIE5vdGlmeSBjYWNoZSBjYWxsYmFja1xuICAgICAgICBhd2FpdCAoKF90aGlzJG11dGF0aW9uQ2FjaGUkYzcgPSAoX3RoaXMkbXV0YXRpb25DYWNoZSRjOCA9IHRoaXMubXV0YXRpb25DYWNoZS5jb25maWcpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbkNhY2hlJGM3LmNhbGwoX3RoaXMkbXV0YXRpb25DYWNoZSRjOCwgZXJyb3IsIHRoaXMuc3RhdGUudmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQsIHRoaXMpKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0ICgoX3RoaXMkb3B0aW9ucyRvbkVycm9yID0gKF90aGlzJG9wdGlvbnM0ID0gdGhpcy5vcHRpb25zKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRvbkVycm9yLmNhbGwoX3RoaXMkb3B0aW9uczQsIGVycm9yLCB0aGlzLnN0YXRlLnZhcmlhYmxlcywgdGhpcy5zdGF0ZS5jb250ZXh0KSk7IC8vIE5vdGlmeSBjYWNoZSBjYWxsYmFja1xuXG4gICAgICAgIGF3YWl0ICgoX3RoaXMkbXV0YXRpb25DYWNoZSRjOSA9IChfdGhpcyRtdXRhdGlvbkNhY2hlJGMxMCA9IHRoaXMubXV0YXRpb25DYWNoZS5jb25maWcpLm9uU2V0dGxlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uQ2FjaGUkYzkuY2FsbChfdGhpcyRtdXRhdGlvbkNhY2hlJGMxMCwgdW5kZWZpbmVkLCBlcnJvciwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCwgdGhpcykpO1xuICAgICAgICBhd2FpdCAoKF90aGlzJG9wdGlvbnMkb25TZXR0bDIgPSAoX3RoaXMkb3B0aW9uczUgPSB0aGlzLm9wdGlvbnMpLm9uU2V0dGxlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMkb25TZXR0bDIuY2FsbChfdGhpcyRvcHRpb25zNSwgdW5kZWZpbmVkLCBlcnJvciwgdGhpcy5zdGF0ZS52YXJpYWJsZXMsIHRoaXMuc3RhdGUuY29udGV4dCkpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGNvbnN0IHJlZHVjZXIgPSBzdGF0ZSA9PiB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IGFjdGlvbi5mYWlsdXJlQ291bnQsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzUGF1c2VkOiB0cnVlXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdjb250aW51ZSc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICAgICAgY29udGV4dDogYWN0aW9uLmNvbnRleHQsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc1BhdXNlZDogIWNhbkZldGNoKHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZSksXG4gICAgICAgICAgICBzdGF0dXM6ICdsb2FkaW5nJyxcbiAgICAgICAgICAgIHZhcmlhYmxlczogYWN0aW9uLnZhcmlhYmxlc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICAgICAgICAgIGZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiBzdGF0ZS5mYWlsdXJlQ291bnQgKyAxLFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdzZXRTdGF0ZSc6XG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICAuLi5hY3Rpb24uc3RhdGVcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnN0YXRlID0gcmVkdWNlcih0aGlzLnN0YXRlKTtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBvYnNlcnZlci5vbk11dGF0aW9uVXBkYXRlKGFjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubXV0YXRpb25DYWNoZS5ub3RpZnkoe1xuICAgICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZWQnLFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgZGF0YTogdW5kZWZpbmVkLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICBzdGF0dXM6ICdpZGxlJyxcbiAgICB2YXJpYWJsZXM6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5leHBvcnQgeyBNdXRhdGlvbiwgZ2V0RGVmYXVsdFN0YXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdXRhdGlvbi5tanMubWFwXG4iXSwibmFtZXMiOlsiZGVmYXVsdExvZ2dlciIsIm5vdGlmeU1hbmFnZXIiLCJSZW1vdmFibGUiLCJjcmVhdGVSZXRyeWVyIiwiY2FuRmV0Y2giLCJNdXRhdGlvbiIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiZGVmYXVsdE9wdGlvbnMiLCJtdXRhdGlvbklkIiwibXV0YXRpb25DYWNoZSIsImxvZ2dlciIsIm9ic2VydmVycyIsInN0YXRlIiwiZ2V0RGVmYXVsdFN0YXRlIiwic2V0T3B0aW9ucyIsIm9wdGlvbnMiLCJzY2hlZHVsZUdjIiwidXBkYXRlQ2FjaGVUaW1lIiwiY2FjaGVUaW1lIiwibWV0YSIsInNldFN0YXRlIiwiZGlzcGF0Y2giLCJ0eXBlIiwiYWRkT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImluY2x1ZGVzIiwicHVzaCIsImNsZWFyR2NUaW1lb3V0Iiwibm90aWZ5IiwibXV0YXRpb24iLCJyZW1vdmVPYnNlcnZlciIsImZpbHRlciIsIngiLCJvcHRpb25hbFJlbW92ZSIsImxlbmd0aCIsInN0YXR1cyIsInJlbW92ZSIsImNvbnRpbnVlIiwiX3RoaXMkcmV0cnllciRjb250aW51IiwiX3RoaXMkcmV0cnllciIsInJldHJ5ZXIiLCJleGVjdXRlIiwiZXhlY3V0ZU11dGF0aW9uIiwiX3RoaXMkb3B0aW9ucyRyZXRyeSIsImZuIiwibXV0YXRpb25GbiIsIlByb21pc2UiLCJyZWplY3QiLCJ2YXJpYWJsZXMiLCJvbkZhaWwiLCJmYWlsdXJlQ291bnQiLCJlcnJvciIsIm9uUGF1c2UiLCJvbkNvbnRpbnVlIiwicmV0cnkiLCJyZXRyeURlbGF5IiwibmV0d29ya01vZGUiLCJwcm9taXNlIiwicmVzdG9yZWQiLCJfdGhpcyRtdXRhdGlvbkNhY2hlJGMzIiwiX3RoaXMkbXV0YXRpb25DYWNoZSRjNCIsIl90aGlzJG9wdGlvbnMkb25TdWNjZSIsIl90aGlzJG9wdGlvbnMyIiwiX3RoaXMkbXV0YXRpb25DYWNoZSRjNSIsIl90aGlzJG11dGF0aW9uQ2FjaGUkYzYiLCJfdGhpcyRvcHRpb25zJG9uU2V0dGwiLCJfdGhpcyRvcHRpb25zMyIsIl90aGlzJG11dGF0aW9uQ2FjaGUkYyIsIl90aGlzJG11dGF0aW9uQ2FjaGUkYzIiLCJfdGhpcyRvcHRpb25zJG9uTXV0YXQiLCJfdGhpcyRvcHRpb25zIiwib25NdXRhdGUiLCJjYWxsIiwiY29udGV4dCIsImRhdGEiLCJvblN1Y2Nlc3MiLCJvblNldHRsZWQiLCJfdGhpcyRtdXRhdGlvbkNhY2hlJGM3IiwiX3RoaXMkbXV0YXRpb25DYWNoZSRjOCIsIl90aGlzJG9wdGlvbnMkb25FcnJvciIsIl90aGlzJG9wdGlvbnM0IiwiX3RoaXMkbXV0YXRpb25DYWNoZSRjOSIsIl90aGlzJG11dGF0aW9uQ2FjaGUkYzEwIiwiX3RoaXMkb3B0aW9ucyRvblNldHRsMiIsIl90aGlzJG9wdGlvbnM1Iiwib25FcnJvciIsInByb2Nlc3MiLCJ1bmRlZmluZWQiLCJhY3Rpb24iLCJyZWR1Y2VyIiwiZmFpbHVyZVJlYXNvbiIsImlzUGF1c2VkIiwiYmF0Y2giLCJmb3JFYWNoIiwib25NdXRhdGlvblVwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/mutation.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/mutationCache.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/mutationCache.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MutationCache: () => (/* binding */ MutationCache)\n/* harmony export */ });\n/* harmony import */ var _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs\");\n/* harmony import */ var _mutation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutation.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/mutation.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n/* harmony import */ var _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/subscribable.mjs\");\n\n\n\n\n// CLASS\nclass MutationCache extends _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n    constructor(config){\n        super();\n        this.config = config || {};\n        this.mutations = [];\n        this.mutationId = 0;\n    }\n    build(client, options, state) {\n        const mutation = new _mutation_mjs__WEBPACK_IMPORTED_MODULE_1__.Mutation({\n            mutationCache: this,\n            logger: client.getLogger(),\n            mutationId: ++this.mutationId,\n            options: client.defaultMutationOptions(options),\n            state,\n            defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n        });\n        this.add(mutation);\n        return mutation;\n    }\n    add(mutation) {\n        this.mutations.push(mutation);\n        this.notify({\n            type: \"added\",\n            mutation\n        });\n    }\n    remove(mutation) {\n        this.mutations = this.mutations.filter((x)=>x !== mutation);\n        this.notify({\n            type: \"removed\",\n            mutation\n        });\n    }\n    clear() {\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(()=>{\n            this.mutations.forEach((mutation)=>{\n                this.remove(mutation);\n            });\n        });\n    }\n    getAll() {\n        return this.mutations;\n    }\n    find(filters) {\n        if (typeof filters.exact === \"undefined\") {\n            filters.exact = true;\n        }\n        return this.mutations.find((mutation)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(filters, mutation));\n    }\n    findAll(filters) {\n        return this.mutations.filter((mutation)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(filters, mutation));\n    }\n    notify(event) {\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(()=>{\n            this.listeners.forEach(({ listener })=>{\n                listener(event);\n            });\n        });\n    }\n    resumePausedMutations() {\n        var _this$resuming;\n        this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(()=>{\n            const pausedMutations = this.mutations.filter((x)=>x.state.isPaused);\n            return _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(()=>pausedMutations.reduce((promise, mutation)=>promise.then(()=>mutation.continue().catch(_utils_mjs__WEBPACK_IMPORTED_MODULE_3__.noop)), Promise.resolve()));\n        }).then(()=>{\n            this.resuming = undefined;\n        });\n        return this.resuming;\n    }\n}\n //# sourceMappingURL=mutationCache.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL211dGF0aW9uQ2FjaGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ1Y7QUFDUTtBQUNBO0FBRWxELFFBQVE7QUFDUixNQUFNSyxzQkFBc0JELDJEQUFZQTtJQUN0Q0UsWUFBWUMsTUFBTSxDQUFFO1FBQ2xCLEtBQUs7UUFDTCxJQUFJLENBQUNBLE1BQU0sR0FBR0EsVUFBVSxDQUFDO1FBQ3pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFDcEI7SUFFQUMsTUFBTUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM1QixNQUFNQyxXQUFXLElBQUliLG1EQUFRQSxDQUFDO1lBQzVCYyxlQUFlLElBQUk7WUFDbkJDLFFBQVFMLE9BQU9NLFNBQVM7WUFDeEJSLFlBQVksRUFBRSxJQUFJLENBQUNBLFVBQVU7WUFDN0JHLFNBQVNELE9BQU9PLHNCQUFzQixDQUFDTjtZQUN2Q0M7WUFDQU0sZ0JBQWdCUCxRQUFRUSxXQUFXLEdBQUdULE9BQU9VLG1CQUFtQixDQUFDVCxRQUFRUSxXQUFXLElBQUlFO1FBQzFGO1FBQ0EsSUFBSSxDQUFDQyxHQUFHLENBQUNUO1FBQ1QsT0FBT0E7SUFDVDtJQUVBUyxJQUFJVCxRQUFRLEVBQUU7UUFDWixJQUFJLENBQUNOLFNBQVMsQ0FBQ2dCLElBQUksQ0FBQ1Y7UUFDcEIsSUFBSSxDQUFDVyxNQUFNLENBQUM7WUFDVkMsTUFBTTtZQUNOWjtRQUNGO0lBQ0Y7SUFFQWEsT0FBT2IsUUFBUSxFQUFFO1FBQ2YsSUFBSSxDQUFDTixTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTLENBQUNvQixNQUFNLENBQUNDLENBQUFBLElBQUtBLE1BQU1mO1FBQ2xELElBQUksQ0FBQ1csTUFBTSxDQUFDO1lBQ1ZDLE1BQU07WUFDTlo7UUFDRjtJQUNGO0lBRUFnQixRQUFRO1FBQ045Qiw2REFBYUEsQ0FBQytCLEtBQUssQ0FBQztZQUNsQixJQUFJLENBQUN2QixTQUFTLENBQUN3QixPQUFPLENBQUNsQixDQUFBQTtnQkFDckIsSUFBSSxDQUFDYSxNQUFNLENBQUNiO1lBQ2Q7UUFDRjtJQUNGO0lBRUFtQixTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUN6QixTQUFTO0lBQ3ZCO0lBRUEwQixLQUFLQyxPQUFPLEVBQUU7UUFDWixJQUFJLE9BQU9BLFFBQVFDLEtBQUssS0FBSyxhQUFhO1lBQ3hDRCxRQUFRQyxLQUFLLEdBQUc7UUFDbEI7UUFFQSxPQUFPLElBQUksQ0FBQzVCLFNBQVMsQ0FBQzBCLElBQUksQ0FBQ3BCLENBQUFBLFdBQVlaLHlEQUFhQSxDQUFDaUMsU0FBU3JCO0lBQ2hFO0lBRUF1QixRQUFRRixPQUFPLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQzNCLFNBQVMsQ0FBQ29CLE1BQU0sQ0FBQ2QsQ0FBQUEsV0FBWVoseURBQWFBLENBQUNpQyxTQUFTckI7SUFDbEU7SUFFQVcsT0FBT2EsS0FBSyxFQUFFO1FBQ1p0Qyw2REFBYUEsQ0FBQytCLEtBQUssQ0FBQztZQUNsQixJQUFJLENBQUNRLFNBQVMsQ0FBQ1AsT0FBTyxDQUFDLENBQUMsRUFDdEJRLFFBQVEsRUFDVDtnQkFDQ0EsU0FBU0Y7WUFDWDtRQUNGO0lBQ0Y7SUFFQUcsd0JBQXdCO1FBQ3RCLElBQUlDO1FBRUosSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQyxDQUFDRCxpQkFBaUIsSUFBSSxDQUFDQyxRQUFRLEtBQUssT0FBT0QsaUJBQWlCRSxRQUFRQyxPQUFPLEVBQUMsRUFBR0MsSUFBSSxDQUFDO1lBQ25HLE1BQU1DLGtCQUFrQixJQUFJLENBQUN2QyxTQUFTLENBQUNvQixNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVoQixLQUFLLENBQUNtQyxRQUFRO1lBQ25FLE9BQU9oRCw2REFBYUEsQ0FBQytCLEtBQUssQ0FBQyxJQUFNZ0IsZ0JBQWdCRSxNQUFNLENBQUMsQ0FBQ0MsU0FBU3BDLFdBQWFvQyxRQUFRSixJQUFJLENBQUMsSUFBTWhDLFNBQVNxQyxRQUFRLEdBQUdDLEtBQUssQ0FBQ2pELDRDQUFJQSxJQUFJeUMsUUFBUUMsT0FBTztRQUNySixHQUFHQyxJQUFJLENBQUM7WUFDTixJQUFJLENBQUNILFFBQVEsR0FBR3JCO1FBQ2xCO1FBQ0EsT0FBTyxJQUFJLENBQUNxQixRQUFRO0lBQ3RCO0FBRUY7QUFFeUIsQ0FDekIsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dDEzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9tdXRhdGlvbkNhY2hlLm1qcz9jYTU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tICcuL25vdGlmeU1hbmFnZXIubWpzJztcbmltcG9ydCB7IE11dGF0aW9uIH0gZnJvbSAnLi9tdXRhdGlvbi5tanMnO1xuaW1wb3J0IHsgbWF0Y2hNdXRhdGlvbiwgbm9vcCB9IGZyb20gJy4vdXRpbHMubWpzJztcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gJy4vc3Vic2NyaWJhYmxlLm1qcyc7XG5cbi8vIENMQVNTXG5jbGFzcyBNdXRhdGlvbkNhY2hlIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLm11dGF0aW9ucyA9IFtdO1xuICAgIHRoaXMubXV0YXRpb25JZCA9IDA7XG4gIH1cblxuICBidWlsZChjbGllbnQsIG9wdGlvbnMsIHN0YXRlKSB7XG4gICAgY29uc3QgbXV0YXRpb24gPSBuZXcgTXV0YXRpb24oe1xuICAgICAgbXV0YXRpb25DYWNoZTogdGhpcyxcbiAgICAgIGxvZ2dlcjogY2xpZW50LmdldExvZ2dlcigpLFxuICAgICAgbXV0YXRpb25JZDogKyt0aGlzLm11dGF0aW9uSWQsXG4gICAgICBvcHRpb25zOiBjbGllbnQuZGVmYXVsdE11dGF0aW9uT3B0aW9ucyhvcHRpb25zKSxcbiAgICAgIHN0YXRlLFxuICAgICAgZGVmYXVsdE9wdGlvbnM6IG9wdGlvbnMubXV0YXRpb25LZXkgPyBjbGllbnQuZ2V0TXV0YXRpb25EZWZhdWx0cyhvcHRpb25zLm11dGF0aW9uS2V5KSA6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIHRoaXMuYWRkKG11dGF0aW9uKTtcbiAgICByZXR1cm4gbXV0YXRpb247XG4gIH1cblxuICBhZGQobXV0YXRpb24pIHtcbiAgICB0aGlzLm11dGF0aW9ucy5wdXNoKG11dGF0aW9uKTtcbiAgICB0aGlzLm5vdGlmeSh7XG4gICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgbXV0YXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZShtdXRhdGlvbikge1xuICAgIHRoaXMubXV0YXRpb25zID0gdGhpcy5tdXRhdGlvbnMuZmlsdGVyKHggPT4geCAhPT0gbXV0YXRpb24pO1xuICAgIHRoaXMubm90aWZ5KHtcbiAgICAgIHR5cGU6ICdyZW1vdmVkJyxcbiAgICAgIG11dGF0aW9uXG4gICAgfSk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZShtdXRhdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGlvbnM7XG4gIH1cblxuICBmaW5kKGZpbHRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGZpbHRlcnMuZXhhY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmaWx0ZXJzLmV4YWN0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tdXRhdGlvbnMuZmluZChtdXRhdGlvbiA9PiBtYXRjaE11dGF0aW9uKGZpbHRlcnMsIG11dGF0aW9uKSk7XG4gIH1cblxuICBmaW5kQWxsKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGlvbnMuZmlsdGVyKG11dGF0aW9uID0+IG1hdGNoTXV0YXRpb24oZmlsdGVycywgbXV0YXRpb24pKTtcbiAgfVxuXG4gIG5vdGlmeShldmVudCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgoe1xuICAgICAgICBsaXN0ZW5lclxuICAgICAgfSkgPT4ge1xuICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc3VtZVBhdXNlZE11dGF0aW9ucygpIHtcbiAgICB2YXIgX3RoaXMkcmVzdW1pbmc7XG5cbiAgICB0aGlzLnJlc3VtaW5nID0gKChfdGhpcyRyZXN1bWluZyA9IHRoaXMucmVzdW1pbmcpICE9IG51bGwgPyBfdGhpcyRyZXN1bWluZyA6IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHBhdXNlZE11dGF0aW9ucyA9IHRoaXMubXV0YXRpb25zLmZpbHRlcih4ID0+IHguc3RhdGUuaXNQYXVzZWQpO1xuICAgICAgcmV0dXJuIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4gcGF1c2VkTXV0YXRpb25zLnJlZHVjZSgocHJvbWlzZSwgbXV0YXRpb24pID0+IHByb21pc2UudGhlbigoKSA9PiBtdXRhdGlvbi5jb250aW51ZSgpLmNhdGNoKG5vb3ApKSwgUHJvbWlzZS5yZXNvbHZlKCkpKTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVzdW1pbmcgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucmVzdW1pbmc7XG4gIH1cblxufVxuXG5leHBvcnQgeyBNdXRhdGlvbkNhY2hlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdXRhdGlvbkNhY2hlLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJub3RpZnlNYW5hZ2VyIiwiTXV0YXRpb24iLCJtYXRjaE11dGF0aW9uIiwibm9vcCIsIlN1YnNjcmliYWJsZSIsIk11dGF0aW9uQ2FjaGUiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsIm11dGF0aW9ucyIsIm11dGF0aW9uSWQiLCJidWlsZCIsImNsaWVudCIsIm9wdGlvbnMiLCJzdGF0ZSIsIm11dGF0aW9uIiwibXV0YXRpb25DYWNoZSIsImxvZ2dlciIsImdldExvZ2dlciIsImRlZmF1bHRNdXRhdGlvbk9wdGlvbnMiLCJkZWZhdWx0T3B0aW9ucyIsIm11dGF0aW9uS2V5IiwiZ2V0TXV0YXRpb25EZWZhdWx0cyIsInVuZGVmaW5lZCIsImFkZCIsInB1c2giLCJub3RpZnkiLCJ0eXBlIiwicmVtb3ZlIiwiZmlsdGVyIiwieCIsImNsZWFyIiwiYmF0Y2giLCJmb3JFYWNoIiwiZ2V0QWxsIiwiZmluZCIsImZpbHRlcnMiLCJleGFjdCIsImZpbmRBbGwiLCJldmVudCIsImxpc3RlbmVycyIsImxpc3RlbmVyIiwicmVzdW1lUGF1c2VkTXV0YXRpb25zIiwiX3RoaXMkcmVzdW1pbmciLCJyZXN1bWluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInBhdXNlZE11dGF0aW9ucyIsImlzUGF1c2VkIiwicmVkdWNlIiwicHJvbWlzZSIsImNvbnRpbnVlIiwiY2F0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/mutationCache.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotifyManager: () => (/* binding */ createNotifyManager),\n/* harmony export */   notifyManager: () => (/* binding */ notifyManager)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n\nfunction createNotifyManager() {\n    let queue = [];\n    let transactions = 0;\n    let notifyFn = (callback)=>{\n        callback();\n    };\n    let batchNotifyFn = (callback)=>{\n        callback();\n    };\n    const batch = (callback)=>{\n        let result;\n        transactions++;\n        try {\n            result = callback();\n        } finally{\n            transactions--;\n            if (!transactions) {\n                flush();\n            }\n        }\n        return result;\n    };\n    const schedule = (callback)=>{\n        if (transactions) {\n            queue.push(callback);\n        } else {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.scheduleMicrotask)(()=>{\n                notifyFn(callback);\n            });\n        }\n    };\n    /**\n   * All calls to the wrapped function will be batched.\n   */ const batchCalls = (callback)=>{\n        return (...args)=>{\n            schedule(()=>{\n                callback(...args);\n            });\n        };\n    };\n    const flush = ()=>{\n        const originalQueue = queue;\n        queue = [];\n        if (originalQueue.length) {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.scheduleMicrotask)(()=>{\n                batchNotifyFn(()=>{\n                    originalQueue.forEach((callback)=>{\n                        notifyFn(callback);\n                    });\n                });\n            });\n        }\n    };\n    /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */ const setNotifyFunction = (fn)=>{\n        notifyFn = fn;\n    };\n    /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */ const setBatchNotifyFunction = (fn)=>{\n        batchNotifyFn = fn;\n    };\n    return {\n        batch,\n        batchCalls,\n        schedule,\n        setNotifyFunction,\n        setBatchNotifyFunction\n    };\n} // SINGLETON\nconst notifyManager = createNotifyManager();\n //# sourceMappingURL=notifyManager.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL25vdGlmeU1hbmFnZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRDtBQUVoRCxTQUFTQztJQUNQLElBQUlDLFFBQVEsRUFBRTtJQUNkLElBQUlDLGVBQWU7SUFFbkIsSUFBSUMsV0FBV0MsQ0FBQUE7UUFDYkE7SUFDRjtJQUVBLElBQUlDLGdCQUFnQkQsQ0FBQUE7UUFDbEJBO0lBQ0Y7SUFFQSxNQUFNRSxRQUFRRixDQUFBQTtRQUNaLElBQUlHO1FBQ0pMO1FBRUEsSUFBSTtZQUNGSyxTQUFTSDtRQUNYLFNBQVU7WUFDUkY7WUFFQSxJQUFJLENBQUNBLGNBQWM7Z0JBQ2pCTTtZQUNGO1FBQ0Y7UUFFQSxPQUFPRDtJQUNUO0lBRUEsTUFBTUUsV0FBV0wsQ0FBQUE7UUFDZixJQUFJRixjQUFjO1lBQ2hCRCxNQUFNUyxJQUFJLENBQUNOO1FBQ2IsT0FBTztZQUNMTCw2REFBaUJBLENBQUM7Z0JBQ2hCSSxTQUFTQztZQUNYO1FBQ0Y7SUFDRjtJQUNBOztHQUVDLEdBR0QsTUFBTU8sYUFBYVAsQ0FBQUE7UUFDakIsT0FBTyxDQUFDLEdBQUdRO1lBQ1RILFNBQVM7Z0JBQ1BMLFlBQVlRO1lBQ2Q7UUFDRjtJQUNGO0lBRUEsTUFBTUosUUFBUTtRQUNaLE1BQU1LLGdCQUFnQlo7UUFDdEJBLFFBQVEsRUFBRTtRQUVWLElBQUlZLGNBQWNDLE1BQU0sRUFBRTtZQUN4QmYsNkRBQWlCQSxDQUFDO2dCQUNoQk0sY0FBYztvQkFDWlEsY0FBY0UsT0FBTyxDQUFDWCxDQUFBQTt3QkFDcEJELFNBQVNDO29CQUNYO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0E7OztHQUdDLEdBR0QsTUFBTVksb0JBQW9CQyxDQUFBQTtRQUN4QmQsV0FBV2M7SUFDYjtJQUNBOzs7R0FHQyxHQUdELE1BQU1DLHlCQUF5QkQsQ0FBQUE7UUFDN0JaLGdCQUFnQlk7SUFDbEI7SUFFQSxPQUFPO1FBQ0xYO1FBQ0FLO1FBQ0FGO1FBQ0FPO1FBQ0FFO0lBQ0Y7QUFDRixFQUFFLFlBQVk7QUFFZCxNQUFNQyxnQkFBZ0JuQjtBQUV3QixDQUM5QywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL25vdGlmeU1hbmFnZXIubWpzP2NlZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2NoZWR1bGVNaWNyb3Rhc2sgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlmeU1hbmFnZXIoKSB7XG4gIGxldCBxdWV1ZSA9IFtdO1xuICBsZXQgdHJhbnNhY3Rpb25zID0gMDtcblxuICBsZXQgbm90aWZ5Rm4gPSBjYWxsYmFjayA9PiB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcblxuICBsZXQgYmF0Y2hOb3RpZnlGbiA9IGNhbGxiYWNrID0+IHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIGNvbnN0IGJhdGNoID0gY2FsbGJhY2sgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJhbnNhY3Rpb25zKys7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJhbnNhY3Rpb25zLS07XG5cbiAgICAgIGlmICghdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBjb25zdCBzY2hlZHVsZSA9IGNhbGxiYWNrID0+IHtcbiAgICBpZiAodHJhbnNhY3Rpb25zKSB7XG4gICAgICBxdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBub3RpZnlGbihjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBBbGwgY2FsbHMgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb24gd2lsbCBiZSBiYXRjaGVkLlxuICAgKi9cblxuXG4gIGNvbnN0IGJhdGNoQ2FsbHMgPSBjYWxsYmFjayA9PiB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBzY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcblxuICAgIGlmIChvcmlnaW5hbFF1ZXVlLmxlbmd0aCkge1xuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBiYXRjaE5vdGlmeUZuKCgpID0+IHtcbiAgICAgICAgICBvcmlnaW5hbFF1ZXVlLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Rm4oY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gbm90aWZ5IGZ1bmN0aW9uLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGZvciBleGFtcGxlIHdyYXAgbm90aWZpY2F0aW9ucyB3aXRoIGBSZWFjdC5hY3RgIHdoaWxlIHJ1bm5pbmcgdGVzdHMuXG4gICAqL1xuXG5cbiAgY29uc3Qgc2V0Tm90aWZ5RnVuY3Rpb24gPSBmbiA9PiB7XG4gICAgbm90aWZ5Rm4gPSBmbjtcbiAgfTtcbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmF0Y2ggbm90aWZpY2F0aW9ucyB0b2dldGhlciBpbnRvIGEgc2luZ2xlIHRpY2suXG4gICAqIEJ5IGRlZmF1bHQgUmVhY3QgUXVlcnkgd2lsbCB1c2UgdGhlIGJhdGNoIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IFJlYWN0RE9NIG9yIFJlYWN0IE5hdGl2ZS5cbiAgICovXG5cblxuICBjb25zdCBzZXRCYXRjaE5vdGlmeUZ1bmN0aW9uID0gZm4gPT4ge1xuICAgIGJhdGNoTm90aWZ5Rm4gPSBmbjtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGJhdGNoLFxuICAgIGJhdGNoQ2FsbHMsXG4gICAgc2NoZWR1bGUsXG4gICAgc2V0Tm90aWZ5RnVuY3Rpb24sXG4gICAgc2V0QmF0Y2hOb3RpZnlGdW5jdGlvblxuICB9O1xufSAvLyBTSU5HTEVUT05cblxuY29uc3Qgbm90aWZ5TWFuYWdlciA9IGNyZWF0ZU5vdGlmeU1hbmFnZXIoKTtcblxuZXhwb3J0IHsgY3JlYXRlTm90aWZ5TWFuYWdlciwgbm90aWZ5TWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90aWZ5TWFuYWdlci5tanMubWFwXG4iXSwibmFtZXMiOlsic2NoZWR1bGVNaWNyb3Rhc2siLCJjcmVhdGVOb3RpZnlNYW5hZ2VyIiwicXVldWUiLCJ0cmFuc2FjdGlvbnMiLCJub3RpZnlGbiIsImNhbGxiYWNrIiwiYmF0Y2hOb3RpZnlGbiIsImJhdGNoIiwicmVzdWx0IiwiZmx1c2giLCJzY2hlZHVsZSIsInB1c2giLCJiYXRjaENhbGxzIiwiYXJncyIsIm9yaWdpbmFsUXVldWUiLCJsZW5ndGgiLCJmb3JFYWNoIiwic2V0Tm90aWZ5RnVuY3Rpb24iLCJmbiIsInNldEJhdGNoTm90aWZ5RnVuY3Rpb24iLCJub3RpZnlNYW5hZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/onlineManager.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/onlineManager.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnlineManager: () => (/* binding */ OnlineManager),\n/* harmony export */   onlineManager: () => (/* binding */ onlineManager)\n/* harmony export */ });\n/* harmony import */ var _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/subscribable.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n\n\nconst onlineEvents = [\n    \"online\",\n    \"offline\"\n];\nclass OnlineManager extends _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n    constructor(){\n        super();\n        this.setup = (onOnline)=>{\n            // addEventListener does not exist in React Native, but window does\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n                const listener = ()=>onOnline(); // Listen to online\n                onlineEvents.forEach((event)=>{\n                    window.addEventListener(event, listener, false);\n                });\n                return ()=>{\n                    // Be sure to unsubscribe if a new handler is set\n                    onlineEvents.forEach((event)=>{\n                        window.removeEventListener(event, listener);\n                    });\n                };\n            }\n            return;\n        };\n    }\n    onSubscribe() {\n        if (!this.cleanup) {\n            this.setEventListener(this.setup);\n        }\n    }\n    onUnsubscribe() {\n        if (!this.hasListeners()) {\n            var _this$cleanup;\n            (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n            this.cleanup = undefined;\n        }\n    }\n    setEventListener(setup) {\n        var _this$cleanup2;\n        this.setup = setup;\n        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n        this.cleanup = setup((online)=>{\n            if (typeof online === \"boolean\") {\n                this.setOnline(online);\n            } else {\n                this.onOnline();\n            }\n        });\n    }\n    setOnline(online) {\n        const changed = this.online !== online;\n        if (changed) {\n            this.online = online;\n            this.onOnline();\n        }\n    }\n    onOnline() {\n        this.listeners.forEach(({ listener })=>{\n            listener();\n        });\n    }\n    isOnline() {\n        if (typeof this.online === \"boolean\") {\n            return this.online;\n        }\n        if (typeof navigator === \"undefined\" || typeof navigator.onLine === \"undefined\") {\n            return true;\n        }\n        return navigator.onLine;\n    }\n}\nconst onlineManager = new OnlineManager();\n //# sourceMappingURL=onlineManager.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL29ubGluZU1hbmFnZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0Q7QUFDWDtBQUV2QyxNQUFNRSxlQUFlO0lBQUM7SUFBVTtDQUFVO0FBQzFDLE1BQU1DLHNCQUFzQkgsMkRBQVlBO0lBQ3RDSSxhQUFjO1FBQ1osS0FBSztRQUVMLElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxDQUFBQTtZQUNYLG1FQUFtRTtZQUNuRSx1RUFBdUU7WUFDdkUsSUFBSSxDQUFDTCxnREFBUUEsSUFBSU0sT0FBT0MsZ0JBQWdCLEVBQUU7Z0JBQ3hDLE1BQU1DLFdBQVcsSUFBTUgsWUFBWSxtQkFBbUI7Z0JBR3RESixhQUFhUSxPQUFPLENBQUNDLENBQUFBO29CQUNuQkosT0FBT0MsZ0JBQWdCLENBQUNHLE9BQU9GLFVBQVU7Z0JBQzNDO2dCQUNBLE9BQU87b0JBQ0wsaURBQWlEO29CQUNqRFAsYUFBYVEsT0FBTyxDQUFDQyxDQUFBQTt3QkFDbkJKLE9BQU9LLG1CQUFtQixDQUFDRCxPQUFPRjtvQkFDcEM7Z0JBQ0Y7WUFDRjtZQUVBO1FBQ0Y7SUFDRjtJQUVBSSxjQUFjO1FBQ1osSUFBSSxDQUFDLElBQUksQ0FBQ0MsT0FBTyxFQUFFO1lBQ2pCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDVixLQUFLO1FBQ2xDO0lBQ0Y7SUFFQVcsZ0JBQWdCO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ0MsWUFBWSxJQUFJO1lBQ3hCLElBQUlDO1lBRUhBLENBQUFBLGdCQUFnQixJQUFJLENBQUNKLE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSUksY0FBY0MsSUFBSSxDQUFDLElBQUk7WUFDekUsSUFBSSxDQUFDTCxPQUFPLEdBQUdNO1FBQ2pCO0lBQ0Y7SUFFQUwsaUJBQWlCVixLQUFLLEVBQUU7UUFDdEIsSUFBSWdCO1FBRUosSUFBSSxDQUFDaEIsS0FBSyxHQUFHQTtRQUNaZ0IsQ0FBQUEsaUJBQWlCLElBQUksQ0FBQ1AsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJTyxlQUFlRixJQUFJLENBQUMsSUFBSTtRQUMzRSxJQUFJLENBQUNMLE9BQU8sR0FBR1QsTUFBTWlCLENBQUFBO1lBQ25CLElBQUksT0FBT0EsV0FBVyxXQUFXO2dCQUMvQixJQUFJLENBQUNDLFNBQVMsQ0FBQ0Q7WUFDakIsT0FBTztnQkFDTCxJQUFJLENBQUNoQixRQUFRO1lBQ2Y7UUFDRjtJQUNGO0lBRUFpQixVQUFVRCxNQUFNLEVBQUU7UUFDaEIsTUFBTUUsVUFBVSxJQUFJLENBQUNGLE1BQU0sS0FBS0E7UUFFaEMsSUFBSUUsU0FBUztZQUNYLElBQUksQ0FBQ0YsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQ2hCLFFBQVE7UUFDZjtJQUNGO0lBRUFBLFdBQVc7UUFDVCxJQUFJLENBQUNtQixTQUFTLENBQUNmLE9BQU8sQ0FBQyxDQUFDLEVBQ3RCRCxRQUFRLEVBQ1Q7WUFDQ0E7UUFDRjtJQUNGO0lBRUFpQixXQUFXO1FBQ1QsSUFBSSxPQUFPLElBQUksQ0FBQ0osTUFBTSxLQUFLLFdBQVc7WUFDcEMsT0FBTyxJQUFJLENBQUNBLE1BQU07UUFDcEI7UUFFQSxJQUFJLE9BQU9LLGNBQWMsZUFBZSxPQUFPQSxVQUFVQyxNQUFNLEtBQUssYUFBYTtZQUMvRSxPQUFPO1FBQ1Q7UUFFQSxPQUFPRCxVQUFVQyxNQUFNO0lBQ3pCO0FBRUY7QUFDQSxNQUFNQyxnQkFBZ0IsSUFBSTFCO0FBRWMsQ0FDeEMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dDEzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9vbmxpbmVNYW5hZ2VyLm1qcz8yYWE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gJy4vc3Vic2NyaWJhYmxlLm1qcyc7XG5pbXBvcnQgeyBpc1NlcnZlciB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuY29uc3Qgb25saW5lRXZlbnRzID0gWydvbmxpbmUnLCAnb2ZmbGluZSddO1xuY2xhc3MgT25saW5lTWFuYWdlciBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnNldHVwID0gb25PbmxpbmUgPT4ge1xuICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lciBkb2VzIG5vdCBleGlzdCBpbiBSZWFjdCBOYXRpdmUsIGJ1dCB3aW5kb3cgZG9lc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgIGlmICghaXNTZXJ2ZXIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiBvbk9ubGluZSgpOyAvLyBMaXN0ZW4gdG8gb25saW5lXG5cblxuICAgICAgICBvbmxpbmVFdmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIC8vIEJlIHN1cmUgdG8gdW5zdWJzY3JpYmUgaWYgYSBuZXcgaGFuZGxlciBpcyBzZXRcbiAgICAgICAgICBvbmxpbmVFdmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuXG4gIG9uU3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5jbGVhbnVwKSB7XG4gICAgICB0aGlzLnNldEV2ZW50TGlzdGVuZXIodGhpcy5zZXR1cCk7XG4gICAgfVxuICB9XG5cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHZhciBfdGhpcyRjbGVhbnVwO1xuXG4gICAgICAoX3RoaXMkY2xlYW51cCA9IHRoaXMuY2xlYW51cCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNsZWFudXAuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuY2xlYW51cCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzZXRFdmVudExpc3RlbmVyKHNldHVwKSB7XG4gICAgdmFyIF90aGlzJGNsZWFudXAyO1xuXG4gICAgdGhpcy5zZXR1cCA9IHNldHVwO1xuICAgIChfdGhpcyRjbGVhbnVwMiA9IHRoaXMuY2xlYW51cCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNsZWFudXAyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5jbGVhbnVwID0gc2V0dXAob25saW5lID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb25saW5lID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5zZXRPbmxpbmUob25saW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25PbmxpbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldE9ubGluZShvbmxpbmUpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5vbmxpbmUgIT09IG9ubGluZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLm9ubGluZSA9IG9ubGluZTtcbiAgICAgIHRoaXMub25PbmxpbmUoKTtcbiAgICB9XG4gIH1cblxuICBvbk9ubGluZSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCh7XG4gICAgICBsaXN0ZW5lclxuICAgIH0pID0+IHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gIH1cblxuICBpc09ubGluZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub25saW5lID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm9ubGluZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG5hdmlnYXRvci5vbkxpbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF2aWdhdG9yLm9uTGluZTtcbiAgfVxuXG59XG5jb25zdCBvbmxpbmVNYW5hZ2VyID0gbmV3IE9ubGluZU1hbmFnZXIoKTtcblxuZXhwb3J0IHsgT25saW5lTWFuYWdlciwgb25saW5lTWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25saW5lTWFuYWdlci5tanMubWFwXG4iXSwibmFtZXMiOlsiU3Vic2NyaWJhYmxlIiwiaXNTZXJ2ZXIiLCJvbmxpbmVFdmVudHMiLCJPbmxpbmVNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJzZXR1cCIsIm9uT25saW5lIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiZm9yRWFjaCIsImV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uU3Vic2NyaWJlIiwiY2xlYW51cCIsInNldEV2ZW50TGlzdGVuZXIiLCJvblVuc3Vic2NyaWJlIiwiaGFzTGlzdGVuZXJzIiwiX3RoaXMkY2xlYW51cCIsImNhbGwiLCJ1bmRlZmluZWQiLCJfdGhpcyRjbGVhbnVwMiIsIm9ubGluZSIsInNldE9ubGluZSIsImNoYW5nZWQiLCJsaXN0ZW5lcnMiLCJpc09ubGluZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsIm9ubGluZU1hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/onlineManager.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/query.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/query.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Query: () => (/* binding */ Query)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n/* harmony import */ var _logger_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/logger.mjs\");\n/* harmony import */ var _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./notifyManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs\");\n/* harmony import */ var _retryer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./retryer.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/retryer.mjs\");\n/* harmony import */ var _removable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/removable.mjs\");\n\n\n\n\n\n// CLASS\nclass Query extends _removable_mjs__WEBPACK_IMPORTED_MODULE_0__.Removable {\n    constructor(config){\n        super();\n        this.abortSignalConsumed = false;\n        this.defaultOptions = config.defaultOptions;\n        this.setOptions(config.options);\n        this.observers = [];\n        this.cache = config.cache;\n        this.logger = config.logger || _logger_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultLogger;\n        this.queryKey = config.queryKey;\n        this.queryHash = config.queryHash;\n        this.initialState = config.state || getDefaultState(this.options);\n        this.state = this.initialState;\n        this.scheduleGc();\n    }\n    get meta() {\n        return this.options.meta;\n    }\n    setOptions(options) {\n        this.options = {\n            ...this.defaultOptions,\n            ...options\n        };\n        this.updateCacheTime(this.options.cacheTime);\n    }\n    optionalRemove() {\n        if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n            this.cache.remove(this);\n        }\n    }\n    setData(newData, options) {\n        const data = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.replaceData)(this.state.data, newData, this.options); // Set data and mark it as cached\n        this.dispatch({\n            data,\n            type: \"success\",\n            dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n            manual: options == null ? void 0 : options.manual\n        });\n        return data;\n    }\n    setState(state, setStateOptions) {\n        this.dispatch({\n            type: \"setState\",\n            state,\n            setStateOptions\n        });\n    }\n    cancel(options) {\n        var _this$retryer;\n        const promise = this.promise;\n        (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n        return promise ? promise.then(_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.noop).catch(_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.noop) : Promise.resolve();\n    }\n    destroy() {\n        super.destroy();\n        this.cancel({\n            silent: true\n        });\n    }\n    reset() {\n        this.destroy();\n        this.setState(this.initialState);\n    }\n    isActive() {\n        return this.observers.some((observer)=>observer.options.enabled !== false);\n    }\n    isDisabled() {\n        return this.getObserversCount() > 0 && !this.isActive();\n    }\n    isStale() {\n        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer)=>observer.getCurrentResult().isStale);\n    }\n    isStaleByTime(staleTime = 0) {\n        return this.state.isInvalidated || !this.state.dataUpdatedAt || !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.timeUntilStale)(this.state.dataUpdatedAt, staleTime);\n    }\n    onFocus() {\n        var _this$retryer2;\n        const observer = this.observers.find((x)=>x.shouldFetchOnWindowFocus());\n        if (observer) {\n            observer.refetch({\n                cancelRefetch: false\n            });\n        } // Continue fetch if currently paused\n        (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n    }\n    onOnline() {\n        var _this$retryer3;\n        const observer = this.observers.find((x)=>x.shouldFetchOnReconnect());\n        if (observer) {\n            observer.refetch({\n                cancelRefetch: false\n            });\n        } // Continue fetch if currently paused\n        (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n    }\n    addObserver(observer) {\n        if (!this.observers.includes(observer)) {\n            this.observers.push(observer); // Stop the query from being garbage collected\n            this.clearGcTimeout();\n            this.cache.notify({\n                type: \"observerAdded\",\n                query: this,\n                observer\n            });\n        }\n    }\n    removeObserver(observer) {\n        if (this.observers.includes(observer)) {\n            this.observers = this.observers.filter((x)=>x !== observer);\n            if (!this.observers.length) {\n                // If the transport layer does not support cancellation\n                // we'll let the query continue so the result can be cached\n                if (this.retryer) {\n                    if (this.abortSignalConsumed) {\n                        this.retryer.cancel({\n                            revert: true\n                        });\n                    } else {\n                        this.retryer.cancelRetry();\n                    }\n                }\n                this.scheduleGc();\n            }\n            this.cache.notify({\n                type: \"observerRemoved\",\n                query: this,\n                observer\n            });\n        }\n    }\n    getObserversCount() {\n        return this.observers.length;\n    }\n    invalidate() {\n        if (!this.state.isInvalidated) {\n            this.dispatch({\n                type: \"invalidate\"\n            });\n        }\n    }\n    fetch(options, fetchOptions) {\n        var _this$options$behavio, _context$fetchOptions;\n        if (this.state.fetchStatus !== \"idle\") {\n            if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n                // Silently cancel current fetch if the user wants to cancel refetches\n                this.cancel({\n                    silent: true\n                });\n            } else if (this.promise) {\n                var _this$retryer4;\n                // make sure that retries that were potentially cancelled due to unmounts can continue\n                (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n                return this.promise;\n            }\n        } // Update config if passed, otherwise the config from the last execution is used\n        if (options) {\n            this.setOptions(options);\n        } // Use the options from the first observer with a query function if no function is found.\n        // This can happen when the query is hydrated or created with setQueryData.\n        if (!this.options.queryFn) {\n            const observer = this.observers.find((x)=>x.options.queryFn);\n            if (observer) {\n                this.setOptions(observer.options);\n            }\n        }\n        if (true) {\n            if (!Array.isArray(this.options.queryKey)) {\n                this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n            }\n        }\n        const abortController = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.getAbortController)(); // Create query function context\n        const queryFnContext = {\n            queryKey: this.queryKey,\n            pageParam: undefined,\n            meta: this.meta\n        }; // Adds an enumerable signal property to the object that\n        // which sets abortSignalConsumed to true when the signal\n        // is read.\n        const addSignalProperty = (object)=>{\n            Object.defineProperty(object, \"signal\", {\n                enumerable: true,\n                get: ()=>{\n                    if (abortController) {\n                        this.abortSignalConsumed = true;\n                        return abortController.signal;\n                    }\n                    return undefined;\n                }\n            });\n        };\n        addSignalProperty(queryFnContext); // Create fetch function\n        const fetchFn = ()=>{\n            if (!this.options.queryFn) {\n                return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n            }\n            this.abortSignalConsumed = false;\n            return this.options.queryFn(queryFnContext);\n        }; // Trigger behavior hook\n        const context = {\n            fetchOptions,\n            options: this.options,\n            queryKey: this.queryKey,\n            state: this.state,\n            fetchFn\n        };\n        addSignalProperty(context);\n        (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n        this.revertState = this.state; // Set to fetching state if not already in it\n        if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n            var _context$fetchOptions2;\n            this.dispatch({\n                type: \"fetch\",\n                meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n            });\n        }\n        const onError = (error)=>{\n            // Optimistically update state if needed\n            if (!((0,_retryer_mjs__WEBPACK_IMPORTED_MODULE_3__.isCancelledError)(error) && error.silent)) {\n                this.dispatch({\n                    type: \"error\",\n                    error: error\n                });\n            }\n            if (!(0,_retryer_mjs__WEBPACK_IMPORTED_MODULE_3__.isCancelledError)(error)) {\n                var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n                // Notify cache callback\n                (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n                (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n                if (true) {\n                    this.logger.error(error);\n                }\n            }\n            if (!this.isFetchingOptimistic) {\n                // Schedule query gc after fetching\n                this.scheduleGc();\n            }\n            this.isFetchingOptimistic = false;\n        }; // Try to fetch the data\n        this.retryer = (0,_retryer_mjs__WEBPACK_IMPORTED_MODULE_3__.createRetryer)({\n            fn: context.fetchFn,\n            abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n            onSuccess: (data)=>{\n                var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n                if (typeof data === \"undefined\") {\n                    if (true) {\n                        this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n                    }\n                    onError(new Error(this.queryHash + \" data is undefined\"));\n                    return;\n                }\n                this.setData(data); // Notify cache callback\n                (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n                (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n                if (!this.isFetchingOptimistic) {\n                    // Schedule query gc after fetching\n                    this.scheduleGc();\n                }\n                this.isFetchingOptimistic = false;\n            },\n            onError,\n            onFail: (failureCount, error)=>{\n                this.dispatch({\n                    type: \"failed\",\n                    failureCount,\n                    error\n                });\n            },\n            onPause: ()=>{\n                this.dispatch({\n                    type: \"pause\"\n                });\n            },\n            onContinue: ()=>{\n                this.dispatch({\n                    type: \"continue\"\n                });\n            },\n            retry: context.options.retry,\n            retryDelay: context.options.retryDelay,\n            networkMode: context.options.networkMode\n        });\n        this.promise = this.retryer.promise;\n        return this.promise;\n    }\n    dispatch(action) {\n        const reducer = (state)=>{\n            var _action$meta, _action$dataUpdatedAt;\n            switch(action.type){\n                case \"failed\":\n                    return {\n                        ...state,\n                        fetchFailureCount: action.failureCount,\n                        fetchFailureReason: action.error\n                    };\n                case \"pause\":\n                    return {\n                        ...state,\n                        fetchStatus: \"paused\"\n                    };\n                case \"continue\":\n                    return {\n                        ...state,\n                        fetchStatus: \"fetching\"\n                    };\n                case \"fetch\":\n                    return {\n                        ...state,\n                        fetchFailureCount: 0,\n                        fetchFailureReason: null,\n                        fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n                        fetchStatus: (0,_retryer_mjs__WEBPACK_IMPORTED_MODULE_3__.canFetch)(this.options.networkMode) ? \"fetching\" : \"paused\",\n                        ...!state.dataUpdatedAt && {\n                            error: null,\n                            status: \"loading\"\n                        }\n                    };\n                case \"success\":\n                    return {\n                        ...state,\n                        data: action.data,\n                        dataUpdateCount: state.dataUpdateCount + 1,\n                        dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n                        error: null,\n                        isInvalidated: false,\n                        status: \"success\",\n                        ...!action.manual && {\n                            fetchStatus: \"idle\",\n                            fetchFailureCount: 0,\n                            fetchFailureReason: null\n                        }\n                    };\n                case \"error\":\n                    const error = action.error;\n                    if ((0,_retryer_mjs__WEBPACK_IMPORTED_MODULE_3__.isCancelledError)(error) && error.revert && this.revertState) {\n                        return {\n                            ...this.revertState,\n                            fetchStatus: \"idle\"\n                        };\n                    }\n                    return {\n                        ...state,\n                        error: error,\n                        errorUpdateCount: state.errorUpdateCount + 1,\n                        errorUpdatedAt: Date.now(),\n                        fetchFailureCount: state.fetchFailureCount + 1,\n                        fetchFailureReason: error,\n                        fetchStatus: \"idle\",\n                        status: \"error\"\n                    };\n                case \"invalidate\":\n                    return {\n                        ...state,\n                        isInvalidated: true\n                    };\n                case \"setState\":\n                    return {\n                        ...state,\n                        ...action.state\n                    };\n            }\n        };\n        this.state = reducer(this.state);\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_4__.notifyManager.batch(()=>{\n            this.observers.forEach((observer)=>{\n                observer.onQueryUpdate(action);\n            });\n            this.cache.notify({\n                query: this,\n                type: \"updated\",\n                action\n            });\n        });\n    }\n}\nfunction getDefaultState(options) {\n    const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n    const hasData = typeof data !== \"undefined\";\n    const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n    return {\n        data,\n        dataUpdateCount: 0,\n        dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n        error: null,\n        errorUpdateCount: 0,\n        errorUpdatedAt: 0,\n        fetchFailureCount: 0,\n        fetchFailureReason: null,\n        fetchMeta: null,\n        isInvalidated: false,\n        status: hasData ? \"success\" : \"loading\",\n        fetchStatus: \"idle\"\n    };\n}\n //# sourceMappingURL=query.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3F1ZXJ5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Y7QUFDdkM7QUFDTztBQUNzQjtBQUM5QjtBQUU1QyxRQUFRO0FBQ1IsTUFBTVUsY0FBY0QscURBQVNBO0lBQzNCRSxZQUFZQyxNQUFNLENBQUU7UUFDbEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc7UUFDM0IsSUFBSSxDQUFDQyxjQUFjLEdBQUdGLE9BQU9FLGNBQWM7UUFDM0MsSUFBSSxDQUFDQyxVQUFVLENBQUNILE9BQU9JLE9BQU87UUFDOUIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLEtBQUssR0FBR04sT0FBT00sS0FBSztRQUN6QixJQUFJLENBQUNDLE1BQU0sR0FBR1AsT0FBT08sTUFBTSxJQUFJZixzREFBYUE7UUFDNUMsSUFBSSxDQUFDZ0IsUUFBUSxHQUFHUixPQUFPUSxRQUFRO1FBQy9CLElBQUksQ0FBQ0MsU0FBUyxHQUFHVCxPQUFPUyxTQUFTO1FBQ2pDLElBQUksQ0FBQ0MsWUFBWSxHQUFHVixPQUFPVyxLQUFLLElBQUlDLGdCQUFnQixJQUFJLENBQUNSLE9BQU87UUFDaEUsSUFBSSxDQUFDTyxLQUFLLEdBQUcsSUFBSSxDQUFDRCxZQUFZO1FBQzlCLElBQUksQ0FBQ0csVUFBVTtJQUNqQjtJQUVBLElBQUlDLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ1YsT0FBTyxDQUFDVSxJQUFJO0lBQzFCO0lBRUFYLFdBQVdDLE9BQU8sRUFBRTtRQUNsQixJQUFJLENBQUNBLE9BQU8sR0FBRztZQUFFLEdBQUcsSUFBSSxDQUFDRixjQUFjO1lBQ3JDLEdBQUdFLE9BQU87UUFDWjtRQUNBLElBQUksQ0FBQ1csZUFBZSxDQUFDLElBQUksQ0FBQ1gsT0FBTyxDQUFDWSxTQUFTO0lBQzdDO0lBRUFDLGlCQUFpQjtRQUNmLElBQUksQ0FBQyxJQUFJLENB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RCxrQkFBa0I7UUFDbEJDLGdCQUFnQjtRQUNoQlAsbUJBQW1CO1FBQ25CQyxvQkFBb0I7UUFDcEIvQixXQUFXO1FBQ1h0RCxlQUFlO1FBQ2ZzRixRQUFRVSxVQUFVLFlBQVk7UUFDOUI5SCxhQUFhO0lBQ2Y7QUFDRjtBQUVpQixDQUNqQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3F1ZXJ5Lm1qcz80ODkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlcGxhY2VEYXRhLCBub29wLCB0aW1lVW50aWxTdGFsZSwgZ2V0QWJvcnRDb250cm9sbGVyIH0gZnJvbSAnLi91dGlscy5tanMnO1xuaW1wb3J0IHsgZGVmYXVsdExvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLm1qcyc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZXRyeWVyLCBpc0NhbmNlbGxlZEVycm9yLCBjYW5GZXRjaCB9IGZyb20gJy4vcmV0cnllci5tanMnO1xuaW1wb3J0IHsgUmVtb3ZhYmxlIH0gZnJvbSAnLi9yZW1vdmFibGUubWpzJztcblxuLy8gQ0xBU1NcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgUmVtb3ZhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFib3J0U2lnbmFsQ29uc3VtZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLmNhY2hlID0gY29uZmlnLmNhY2hlO1xuICAgIHRoaXMubG9nZ2VyID0gY29uZmlnLmxvZ2dlciB8fCBkZWZhdWx0TG9nZ2VyO1xuICAgIHRoaXMucXVlcnlLZXkgPSBjb25maWcucXVlcnlLZXk7XG4gICAgdGhpcy5xdWVyeUhhc2ggPSBjb25maWcucXVlcnlIYXNoO1xuICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gY29uZmlnLnN0YXRlIHx8IGdldERlZmF1bHRTdGF0ZSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgfVxuXG4gIGdldCBtZXRhKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWV0YTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlQ2FjaGVUaW1lKHRoaXMub3B0aW9ucy5jYWNoZVRpbWUpO1xuICB9XG5cbiAgb3B0aW9uYWxSZW1vdmUoKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5zdGF0ZS5mZXRjaFN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICB0aGlzLmNhY2hlLnJlbW92ZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBzZXREYXRhKG5ld0RhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXRhID0gcmVwbGFjZURhdGEodGhpcy5zdGF0ZS5kYXRhLCBuZXdEYXRhLCB0aGlzLm9wdGlvbnMpOyAvLyBTZXQgZGF0YSBhbmQgbWFyayBpdCBhcyBjYWNoZWRcblxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgZGF0YSxcbiAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgIGRhdGFVcGRhdGVkQXQ6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudXBkYXRlZEF0LFxuICAgICAgbWFudWFsOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1hbnVhbFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgc2V0U3RhdGUoc3RhdGUsIHNldFN0YXRlT3B0aW9ucykge1xuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ3NldFN0YXRlJyxcbiAgICAgIHN0YXRlLFxuICAgICAgc2V0U3RhdGVPcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICBjYW5jZWwob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyRyZXRyeWVyO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICAoX3RoaXMkcmV0cnllciA9IHRoaXMucmV0cnllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHJldHJ5ZXIuY2FuY2VsKG9wdGlvbnMpO1xuICAgIHJldHVybiBwcm9taXNlID8gcHJvbWlzZS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbmNlbCh7XG4gICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuc2V0U3RhdGUodGhpcy5pbml0aWFsU3RhdGUpO1xuICB9XG5cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNvbWUob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIub3B0aW9ucy5lbmFibGVkICE9PSBmYWxzZSk7XG4gIH1cblxuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE9ic2VydmVyc0NvdW50KCkgPiAwICYmICF0aGlzLmlzQWN0aXZlKCk7XG4gIH1cblxuICBpc1N0YWxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzSW52YWxpZGF0ZWQgfHwgIXRoaXMuc3RhdGUuZGF0YVVwZGF0ZWRBdCB8fCB0aGlzLm9ic2VydmVycy5zb21lKG9ic2VydmVyID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKS5pc1N0YWxlKTtcbiAgfVxuXG4gIGlzU3RhbGVCeVRpbWUoc3RhbGVUaW1lID0gMCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzSW52YWxpZGF0ZWQgfHwgIXRoaXMuc3RhdGUuZGF0YVVwZGF0ZWRBdCB8fCAhdGltZVVudGlsU3RhbGUodGhpcy5zdGF0ZS5kYXRhVXBkYXRlZEF0LCBzdGFsZVRpbWUpO1xuICB9XG5cbiAgb25Gb2N1cygpIHtcbiAgICB2YXIgX3RoaXMkcmV0cnllcjI7XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoeCA9PiB4LnNob3VsZEZldGNoT25XaW5kb3dGb2N1cygpKTtcblxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVmZXRjaCh7XG4gICAgICAgIGNhbmNlbFJlZmV0Y2g6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IC8vIENvbnRpbnVlIGZldGNoIGlmIGN1cnJlbnRseSBwYXVzZWRcblxuXG4gICAgKF90aGlzJHJldHJ5ZXIyID0gdGhpcy5yZXRyeWVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmV0cnllcjIuY29udGludWUoKTtcbiAgfVxuXG4gIG9uT25saW5lKCkge1xuICAgIHZhciBfdGhpcyRyZXRyeWVyMztcblxuICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcnMuZmluZCh4ID0+IHguc2hvdWxkRmV0Y2hPblJlY29ubmVjdCgpKTtcblxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVmZXRjaCh7XG4gICAgICAgIGNhbmNlbFJlZmV0Y2g6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IC8vIENvbnRpbnVlIGZldGNoIGlmIGN1cnJlbnRseSBwYXVzZWRcblxuXG4gICAgKF90aGlzJHJldHJ5ZXIzID0gdGhpcy5yZXRyeWVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmV0cnllcjMuY29udGludWUoKTtcbiAgfVxuXG4gIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpOyAvLyBTdG9wIHRoZSBxdWVyeSBmcm9tIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkXG5cbiAgICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgICAgIHRoaXMuY2FjaGUubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ29ic2VydmVyQWRkZWQnLFxuICAgICAgICBxdWVyeTogdGhpcyxcbiAgICAgICAgb2JzZXJ2ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzLmluY2x1ZGVzKG9ic2VydmVyKSkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycy5maWx0ZXIoeCA9PiB4ICE9PSBvYnNlcnZlcik7XG5cbiAgICAgIGlmICghdGhpcy5vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCBjYW5jZWxsYXRpb25cbiAgICAgICAgLy8gd2UnbGwgbGV0IHRoZSBxdWVyeSBjb250aW51ZSBzbyB0aGUgcmVzdWx0IGNhbiBiZSBjYWNoZWRcbiAgICAgICAgaWYgKHRoaXMucmV0cnllcikge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0U2lnbmFsQ29uc3VtZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnllci5jYW5jZWwoe1xuICAgICAgICAgICAgICByZXZlcnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5ZXIuY2FuY2VsUmV0cnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZS5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAnb2JzZXJ2ZXJSZW1vdmVkJyxcbiAgICAgICAgcXVlcnk6IHRoaXMsXG4gICAgICAgIG9ic2VydmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRPYnNlcnZlcnNDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMubGVuZ3RoO1xuICB9XG5cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdpbnZhbGlkYXRlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZmV0Y2gob3B0aW9ucywgZmV0Y2hPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMkYmVoYXZpbywgX2NvbnRleHQkZmV0Y2hPcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgIT09ICdpZGxlJykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuZGF0YVVwZGF0ZWRBdCAmJiBmZXRjaE9wdGlvbnMgIT0gbnVsbCAmJiBmZXRjaE9wdGlvbnMuY2FuY2VsUmVmZXRjaCkge1xuICAgICAgICAvLyBTaWxlbnRseSBjYW5jZWwgY3VycmVudCBmZXRjaCBpZiB0aGUgdXNlciB3YW50cyB0byBjYW5jZWwgcmVmZXRjaGVzXG4gICAgICAgIHRoaXMuY2FuY2VsKHtcbiAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgICB2YXIgX3RoaXMkcmV0cnllcjQ7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgcmV0cmllcyB0aGF0IHdlcmUgcG90ZW50aWFsbHkgY2FuY2VsbGVkIGR1ZSB0byB1bm1vdW50cyBjYW4gY29udGludWVcbiAgICAgICAgKF90aGlzJHJldHJ5ZXI0ID0gdGhpcy5yZXRyeWVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmV0cnllcjQuY29udGludWVSZXRyeSgpOyAvLyBSZXR1cm4gY3VycmVudCBwcm9taXNlIGlmIHdlIGFyZSBhbHJlYWR5IGZldGNoaW5nXG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9IC8vIFVwZGF0ZSBjb25maWcgaWYgcGFzc2VkLCBvdGhlcndpc2UgdGhlIGNvbmZpZyBmcm9tIHRoZSBsYXN0IGV4ZWN1dGlvbiBpcyB1c2VkXG5cblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSAvLyBVc2UgdGhlIG9wdGlvbnMgZnJvbSB0aGUgZmlyc3Qgb2JzZXJ2ZXIgd2l0aCBhIHF1ZXJ5IGZ1bmN0aW9uIGlmIG5vIGZ1bmN0aW9uIGlzIGZvdW5kLlxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSBxdWVyeSBpcyBoeWRyYXRlZCBvciBjcmVhdGVkIHdpdGggc2V0UXVlcnlEYXRhLlxuXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5xdWVyeUZuKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoeCA9PiB4Lm9wdGlvbnMucXVlcnlGbik7XG5cbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob2JzZXJ2ZXIub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMucXVlcnlLZXkpKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiQXMgb2YgdjQsIHF1ZXJ5S2V5IG5lZWRzIHRvIGJlIGFuIEFycmF5LiBJZiB5b3UgYXJlIHVzaW5nIGEgc3RyaW5nIGxpa2UgJ3JlcG9EYXRhJywgcGxlYXNlIGNoYW5nZSBpdCB0byBhbiBBcnJheSwgZS5nLiBbJ3JlcG9EYXRhJ11cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gZ2V0QWJvcnRDb250cm9sbGVyKCk7IC8vIENyZWF0ZSBxdWVyeSBmdW5jdGlvbiBjb250ZXh0XG5cbiAgICBjb25zdCBxdWVyeUZuQ29udGV4dCA9IHtcbiAgICAgIHF1ZXJ5S2V5OiB0aGlzLnF1ZXJ5S2V5LFxuICAgICAgcGFnZVBhcmFtOiB1bmRlZmluZWQsXG4gICAgICBtZXRhOiB0aGlzLm1ldGFcbiAgICB9OyAvLyBBZGRzIGFuIGVudW1lcmFibGUgc2lnbmFsIHByb3BlcnR5IHRvIHRoZSBvYmplY3QgdGhhdFxuICAgIC8vIHdoaWNoIHNldHMgYWJvcnRTaWduYWxDb25zdW1lZCB0byB0cnVlIHdoZW4gdGhlIHNpZ25hbFxuICAgIC8vIGlzIHJlYWQuXG5cbiAgICBjb25zdCBhZGRTaWduYWxQcm9wZXJ0eSA9IG9iamVjdCA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2lnbmFsJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0U2lnbmFsQ29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFkZFNpZ25hbFByb3BlcnR5KHF1ZXJ5Rm5Db250ZXh0KTsgLy8gQ3JlYXRlIGZldGNoIGZ1bmN0aW9uXG5cbiAgICBjb25zdCBmZXRjaEZuID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucXVlcnlGbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJNaXNzaW5nIHF1ZXJ5Rm4gZm9yIHF1ZXJ5S2V5ICdcIiArIHRoaXMub3B0aW9ucy5xdWVyeUhhc2ggKyBcIidcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWJvcnRTaWduYWxDb25zdW1lZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5xdWVyeUZuKHF1ZXJ5Rm5Db250ZXh0KTtcbiAgICB9OyAvLyBUcmlnZ2VyIGJlaGF2aW9yIGhvb2tcblxuXG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHF1ZXJ5S2V5OiB0aGlzLnF1ZXJ5S2V5LFxuICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICBmZXRjaEZuXG4gICAgfTtcbiAgICBhZGRTaWduYWxQcm9wZXJ0eShjb250ZXh0KTtcbiAgICAoX3RoaXMkb3B0aW9ucyRiZWhhdmlvID0gdGhpcy5vcHRpb25zLmJlaGF2aW9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucyRiZWhhdmlvLm9uRmV0Y2goY29udGV4dCk7IC8vIFN0b3JlIHN0YXRlIGluIGNhc2UgdGhlIGN1cnJlbnQgZmV0Y2ggbmVlZHMgdG8gYmUgcmV2ZXJ0ZWRcblxuICAgIHRoaXMucmV2ZXJ0U3RhdGUgPSB0aGlzLnN0YXRlOyAvLyBTZXQgdG8gZmV0Y2hpbmcgc3RhdGUgaWYgbm90IGFscmVhZHkgaW4gaXRcblxuICAgIGlmICh0aGlzLnN0YXRlLmZldGNoU3RhdHVzID09PSAnaWRsZScgfHwgdGhpcy5zdGF0ZS5mZXRjaE1ldGEgIT09ICgoX2NvbnRleHQkZmV0Y2hPcHRpb25zID0gY29udGV4dC5mZXRjaE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRmZXRjaE9wdGlvbnMubWV0YSkpIHtcbiAgICAgIHZhciBfY29udGV4dCRmZXRjaE9wdGlvbnMyO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ2ZldGNoJyxcbiAgICAgICAgbWV0YTogKF9jb250ZXh0JGZldGNoT3B0aW9uczIgPSBjb250ZXh0LmZldGNoT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JGZldGNoT3B0aW9uczIubWV0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb25FcnJvciA9IGVycm9yID0+IHtcbiAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSBzdGF0ZSBpZiBuZWVkZWRcbiAgICAgIGlmICghKGlzQ2FuY2VsbGVkRXJyb3IoZXJyb3IpICYmIGVycm9yLnNpbGVudCkpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNDYW5jZWxsZWRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgdmFyIF90aGlzJGNhY2hlJGNvbmZpZyRvbiwgX3RoaXMkY2FjaGUkY29uZmlnLCBfdGhpcyRjYWNoZSRjb25maWckb24yLCBfdGhpcyRjYWNoZSRjb25maWcyO1xuXG4gICAgICAgIC8vIE5vdGlmeSBjYWNoZSBjYWxsYmFja1xuICAgICAgICAoX3RoaXMkY2FjaGUkY29uZmlnJG9uID0gKF90aGlzJGNhY2hlJGNvbmZpZyA9IHRoaXMuY2FjaGUuY29uZmlnKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FjaGUkY29uZmlnJG9uLmNhbGwoX3RoaXMkY2FjaGUkY29uZmlnLCBlcnJvciwgdGhpcyk7XG4gICAgICAgIChfdGhpcyRjYWNoZSRjb25maWckb24yID0gKF90aGlzJGNhY2hlJGNvbmZpZzIgPSB0aGlzLmNhY2hlLmNvbmZpZykub25TZXR0bGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FjaGUkY29uZmlnJG9uMi5jYWxsKF90aGlzJGNhY2hlJGNvbmZpZzIsIHRoaXMuc3RhdGUuZGF0YSwgZXJyb3IsIHRoaXMpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYykge1xuICAgICAgICAvLyBTY2hlZHVsZSBxdWVyeSBnYyBhZnRlciBmZXRjaGluZ1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYyA9IGZhbHNlO1xuICAgIH07IC8vIFRyeSB0byBmZXRjaCB0aGUgZGF0YVxuXG5cbiAgICB0aGlzLnJldHJ5ZXIgPSBjcmVhdGVSZXRyeWVyKHtcbiAgICAgIGZuOiBjb250ZXh0LmZldGNoRm4sXG4gICAgICBhYm9ydDogYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuYWJvcnQuYmluZChhYm9ydENvbnRyb2xsZXIpLFxuICAgICAgb25TdWNjZXNzOiBkYXRhID0+IHtcbiAgICAgICAgdmFyIF90aGlzJGNhY2hlJGNvbmZpZyRvbjMsIF90aGlzJGNhY2hlJGNvbmZpZzMsIF90aGlzJGNhY2hlJGNvbmZpZyRvbjQsIF90aGlzJGNhY2hlJGNvbmZpZzQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlF1ZXJ5IGRhdGEgY2Fubm90IGJlIHVuZGVmaW5lZC4gUGxlYXNlIG1ha2Ugc3VyZSB0byByZXR1cm4gYSB2YWx1ZSBvdGhlciB0aGFuIHVuZGVmaW5lZCBmcm9tIHlvdXIgcXVlcnkgZnVuY3Rpb24uIEFmZmVjdGVkIHF1ZXJ5IGtleTogXCIgKyB0aGlzLnF1ZXJ5SGFzaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IodGhpcy5xdWVyeUhhc2ggKyBcIiBkYXRhIGlzIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREYXRhKGRhdGEpOyAvLyBOb3RpZnkgY2FjaGUgY2FsbGJhY2tcblxuICAgICAgICAoX3RoaXMkY2FjaGUkY29uZmlnJG9uMyA9IChfdGhpcyRjYWNoZSRjb25maWczID0gdGhpcy5jYWNoZS5jb25maWcpLm9uU3VjY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhY2hlJGNvbmZpZyRvbjMuY2FsbChfdGhpcyRjYWNoZSRjb25maWczLCBkYXRhLCB0aGlzKTtcbiAgICAgICAgKF90aGlzJGNhY2hlJGNvbmZpZyRvbjQgPSAoX3RoaXMkY2FjaGUkY29uZmlnNCA9IHRoaXMuY2FjaGUuY29uZmlnKS5vblNldHRsZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWNoZSRjb25maWckb240LmNhbGwoX3RoaXMkY2FjaGUkY29uZmlnNCwgZGF0YSwgdGhpcy5zdGF0ZS5lcnJvciwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRmV0Y2hpbmdPcHRpbWlzdGljKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgcXVlcnkgZ2MgYWZ0ZXIgZmV0Y2hpbmdcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNGZXRjaGluZ09wdGltaXN0aWMgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yLFxuICAgICAgb25GYWlsOiAoZmFpbHVyZUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnZmFpbGVkJyxcbiAgICAgICAgICBmYWlsdXJlQ291bnQsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAncGF1c2UnXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uQ29udGludWU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ2NvbnRpbnVlJ1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZXRyeTogY29udGV4dC5vcHRpb25zLnJldHJ5LFxuICAgICAgcmV0cnlEZWxheTogY29udGV4dC5vcHRpb25zLnJldHJ5RGVsYXksXG4gICAgICBuZXR3b3JrTW9kZTogY29udGV4dC5vcHRpb25zLm5ldHdvcmtNb2RlXG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlID0gdGhpcy5yZXRyeWVyLnByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGNvbnN0IHJlZHVjZXIgPSBzdGF0ZSA9PiB7XG4gICAgICB2YXIgX2FjdGlvbiRtZXRhLCBfYWN0aW9uJGRhdGFVcGRhdGVkQXQ7XG5cbiAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiBhY3Rpb24uZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ3BhdXNlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiAncGF1c2VkJ1xuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6ICdmZXRjaGluZydcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ2ZldGNoJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZmV0Y2hNZXRhOiAoX2FjdGlvbiRtZXRhID0gYWN0aW9uLm1ldGEpICE9IG51bGwgPyBfYWN0aW9uJG1ldGEgOiBudWxsLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IGNhbkZldGNoKHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZSkgPyAnZmV0Y2hpbmcnIDogJ3BhdXNlZCcsXG4gICAgICAgICAgICAuLi4oIXN0YXRlLmRhdGFVcGRhdGVkQXQgJiYge1xuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnbG9hZGluZydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGRhdGE6IGFjdGlvbi5kYXRhLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZUNvdW50OiBzdGF0ZS5kYXRhVXBkYXRlQ291bnQgKyAxLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZWRBdDogKF9hY3Rpb24kZGF0YVVwZGF0ZWRBdCA9IGFjdGlvbi5kYXRhVXBkYXRlZEF0KSAhPSBudWxsID8gX2FjdGlvbiRkYXRhVXBkYXRlZEF0IDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIC4uLighYWN0aW9uLm1hbnVhbCAmJiB7XG4gICAgICAgICAgICAgIGZldGNoU3RhdHVzOiAnaWRsZScsXG4gICAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBhY3Rpb24uZXJyb3I7XG5cbiAgICAgICAgICBpZiAoaXNDYW5jZWxsZWRFcnJvcihlcnJvcikgJiYgZXJyb3IucmV2ZXJ0ICYmIHRoaXMucmV2ZXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnRoaXMucmV2ZXJ0U3RhdGUsXG4gICAgICAgICAgICAgIGZldGNoU3RhdHVzOiAnaWRsZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBlcnJvclVwZGF0ZUNvdW50OiBzdGF0ZS5lcnJvclVwZGF0ZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGVycm9yVXBkYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlQ291bnQ6IHN0YXRlLmZldGNoRmFpbHVyZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZVJlYXNvbjogZXJyb3IsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogJ2lkbGUnLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdpbnZhbGlkYXRlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzSW52YWxpZGF0ZWQ6IHRydWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ3NldFN0YXRlJzpcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICAgIC4uLmFjdGlvbi5zdGF0ZVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc3RhdGUgPSByZWR1Y2VyKHRoaXMuc3RhdGUpO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgIG9ic2VydmVyLm9uUXVlcnlVcGRhdGUoYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWNoZS5ub3RpZnkoe1xuICAgICAgICBxdWVyeTogdGhpcyxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZWQnLFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0YXRlKG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxEYXRhID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5pbml0aWFsRGF0YSgpIDogb3B0aW9ucy5pbml0aWFsRGF0YTtcbiAgY29uc3QgaGFzRGF0YSA9IHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJztcbiAgY29uc3QgaW5pdGlhbERhdGFVcGRhdGVkQXQgPSBoYXNEYXRhID8gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0KCkgOiBvcHRpb25zLmluaXRpYWxEYXRhVXBkYXRlZEF0IDogMDtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGRhdGFVcGRhdGVDb3VudDogMCxcbiAgICBkYXRhVXBkYXRlZEF0OiBoYXNEYXRhID8gaW5pdGlhbERhdGFVcGRhdGVkQXQgIT0gbnVsbCA/IGluaXRpYWxEYXRhVXBkYXRlZEF0IDogRGF0ZS5ub3coKSA6IDAsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgZXJyb3JVcGRhdGVDb3VudDogMCxcbiAgICBlcnJvclVwZGF0ZWRBdDogMCxcbiAgICBmZXRjaEZhaWx1cmVDb3VudDogMCxcbiAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgZmV0Y2hNZXRhOiBudWxsLFxuICAgIGlzSW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgIHN0YXR1czogaGFzRGF0YSA/ICdzdWNjZXNzJyA6ICdsb2FkaW5nJyxcbiAgICBmZXRjaFN0YXR1czogJ2lkbGUnXG4gIH07XG59XG5cbmV4cG9ydCB7IFF1ZXJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5tanMubWFwXG4iXSwibmFtZXMiOlsicmVwbGFjZURhdGEiLCJub29wIiwidGltZVVudGlsU3RhbGUiLCJnZXRBYm9ydENvbnRyb2xsZXIiLCJkZWZhdWx0TG9nZ2VyIiwibm90aWZ5TWFuYWdlciIsImNyZWF0ZVJldHJ5ZXIiLCJpc0NhbmNlbGxlZEVycm9yIiwiY2FuRmV0Y2giLCJSZW1vdmFibGUiLCJRdWVyeSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiYWJvcnRTaWduYWxDb25zdW1lZCIsImRlZmF1bHRPcHRpb25zIiwic2V0T3B0aW9ucyIsIm9wdGlvbnMiLCJvYnNlcnZlcnMiLCJjYWNoZSIsImxvZ2dlciIsInF1ZXJ5S2V5IiwicXVlcnlIYXNoIiwiaW5pdGlhbFN0YXRlIiwic3RhdGUiLCJnZXREZWZhdWx0U3RhdGUiLCJzY2hlZHVsZUdjIiwibWV0YSIsInVwZGF0ZUNhY2hlVGltZSIsImNhY2hlVGltZSIsIm9wdGlvbmFsUmVtb3ZlIiwibGVuZ3RoIiwiZmV0Y2hTdGF0dXMiLCJyZW1vdmUiLCJzZXREYXRhIiwibmV3RGF0YSIsImRhdGEiLCJkaXNwYXRjaCIsInR5cGUiLCJkYXRhVXBkYXRlZEF0IiwidXBkYXRlZEF0IiwibWFudWFsIiwic2V0U3RhdGUiLCJzZXRTdGF0ZU9wdGlvbnMiLCJjYW5jZWwiLCJfdGhpcyRyZXRyeWVyIiwicHJvbWlzZSIsInJldHJ5ZXIiLCJ0aGVuIiwiY2F0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsImRlc3Ryb3kiLCJzaWxlbnQiLCJyZXNldCIsImlzQWN0aXZlIiwic29tZSIsIm9ic2VydmVyIiwiZW5hYmxlZCIsImlzRGlzYWJsZWQiLCJnZXRPYnNlcnZlcnNDb3VudCIsImlzU3RhbGUiLCJpc0ludmFsaWRhdGVkIiwiZ2V0Q3VycmVudFJlc3VsdCIsImlzU3RhbGVCeVRpbWUiLCJzdGFsZVRpbWUiLCJvbkZvY3VzIiwiX3RoaXMkcmV0cnllcjIiLCJmaW5kIiwieCIsInNob3VsZEZldGNoT25XaW5kb3dGb2N1cyIsInJlZmV0Y2giLCJjYW5jZWxSZWZldGNoIiwiY29udGludWUiLCJvbk9ubGluZSIsIl90aGlzJHJldHJ5ZXIzIiwic2hvdWxkRmV0Y2hPblJlY29ubmVjdCIsImFkZE9ic2VydmVyIiwiaW5jbHVkZXMiLCJwdXNoIiwiY2xlYXJHY1RpbWVvdXQiLCJub3RpZnkiLCJxdWVyeSIsInJlbW92ZU9ic2VydmVyIiwiZmlsdGVyIiwicmV2ZXJ0IiwiY2FuY2VsUmV0cnkiLCJpbnZhbGlkYXRlIiwiZmV0Y2giLCJmZXRjaE9wdGlvbnMiLCJfdGhpcyRvcHRpb25zJGJlaGF2aW8iLCJfY29udGV4dCRmZXRjaE9wdGlvbnMiLCJfdGhpcyRyZXRyeWVyNCIsImNvbnRpbnVlUmV0cnkiLCJxdWVyeUZuIiwicHJvY2VzcyIsIkFycmF5IiwiaXNBcnJheSIsImVycm9yIiwiYWJvcnRDb250cm9sbGVyIiwicXVlcnlGbkNvbnRleHQiLCJwYWdlUGFyYW0iLCJ1bmRlZmluZWQiLCJhZGRTaWduYWxQcm9wZXJ0eSIsIm9iamVjdCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInNpZ25hbCIsImZldGNoRm4iLCJyZWplY3QiLCJjb250ZXh0IiwiYmVoYXZpb3IiLCJvbkZldGNoIiwicmV2ZXJ0U3RhdGUiLCJmZXRjaE1ldGEiLCJfY29udGV4dCRmZXRjaE9wdGlvbnMyIiwib25FcnJvciIsIl90aGlzJGNhY2hlJGNvbmZpZyRvbiIsIl90aGlzJGNhY2hlJGNvbmZpZyIsIl90aGlzJGNhY2hlJGNvbmZpZyRvbjIiLCJfdGhpcyRjYWNoZSRjb25maWcyIiwiY2FsbCIsIm9uU2V0dGxlZCIsImlzRmV0Y2hpbmdPcHRpbWlzdGljIiwiZm4iLCJhYm9ydCIsImJpbmQiLCJvblN1Y2Nlc3MiLCJfdGhpcyRjYWNoZSRjb25maWckb24zIiwiX3RoaXMkY2FjaGUkY29uZmlnMyIsIl90aGlzJGNhY2hlJGNvbmZpZyRvbjQiLCJfdGhpcyRjYWNoZSRjb25maWc0IiwiRXJyb3IiLCJvbkZhaWwiLCJmYWlsdXJlQ291bnQiLCJvblBhdXNlIiwib25Db250aW51ZSIsInJldHJ5IiwicmV0cnlEZWxheSIsIm5ldHdvcmtNb2RlIiwiYWN0aW9uIiwicmVkdWNlciIsIl9hY3Rpb24kbWV0YSIsIl9hY3Rpb24kZGF0YVVwZGF0ZWRBdCIsImZldGNoRmFpbHVyZUNvdW50IiwiZmV0Y2hGYWlsdXJlUmVhc29uIiwic3RhdHVzIiwiZGF0YVVwZGF0ZUNvdW50IiwiRGF0ZSIsIm5vdyIsImVycm9yVXBkYXRlQ291bnQiLCJlcnJvclVwZGF0ZWRBdCIsImJhdGNoIiwiZm9yRWFjaCIsIm9uUXVlcnlVcGRhdGUiLCJpbml0aWFsRGF0YSIsImhhc0RhdGEiLCJpbml0aWFsRGF0YVVwZGF0ZWRBdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/query.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/queryCache.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/queryCache.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryCache: () => (/* binding */ QueryCache)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n/* harmony import */ var _query_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/query.mjs\");\n/* harmony import */ var _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs\");\n/* harmony import */ var _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/subscribable.mjs\");\n\n\n\n\n// CLASS\nclass QueryCache extends _subscribable_mjs__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n    constructor(config){\n        super();\n        this.config = config || {};\n        this.queries = [];\n        this.queriesMap = {};\n    }\n    build(client, options, state) {\n        var _options$queryHash;\n        const queryKey = options.queryKey;\n        const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.hashQueryKeyByOptions)(queryKey, options);\n        let query = this.get(queryHash);\n        if (!query) {\n            query = new _query_mjs__WEBPACK_IMPORTED_MODULE_2__.Query({\n                cache: this,\n                logger: client.getLogger(),\n                queryKey,\n                queryHash,\n                options: client.defaultQueryOptions(options),\n                state,\n                defaultOptions: client.getQueryDefaults(queryKey)\n            });\n            this.add(query);\n        }\n        return query;\n    }\n    add(query) {\n        if (!this.queriesMap[query.queryHash]) {\n            this.queriesMap[query.queryHash] = query;\n            this.queries.push(query);\n            this.notify({\n                type: \"added\",\n                query\n            });\n        }\n    }\n    remove(query) {\n        const queryInMap = this.queriesMap[query.queryHash];\n        if (queryInMap) {\n            query.destroy();\n            this.queries = this.queries.filter((x)=>x !== query);\n            if (queryInMap === query) {\n                delete this.queriesMap[query.queryHash];\n            }\n            this.notify({\n                type: \"removed\",\n                query\n            });\n        }\n    }\n    clear() {\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(()=>{\n            this.queries.forEach((query)=>{\n                this.remove(query);\n            });\n        });\n    }\n    get(queryHash) {\n        return this.queriesMap[queryHash];\n    }\n    getAll() {\n        return this.queries;\n    }\n    find(arg1, arg2) {\n        const [filters] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.parseFilterArgs)(arg1, arg2);\n        if (typeof filters.exact === \"undefined\") {\n            filters.exact = true;\n        }\n        return this.queries.find((query)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(filters, query));\n    }\n    findAll(arg1, arg2) {\n        const [filters] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.parseFilterArgs)(arg1, arg2);\n        return Object.keys(filters).length > 0 ? this.queries.filter((query)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(filters, query)) : this.queries;\n    }\n    notify(event) {\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(()=>{\n            this.listeners.forEach(({ listener })=>{\n                listener(event);\n            });\n        });\n    }\n    onFocus() {\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(()=>{\n            this.queries.forEach((query)=>{\n                query.onFocus();\n            });\n        });\n    }\n    onOnline() {\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(()=>{\n            this.queries.forEach((query)=>{\n                query.onOnline();\n            });\n        });\n    }\n}\n //# sourceMappingURL=queryCache.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3F1ZXJ5Q2FjaGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlGO0FBQzdDO0FBQ2dCO0FBQ0Y7QUFFbEQsUUFBUTtBQUNSLE1BQU1NLG1CQUFtQkQsMkRBQVlBO0lBQ25DRSxZQUFZQyxNQUFNLENBQUU7UUFDbEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsTUFBTSxHQUFHQSxVQUFVLENBQUM7UUFDekIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO0lBQ3JCO0lBRUFDLE1BQU1DLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUU7UUFDNUIsSUFBSUM7UUFFSixNQUFNQyxXQUFXSCxRQUFRRyxRQUFRO1FBQ2pDLE1BQU1DLFlBQVksQ0FBQ0YscUJBQXFCRixRQUFRSSxTQUFTLEtBQUssT0FBT0YscUJBQXFCZixpRUFBcUJBLENBQUNnQixVQUFVSDtRQUMxSCxJQUFJSyxRQUFRLElBQUksQ0FBQ0MsR0FBRyxDQUFDRjtRQUVyQixJQUFJLENBQUNDLE9BQU87WUFDVkEsUUFBUSxJQUFJZiw2Q0FBS0EsQ0FBQztnQkFDaEJpQixPQUFPLElBQUk7Z0JBQ1hDLFFBQVFULE9BQU9VLFNBQVM7Z0JBQ3hCTjtnQkFDQUM7Z0JBQ0FKLFNBQVNELE9BQU9XLG1CQUFtQixDQUFDVjtnQkFDcENDO2dCQUNBVSxnQkFBZ0JaLE9BQU9hLGdCQUFnQixDQUFDVDtZQUMxQztZQUNBLElBQUksQ0FBQ1UsR0FBRyxDQUFDUjtRQUNYO1FBRUEsT0FBT0E7SUFDVDtJQUVBUSxJQUFJUixLQUFLLEVBQUU7UUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDUixVQUFVLENBQUNRLE1BQU1ELFNBQVMsQ0FBQyxFQUFFO1lBQ3JDLElBQUksQ0FBQ1AsVUFBVSxDQUFDUSxNQUFNRCxTQUFTLENBQUMsR0FBR0M7WUFDbkMsSUFBSSxDQUFDVCxPQUFPLENBQUNrQixJQUFJLENBQUNUO1lBQ2xCLElBQUksQ0FBQ1UsTUFBTSxDQUFDO2dCQUNWQyxNQUFNO2dCQUNOWDtZQUNGO1FBQ0Y7SUFDRjtJQUVBWSxPQUFPWixLQUFLLEVBQUU7UUFDWixNQUFNYSxhQUFhLElBQUksQ0FBQ3JCLFVBQVUsQ0FBQ1EsTUFBTUQsU0FBUyxDQUFDO1FBRW5ELElBQUljLFlBQVk7WUFDZGIsTUFBTWMsT0FBTztZQUNiLElBQUksQ0FBQ3ZCLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQ3dCLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsTUFBTWhCO1lBRTlDLElBQUlhLGVBQWViLE9BQU87Z0JBQ3hCLE9BQU8sSUFBSSxDQUFDUixVQUFVLENBQUNRLE1BQU1ELFNBQVMsQ0FBQztZQUN6QztZQUVBLElBQUksQ0FBQ1csTUFBTSxDQUFDO2dCQUNWQyxNQUFNO2dCQUNOWDtZQUNGO1FBQ0Y7SUFDRjtJQUVBaUIsUUFBUTtRQUNOL0IsNkRBQWFBLENBQUNnQyxLQUFLLENBQUM7WUFDbEIsSUFBSSxDQUFDM0IsT0FBTyxDQUFDNEIsT0FBTyxDQUFDbkIsQ0FBQUE7Z0JBQ25CLElBQUksQ0FBQ1ksTUFBTSxDQUFDWjtZQUNkO1FBQ0Y7SUFDRjtJQUVBQyxJQUFJRixTQUFTLEVBQUU7UUFDYixPQUFPLElBQUksQ0FBQ1AsVUFBVSxDQUFDTyxVQUFVO0lBQ25DO0lBRUFxQixTQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUM3QixPQUFPO0lBQ3JCO0lBRUE4QixLQUFLQyxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUNmLE1BQU0sQ0FBQ0MsUUFBUSxHQUFHekMsMkRBQWVBLENBQUN1QyxNQUFNQztRQUV4QyxJQUFJLE9BQU9DLFFBQVFDLEtBQUssS0FBSyxhQUFhO1lBQ3hDRCxRQUFRQyxLQUFLLEdBQUc7UUFDbEI7UUFFQSxPQUFPLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQzhCLElBQUksQ0FBQ3JCLENBQUFBLFFBQVNoQixzREFBVUEsQ0FBQ3dDLFNBQVN4QjtJQUN4RDtJQUVBMEIsUUFBUUosSUFBSSxFQUFFQyxJQUFJLEVBQUU7UUFDbEIsTUFBTSxDQUFDQyxRQUFRLEdBQUd6QywyREFBZUEsQ0FBQ3VDLE1BQU1DO1FBQ3hDLE9BQU9JLE9BQU9DLElBQUksQ0FBQ0osU0FBU0ssTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDdEMsT0FBTyxDQUFDd0IsTUFBTSxDQUFDZixDQUFBQSxRQUFTaEIsc0RBQVVBLENBQUN3QyxTQUFTeEIsVUFBVSxJQUFJLENBQUNULE9BQU87SUFDbEg7SUFFQW1CLE9BQU9vQixLQUFLLEVBQUU7UUFDWjVDLDZEQUFhQSxDQUFDZ0MsS0FBSyxDQUFDO1lBQ2xCLElBQUksQ0FBQ2EsU0FBUyxDQUFDWixPQUFPLENBQUMsQ0FBQyxFQUN0QmEsUUFBUSxFQUNUO2dCQUNDQSxTQUFTRjtZQUNYO1FBQ0Y7SUFDRjtJQUVBRyxVQUFVO1FBQ1IvQyw2REFBYUEsQ0FBQ2dDLEtBQUssQ0FBQztZQUNsQixJQUFJLENBQUMzQixPQUFPLENBQUM0QixPQUFPLENBQUNuQixDQUFBQTtnQkFDbkJBLE1BQU1pQyxPQUFPO1lBQ2Y7UUFDRjtJQUNGO0lBRUFDLFdBQVc7UUFDVGhELDZEQUFhQSxDQUFDZ0MsS0FBSyxDQUFDO1lBQ2xCLElBQUksQ0FBQzNCLE9BQU8sQ0FBQzRCLE9BQU8sQ0FBQ25CLENBQUFBO2dCQUNuQkEsTUFBTWtDLFFBQVE7WUFDaEI7UUFDRjtJQUNGO0FBRUY7QUFFc0IsQ0FDdEIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dDEzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9xdWVyeUNhY2hlLm1qcz85OTJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2hRdWVyeUtleUJ5T3B0aW9ucywgcGFyc2VGaWx0ZXJBcmdzLCBtYXRjaFF1ZXJ5IH0gZnJvbSAnLi91dGlscy5tanMnO1xuaW1wb3J0IHsgUXVlcnkgfSBmcm9tICcuL3F1ZXJ5Lm1qcyc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tICcuL3N1YnNjcmliYWJsZS5tanMnO1xuXG4vLyBDTEFTU1xuY2xhc3MgUXVlcnlDYWNoZSBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgdGhpcy5xdWVyaWVzID0gW107XG4gICAgdGhpcy5xdWVyaWVzTWFwID0ge307XG4gIH1cblxuICBidWlsZChjbGllbnQsIG9wdGlvbnMsIHN0YXRlKSB7XG4gICAgdmFyIF9vcHRpb25zJHF1ZXJ5SGFzaDtcblxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gb3B0aW9ucy5xdWVyeUtleTtcbiAgICBjb25zdCBxdWVyeUhhc2ggPSAoX29wdGlvbnMkcXVlcnlIYXNoID0gb3B0aW9ucy5xdWVyeUhhc2gpICE9IG51bGwgPyBfb3B0aW9ucyRxdWVyeUhhc2ggOiBoYXNoUXVlcnlLZXlCeU9wdGlvbnMocXVlcnlLZXksIG9wdGlvbnMpO1xuICAgIGxldCBxdWVyeSA9IHRoaXMuZ2V0KHF1ZXJ5SGFzaCk7XG5cbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICBxdWVyeSA9IG5ldyBRdWVyeSh7XG4gICAgICAgIGNhY2hlOiB0aGlzLFxuICAgICAgICBsb2dnZXI6IGNsaWVudC5nZXRMb2dnZXIoKSxcbiAgICAgICAgcXVlcnlLZXksXG4gICAgICAgIHF1ZXJ5SGFzaCxcbiAgICAgICAgb3B0aW9uczogY2xpZW50LmRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucyksXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkZWZhdWx0T3B0aW9uczogY2xpZW50LmdldFF1ZXJ5RGVmYXVsdHMocXVlcnlLZXkpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkKHF1ZXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cblxuICBhZGQocXVlcnkpIHtcbiAgICBpZiAoIXRoaXMucXVlcmllc01hcFtxdWVyeS5xdWVyeUhhc2hdKSB7XG4gICAgICB0aGlzLnF1ZXJpZXNNYXBbcXVlcnkucXVlcnlIYXNoXSA9IHF1ZXJ5O1xuICAgICAgdGhpcy5xdWVyaWVzLnB1c2gocXVlcnkpO1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgICBxdWVyeVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlKHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnlJbk1hcCA9IHRoaXMucXVlcmllc01hcFtxdWVyeS5xdWVyeUhhc2hdO1xuXG4gICAgaWYgKHF1ZXJ5SW5NYXApIHtcbiAgICAgIHF1ZXJ5LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucXVlcmllcyA9IHRoaXMucXVlcmllcy5maWx0ZXIoeCA9PiB4ICE9PSBxdWVyeSk7XG5cbiAgICAgIGlmIChxdWVyeUluTWFwID09PSBxdWVyeSkge1xuICAgICAgICBkZWxldGUgdGhpcy5xdWVyaWVzTWFwW3F1ZXJ5LnF1ZXJ5SGFzaF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ3JlbW92ZWQnLFxuICAgICAgICBxdWVyeVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChxdWVyeSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlKHF1ZXJ5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0KHF1ZXJ5SGFzaCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJpZXNNYXBbcXVlcnlIYXNoXTtcbiAgfVxuXG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyaWVzO1xuICB9XG5cbiAgZmluZChhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgW2ZpbHRlcnNdID0gcGFyc2VGaWx0ZXJBcmdzKGFyZzEsIGFyZzIpO1xuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJzLmV4YWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZmlsdGVycy5leGFjdCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucXVlcmllcy5maW5kKHF1ZXJ5ID0+IG1hdGNoUXVlcnkoZmlsdGVycywgcXVlcnkpKTtcbiAgfVxuXG4gIGZpbmRBbGwoYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IFtmaWx0ZXJzXSA9IHBhcnNlRmlsdGVyQXJncyhhcmcxLCBhcmcyKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlsdGVycykubGVuZ3RoID4gMCA/IHRoaXMucXVlcmllcy5maWx0ZXIocXVlcnkgPT4gbWF0Y2hRdWVyeShmaWx0ZXJzLCBxdWVyeSkpIDogdGhpcy5xdWVyaWVzO1xuICB9XG5cbiAgbm90aWZ5KGV2ZW50KSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCh7XG4gICAgICAgIGxpc3RlbmVyXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb25Gb2N1cygpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucXVlcmllcy5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgcXVlcnkub25Gb2N1cygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBvbk9ubGluZSgpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMucXVlcmllcy5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgcXVlcnkub25PbmxpbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0IHsgUXVlcnlDYWNoZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlDYWNoZS5tanMubWFwXG4iXSwibmFtZXMiOlsiaGFzaFF1ZXJ5S2V5QnlPcHRpb25zIiwicGFyc2VGaWx0ZXJBcmdzIiwibWF0Y2hRdWVyeSIsIlF1ZXJ5Iiwibm90aWZ5TWFuYWdlciIsIlN1YnNjcmliYWJsZSIsIlF1ZXJ5Q2FjaGUiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsInF1ZXJpZXMiLCJxdWVyaWVzTWFwIiwiYnVpbGQiLCJjbGllbnQiLCJvcHRpb25zIiwic3RhdGUiLCJfb3B0aW9ucyRxdWVyeUhhc2giLCJxdWVyeUtleSIsInF1ZXJ5SGFzaCIsInF1ZXJ5IiwiZ2V0IiwiY2FjaGUiLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJkZWZhdWx0UXVlcnlPcHRpb25zIiwiZGVmYXVsdE9wdGlvbnMiLCJnZXRRdWVyeURlZmF1bHRzIiwiYWRkIiwicHVzaCIsIm5vdGlmeSIsInR5cGUiLCJyZW1vdmUiLCJxdWVyeUluTWFwIiwiZGVzdHJveSIsImZpbHRlciIsIngiLCJjbGVhciIsImJhdGNoIiwiZm9yRWFjaCIsImdldEFsbCIsImZpbmQiLCJhcmcxIiwiYXJnMiIsImZpbHRlcnMiLCJleGFjdCIsImZpbmRBbGwiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZXZlbnQiLCJsaXN0ZW5lcnMiLCJsaXN0ZW5lciIsIm9uRm9jdXMiLCJvbk9ubGluZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/queryCache.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/queryClient.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/queryClient.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClient: () => (/* binding */ QueryClient)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n/* harmony import */ var _queryCache_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queryCache.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/queryCache.mjs\");\n/* harmony import */ var _mutationCache_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutationCache.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/mutationCache.mjs\");\n/* harmony import */ var _focusManager_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./focusManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/focusManager.mjs\");\n/* harmony import */ var _onlineManager_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onlineManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/onlineManager.mjs\");\n/* harmony import */ var _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./notifyManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/notifyManager.mjs\");\n/* harmony import */ var _infiniteQueryBehavior_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./infiniteQueryBehavior.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs\");\n/* harmony import */ var _logger_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logger.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/logger.mjs\");\n\n\n\n\n\n\n\n\n// CLASS\nclass QueryClient {\n    constructor(config = {}){\n        this.queryCache = config.queryCache || new _queryCache_mjs__WEBPACK_IMPORTED_MODULE_0__.QueryCache();\n        this.mutationCache = config.mutationCache || new _mutationCache_mjs__WEBPACK_IMPORTED_MODULE_1__.MutationCache();\n        this.logger = config.logger || _logger_mjs__WEBPACK_IMPORTED_MODULE_2__.defaultLogger;\n        this.defaultOptions = config.defaultOptions || {};\n        this.queryDefaults = [];\n        this.mutationDefaults = [];\n        this.mountCount = 0;\n        if ( true && config.logger) {\n            this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n        }\n    }\n    mount() {\n        this.mountCount++;\n        if (this.mountCount !== 1) return;\n        this.unsubscribeFocus = _focusManager_mjs__WEBPACK_IMPORTED_MODULE_3__.focusManager.subscribe(()=>{\n            if (_focusManager_mjs__WEBPACK_IMPORTED_MODULE_3__.focusManager.isFocused()) {\n                this.resumePausedMutations();\n                this.queryCache.onFocus();\n            }\n        });\n        this.unsubscribeOnline = _onlineManager_mjs__WEBPACK_IMPORTED_MODULE_4__.onlineManager.subscribe(()=>{\n            if (_onlineManager_mjs__WEBPACK_IMPORTED_MODULE_4__.onlineManager.isOnline()) {\n                this.resumePausedMutations();\n                this.queryCache.onOnline();\n            }\n        });\n    }\n    unmount() {\n        var _this$unsubscribeFocu, _this$unsubscribeOnli;\n        this.mountCount--;\n        if (this.mountCount !== 0) return;\n        (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n        this.unsubscribeFocus = undefined;\n        (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n        this.unsubscribeOnline = undefined;\n    }\n    isFetching(arg1, arg2) {\n        const [filters] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseFilterArgs)(arg1, arg2);\n        filters.fetchStatus = \"fetching\";\n        return this.queryCache.findAll(filters).length;\n    }\n    isMutating(filters) {\n        return this.mutationCache.findAll({\n            ...filters,\n            fetching: true\n        }).length;\n    }\n    getQueryData(queryKey, filters) {\n        var _this$queryCache$find;\n        return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n    }\n    ensureQueryData(arg1, arg2, arg3) {\n        const parsedOptions = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseQueryArgs)(arg1, arg2, arg3);\n        const cachedData = this.getQueryData(parsedOptions.queryKey);\n        return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n    }\n    getQueriesData(queryKeyOrFilters) {\n        return this.getQueryCache().findAll(queryKeyOrFilters).map(({ queryKey, state })=>{\n            const data = state.data;\n            return [\n                queryKey,\n                data\n            ];\n        });\n    }\n    setQueryData(queryKey, updater, options) {\n        const query = this.queryCache.find(queryKey);\n        const prevData = query == null ? void 0 : query.state.data;\n        const data = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.functionalUpdate)(updater, prevData);\n        if (typeof data === \"undefined\") {\n            return undefined;\n        }\n        const parsedOptions = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseQueryArgs)(queryKey);\n        const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n        return this.queryCache.build(this, defaultedOptions).setData(data, {\n            ...options,\n            manual: true\n        });\n    }\n    setQueriesData(queryKeyOrFilters, updater, options) {\n        return _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batch(()=>this.getQueryCache().findAll(queryKeyOrFilters).map(({ queryKey })=>[\n                    queryKey,\n                    this.setQueryData(queryKey, updater, options)\n                ]));\n    }\n    getQueryState(queryKey, filters) {\n        var _this$queryCache$find2;\n        return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n    }\n    removeQueries(arg1, arg2) {\n        const [filters] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseFilterArgs)(arg1, arg2);\n        const queryCache = this.queryCache;\n        _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batch(()=>{\n            queryCache.findAll(filters).forEach((query)=>{\n                queryCache.remove(query);\n            });\n        });\n    }\n    resetQueries(arg1, arg2, arg3) {\n        const [filters, options] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseFilterArgs)(arg1, arg2, arg3);\n        const queryCache = this.queryCache;\n        const refetchFilters = {\n            type: \"active\",\n            ...filters\n        };\n        return _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batch(()=>{\n            queryCache.findAll(filters).forEach((query)=>{\n                query.reset();\n            });\n            return this.refetchQueries(refetchFilters, options);\n        });\n    }\n    cancelQueries(arg1, arg2, arg3) {\n        const [filters, cancelOptions = {}] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseFilterArgs)(arg1, arg2, arg3);\n        if (typeof cancelOptions.revert === \"undefined\") {\n            cancelOptions.revert = true;\n        }\n        const promises = _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batch(()=>this.queryCache.findAll(filters).map((query)=>query.cancel(cancelOptions)));\n        return Promise.all(promises).then(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop).catch(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop);\n    }\n    invalidateQueries(arg1, arg2, arg3) {\n        const [filters, options] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseFilterArgs)(arg1, arg2, arg3);\n        return _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batch(()=>{\n            var _ref, _filters$refetchType;\n            this.queryCache.findAll(filters).forEach((query)=>{\n                query.invalidate();\n            });\n            if (filters.refetchType === \"none\") {\n                return Promise.resolve();\n            }\n            const refetchFilters = {\n                ...filters,\n                type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : \"active\"\n            };\n            return this.refetchQueries(refetchFilters, options);\n        });\n    }\n    refetchQueries(arg1, arg2, arg3) {\n        const [filters, options] = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseFilterArgs)(arg1, arg2, arg3);\n        const promises = _notifyManager_mjs__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batch(()=>this.queryCache.findAll(filters).filter((query)=>!query.isDisabled()).map((query)=>{\n                var _options$cancelRefetc;\n                return query.fetch(undefined, {\n                    ...options,\n                    cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n                    meta: {\n                        refetchPage: filters.refetchPage\n                    }\n                });\n            }));\n        let promise = Promise.all(promises).then(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop);\n        if (!(options != null && options.throwOnError)) {\n            promise = promise.catch(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop);\n        }\n        return promise;\n    }\n    fetchQuery(arg1, arg2, arg3) {\n        const parsedOptions = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseQueryArgs)(arg1, arg2, arg3);\n        const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n        if (typeof defaultedOptions.retry === \"undefined\") {\n            defaultedOptions.retry = false;\n        }\n        const query = this.queryCache.build(this, defaultedOptions);\n        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n    }\n    prefetchQuery(arg1, arg2, arg3) {\n        return this.fetchQuery(arg1, arg2, arg3).then(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop).catch(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop);\n    }\n    fetchInfiniteQuery(arg1, arg2, arg3) {\n        const parsedOptions = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.parseQueryArgs)(arg1, arg2, arg3);\n        parsedOptions.behavior = (0,_infiniteQueryBehavior_mjs__WEBPACK_IMPORTED_MODULE_7__.infiniteQueryBehavior)();\n        return this.fetchQuery(parsedOptions);\n    }\n    prefetchInfiniteQuery(arg1, arg2, arg3) {\n        return this.fetchInfiniteQuery(arg1, arg2, arg3).then(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop).catch(_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.noop);\n    }\n    resumePausedMutations() {\n        return this.mutationCache.resumePausedMutations();\n    }\n    getQueryCache() {\n        return this.queryCache;\n    }\n    getMutationCache() {\n        return this.mutationCache;\n    }\n    getLogger() {\n        return this.logger;\n    }\n    getDefaultOptions() {\n        return this.defaultOptions;\n    }\n    setDefaultOptions(options) {\n        this.defaultOptions = options;\n    }\n    setQueryDefaults(queryKey, options) {\n        const result = this.queryDefaults.find((x)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.hashQueryKey)(queryKey) === (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.hashQueryKey)(x.queryKey));\n        if (result) {\n            result.defaultOptions = options;\n        } else {\n            this.queryDefaults.push({\n                queryKey,\n                defaultOptions: options\n            });\n        }\n    }\n    getQueryDefaults(queryKey) {\n        if (!queryKey) {\n            return undefined;\n        } // Get the first matching defaults\n        const firstMatchingDefaults = this.queryDefaults.find((x)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.partialMatchKey)(queryKey, x.queryKey)); // Additional checks and error in dev mode\n        if (true) {\n            // Retrieve all matching defaults for the given key\n            const matchingDefaults = this.queryDefaults.filter((x)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.partialMatchKey)(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n            if (matchingDefaults.length > 1) {\n                this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n            }\n        }\n        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n    }\n    setMutationDefaults(mutationKey, options) {\n        const result = this.mutationDefaults.find((x)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.hashQueryKey)(mutationKey) === (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.hashQueryKey)(x.mutationKey));\n        if (result) {\n            result.defaultOptions = options;\n        } else {\n            this.mutationDefaults.push({\n                mutationKey,\n                defaultOptions: options\n            });\n        }\n    }\n    getMutationDefaults(mutationKey) {\n        if (!mutationKey) {\n            return undefined;\n        } // Get the first matching defaults\n        const firstMatchingDefaults = this.mutationDefaults.find((x)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.partialMatchKey)(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n        if (true) {\n            // Retrieve all matching defaults for the given key\n            const matchingDefaults = this.mutationDefaults.filter((x)=>(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.partialMatchKey)(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n            if (matchingDefaults.length > 1) {\n                this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n            }\n        }\n        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n    }\n    defaultQueryOptions(options) {\n        if (options != null && options._defaulted) {\n            return options;\n        }\n        const defaultedOptions = {\n            ...this.defaultOptions.queries,\n            ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n            ...options,\n            _defaulted: true\n        };\n        if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n            defaultedOptions.queryHash = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_5__.hashQueryKeyByOptions)(defaultedOptions.queryKey, defaultedOptions);\n        } // dependent default values\n        if (typeof defaultedOptions.refetchOnReconnect === \"undefined\") {\n            defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n        }\n        if (typeof defaultedOptions.useErrorBoundary === \"undefined\") {\n            defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n        }\n        return defaultedOptions;\n    }\n    defaultMutationOptions(options) {\n        if (options != null && options._defaulted) {\n            return options;\n        }\n        return {\n            ...this.defaultOptions.mutations,\n            ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n            ...options,\n            _defaulted: true\n        };\n    }\n    clear() {\n        this.queryCache.clear();\n        this.mutationCache.clear();\n    }\n}\n //# sourceMappingURL=queryClient.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3F1ZXJ5Q2xpZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNEk7QUFDOUY7QUFDTTtBQUNGO0FBQ0U7QUFDQTtBQUNnQjtBQUN2QjtBQUU3QyxRQUFRO0FBQ1IsTUFBTWM7SUFDSkMsWUFBWUMsU0FBUyxDQUFDLENBQUMsQ0FBRTtRQUN2QixJQUFJLENBQUNDLFVBQVUsR0FBR0QsT0FBT0MsVUFBVSxJQUFJLElBQUlWLHVEQUFVQTtRQUNyRCxJQUFJLENBQUNXLGFBQWEsR0FBR0YsT0FBT0UsYUFBYSxJQUFJLElBQUlWLDZEQUFhQTtRQUM5RCxJQUFJLENBQUNXLE1BQU0sR0FBR0gsT0FBT0csTUFBTSxJQUFJTixzREFBYUE7UUFDNUMsSUFBSSxDQUFDTyxjQUFjLEdBQUdKLE9BQU9JLGNBQWMsSUFBSSxDQUFDO1FBQ2hELElBQUksQ0FBQ0MsYUFBYSxHQUFHLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBRWxCLElBQUlDLEtBQXlCLElBQWdCUixPQUFPRyxNQUFNLEVBQUU7WUFDMUQsSUFBSSxDQUFDQSxNQUFNLENBQUNNLEtBQUssQ0FBQztRQUNwQjtJQUNGO0lBRUFDLFFBQVE7UUFDTixJQUFJLENBQUNILFVBQVU7UUFDZixJQUFJLElBQUksQ0FBQ0EsVUFBVSxLQUFLLEdBQUc7UUFDM0IsSUFBSSxDQUFDSSxnQkFBZ0IsR0FBR2xCLDJEQUFZQSxDQUFDbUIsU0FBUyxDQUFDO1lBQzdDLElBQUluQiwyREFBWUEsQ0FBQ29CLFNBQVMsSUFBSTtnQkFDNUIsSUFBSSxDQUFDQyxxQkFBcUI7Z0JBQzFCLElBQUksQ0FBQ2IsVUFBVSxDQUFDYyxPQUFPO1lBQ3pCO1FBQ0Y7UUFDQSxJQUFJLENBQUNDLGlCQUFpQixHQUFHdEIsNkRBQWFBLENBQUNrQixTQUFTLENBQUM7WUFDL0Ms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cy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9saWIvcXVlcnlDbGllbnQubWpzPzllZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VGaWx0ZXJBcmdzLCBwYXJzZVF1ZXJ5QXJncywgZnVuY3Rpb25hbFVwZGF0ZSwgbm9vcCwgaGFzaFF1ZXJ5S2V5LCBwYXJ0aWFsTWF0Y2hLZXksIGhhc2hRdWVyeUtleUJ5T3B0aW9ucyB9IGZyb20gJy4vdXRpbHMubWpzJztcbmltcG9ydCB7IFF1ZXJ5Q2FjaGUgfSBmcm9tICcuL3F1ZXJ5Q2FjaGUubWpzJztcbmltcG9ydCB7IE11dGF0aW9uQ2FjaGUgfSBmcm9tICcuL211dGF0aW9uQ2FjaGUubWpzJztcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gJy4vZm9jdXNNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBvbmxpbmVNYW5hZ2VyIH0gZnJvbSAnLi9vbmxpbmVNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnLi9ub3RpZnlNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IgfSBmcm9tICcuL2luZmluaXRlUXVlcnlCZWhhdmlvci5tanMnO1xuaW1wb3J0IHsgZGVmYXVsdExvZ2dlciB9IGZyb20gJy4vbG9nZ2VyLm1qcyc7XG5cbi8vIENMQVNTXG5jbGFzcyBRdWVyeUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5xdWVyeUNhY2hlID0gY29uZmlnLnF1ZXJ5Q2FjaGUgfHwgbmV3IFF1ZXJ5Q2FjaGUoKTtcbiAgICB0aGlzLm11dGF0aW9uQ2FjaGUgPSBjb25maWcubXV0YXRpb25DYWNoZSB8fCBuZXcgTXV0YXRpb25DYWNoZSgpO1xuICAgIHRoaXMubG9nZ2VyID0gY29uZmlnLmxvZ2dlciB8fCBkZWZhdWx0TG9nZ2VyO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBjb25maWcuZGVmYXVsdE9wdGlvbnMgfHwge307XG4gICAgdGhpcy5xdWVyeURlZmF1bHRzID0gW107XG4gICAgdGhpcy5tdXRhdGlvbkRlZmF1bHRzID0gW107XG4gICAgdGhpcy5tb3VudENvdW50ID0gMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5sb2dnZXIpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiUGFzc2luZyBhIGN1c3RvbSBsb2dnZXIgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXCIpO1xuICAgIH1cbiAgfVxuXG4gIG1vdW50KCkge1xuICAgIHRoaXMubW91bnRDb3VudCsrO1xuICAgIGlmICh0aGlzLm1vdW50Q291bnQgIT09IDEpIHJldHVybjtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRm9jdXMgPSBmb2N1c01hbmFnZXIuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmIChmb2N1c01hbmFnZXIuaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVQYXVzZWRNdXRhdGlvbnMoKTtcbiAgICAgICAgdGhpcy5xdWVyeUNhY2hlLm9uRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlT25saW5lID0gb25saW5lTWFuYWdlci5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSkge1xuICAgICAgICB0aGlzLnJlc3VtZVBhdXNlZE11dGF0aW9ucygpO1xuICAgICAgICB0aGlzLnF1ZXJ5Q2FjaGUub25PbmxpbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVubW91bnQoKSB7XG4gICAgdmFyIF90aGlzJHVuc3Vic2NyaWJlRm9jdSwgX3RoaXMkdW5zdWJzY3JpYmVPbmxpO1xuXG4gICAgdGhpcy5tb3VudENvdW50LS07XG4gICAgaWYgKHRoaXMubW91bnRDb3VudCAhPT0gMCkgcmV0dXJuO1xuICAgIChfdGhpcyR1bnN1YnNjcmliZUZvY3UgPSB0aGlzLnVuc3Vic2NyaWJlRm9jdXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR1bnN1YnNjcmliZUZvY3UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRm9jdXMgPSB1bmRlZmluZWQ7XG4gICAgKF90aGlzJHVuc3Vic2NyaWJlT25saSA9IHRoaXMudW5zdWJzY3JpYmVPbmxpbmUpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR1bnN1YnNjcmliZU9ubGkuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlT25saW5lID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaXNGZXRjaGluZyhhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgW2ZpbHRlcnNdID0gcGFyc2VGaWx0ZXJBcmdzKGFyZzEsIGFyZzIpO1xuICAgIGZpbHRlcnMuZmV0Y2hTdGF0dXMgPSAnZmV0Y2hpbmcnO1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5sZW5ndGg7XG4gIH1cblxuICBpc011dGF0aW5nKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGlvbkNhY2hlLmZpbmRBbGwoeyAuLi5maWx0ZXJzLFxuICAgICAgZmV0Y2hpbmc6IHRydWVcbiAgICB9KS5sZW5ndGg7XG4gIH1cblxuICBnZXRRdWVyeURhdGEocXVlcnlLZXksIGZpbHRlcnMpIHtcbiAgICB2YXIgX3RoaXMkcXVlcnlDYWNoZSRmaW5kO1xuXG4gICAgcmV0dXJuIChfdGhpcyRxdWVyeUNhY2hlJGZpbmQgPSB0aGlzLnF1ZXJ5Q2FjaGUuZmluZChxdWVyeUtleSwgZmlsdGVycykpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRxdWVyeUNhY2hlJGZpbmQuc3RhdGUuZGF0YTtcbiAgfVxuXG4gIGVuc3VyZVF1ZXJ5RGF0YShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IHBhcnNlUXVlcnlBcmdzKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLmdldFF1ZXJ5RGF0YShwYXJzZWRPcHRpb25zLnF1ZXJ5S2V5KTtcbiAgICByZXR1cm4gY2FjaGVkRGF0YSA/IFByb21pc2UucmVzb2x2ZShjYWNoZWREYXRhKSA6IHRoaXMuZmV0Y2hRdWVyeShwYXJzZWRPcHRpb25zKTtcbiAgfVxuXG4gIGdldFF1ZXJpZXNEYXRhKHF1ZXJ5S2V5T3JGaWx0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UXVlcnlDYWNoZSgpLmZpbmRBbGwocXVlcnlLZXlPckZpbHRlcnMpLm1hcCgoe1xuICAgICAgcXVlcnlLZXksXG4gICAgICBzdGF0ZVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzdGF0ZS5kYXRhO1xuICAgICAgcmV0dXJuIFtxdWVyeUtleSwgZGF0YV07XG4gICAgfSk7XG4gIH1cblxuICBzZXRRdWVyeURhdGEocXVlcnlLZXksIHVwZGF0ZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlDYWNoZS5maW5kKHF1ZXJ5S2V5KTtcbiAgICBjb25zdCBwcmV2RGF0YSA9IHF1ZXJ5ID09IG51bGwgPyB2b2lkIDAgOiBxdWVyeS5zdGF0ZS5kYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHByZXZEYXRhKTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IHBhcnNlUXVlcnlBcmdzKHF1ZXJ5S2V5KTtcbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKHBhcnNlZE9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5Q2FjaGUuYnVpbGQodGhpcywgZGVmYXVsdGVkT3B0aW9ucykuc2V0RGF0YShkYXRhLCB7IC4uLm9wdGlvbnMsXG4gICAgICBtYW51YWw6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHNldFF1ZXJpZXNEYXRhKHF1ZXJ5S2V5T3JGaWx0ZXJzLCB1cGRhdGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4gdGhpcy5nZXRRdWVyeUNhY2hlKCkuZmluZEFsbChxdWVyeUtleU9yRmlsdGVycykubWFwKCh7XG4gICAgICBxdWVyeUtleVxuICAgIH0pID0+IFtxdWVyeUtleSwgdGhpcy5zZXRRdWVyeURhdGEocXVlcnlLZXksIHVwZGF0ZXIsIG9wdGlvbnMpXSkpO1xuICB9XG5cbiAgZ2V0UXVlcnlTdGF0ZShxdWVyeUtleSwgZmlsdGVycykge1xuICAgIHZhciBfdGhpcyRxdWVyeUNhY2hlJGZpbmQyO1xuXG4gICAgcmV0dXJuIChfdGhpcyRxdWVyeUNhY2hlJGZpbmQyID0gdGhpcy5xdWVyeUNhY2hlLmZpbmQocXVlcnlLZXksIGZpbHRlcnMpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcXVlcnlDYWNoZSRmaW5kMi5zdGF0ZTtcbiAgfVxuXG4gIHJlbW92ZVF1ZXJpZXMoYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IFtmaWx0ZXJzXSA9IHBhcnNlRmlsdGVyQXJncyhhcmcxLCBhcmcyKTtcbiAgICBjb25zdCBxdWVyeUNhY2hlID0gdGhpcy5xdWVyeUNhY2hlO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZvckVhY2gocXVlcnkgPT4ge1xuICAgICAgICBxdWVyeUNhY2hlLnJlbW92ZShxdWVyeSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0UXVlcmllcyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgY29uc3QgW2ZpbHRlcnMsIG9wdGlvbnNdID0gcGFyc2VGaWx0ZXJBcmdzKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIGNvbnN0IHF1ZXJ5Q2FjaGUgPSB0aGlzLnF1ZXJ5Q2FjaGU7XG4gICAgY29uc3QgcmVmZXRjaEZpbHRlcnMgPSB7XG4gICAgICB0eXBlOiAnYWN0aXZlJyxcbiAgICAgIC4uLmZpbHRlcnNcbiAgICB9O1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgcXVlcnkucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucmVmZXRjaFF1ZXJpZXMocmVmZXRjaEZpbHRlcnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgY2FuY2VsUXVlcmllcyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgY29uc3QgW2ZpbHRlcnMsIGNhbmNlbE9wdGlvbnMgPSB7fV0gPSBwYXJzZUZpbHRlckFyZ3MoYXJnMSwgYXJnMiwgYXJnMyk7XG5cbiAgICBpZiAodHlwZW9mIGNhbmNlbE9wdGlvbnMucmV2ZXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY2FuY2VsT3B0aW9ucy5yZXZlcnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2VzID0gbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB0aGlzLnF1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5tYXAocXVlcnkgPT4gcXVlcnkuY2FuY2VsKGNhbmNlbE9wdGlvbnMpKSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApO1xuICB9XG5cbiAgaW52YWxpZGF0ZVF1ZXJpZXMoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IFtmaWx0ZXJzLCBvcHRpb25zXSA9IHBhcnNlRmlsdGVyQXJncyhhcmcxLCBhcmcyLCBhcmczKTtcbiAgICByZXR1cm4gbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX2ZpbHRlcnMkcmVmZXRjaFR5cGU7XG5cbiAgICAgIHRoaXMucXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZvckVhY2gocXVlcnkgPT4ge1xuICAgICAgICBxdWVyeS5pbnZhbGlkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpbHRlcnMucmVmZXRjaFR5cGUgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZmV0Y2hGaWx0ZXJzID0geyAuLi5maWx0ZXJzLFxuICAgICAgICB0eXBlOiAoX3JlZiA9IChfZmlsdGVycyRyZWZldGNoVHlwZSA9IGZpbHRlcnMucmVmZXRjaFR5cGUpICE9IG51bGwgPyBfZmlsdGVycyRyZWZldGNoVHlwZSA6IGZpbHRlcnMudHlwZSkgIT0gbnVsbCA/IF9yZWYgOiAnYWN0aXZlJ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLnJlZmV0Y2hRdWVyaWVzKHJlZmV0Y2hGaWx0ZXJzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlZmV0Y2hRdWVyaWVzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCBbZmlsdGVycywgb3B0aW9uc10gPSBwYXJzZUZpbHRlckFyZ3MoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHRoaXMucXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZpbHRlcihxdWVyeSA9PiAhcXVlcnkuaXNEaXNhYmxlZCgpKS5tYXAocXVlcnkgPT4ge1xuICAgICAgdmFyIF9vcHRpb25zJGNhbmNlbFJlZmV0YztcblxuICAgICAgcmV0dXJuIHF1ZXJ5LmZldGNoKHVuZGVmaW5lZCwgeyAuLi5vcHRpb25zLFxuICAgICAgICBjYW5jZWxSZWZldGNoOiAoX29wdGlvbnMkY2FuY2VsUmVmZXRjID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jYW5jZWxSZWZldGNoKSAhPSBudWxsID8gX29wdGlvbnMkY2FuY2VsUmVmZXRjIDogdHJ1ZSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlZmV0Y2hQYWdlOiBmaWx0ZXJzLnJlZmV0Y2hQYWdlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKG5vb3ApO1xuXG4gICAgaWYgKCEob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMudGhyb3dPbkVycm9yKSkge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2gobm9vcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmZXRjaFF1ZXJ5KGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCBwYXJzZWRPcHRpb25zID0gcGFyc2VRdWVyeUFyZ3MoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgY29uc3QgZGVmYXVsdGVkT3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhwYXJzZWRPcHRpb25zKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Rhbm5lcmxpbnNsZXkvcmVhY3QtcXVlcnkvaXNzdWVzLzY1MlxuXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0ZWRPcHRpb25zLnJldHJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5yZXRyeSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgIHJldHVybiBxdWVyeS5pc1N0YWxlQnlUaW1lKGRlZmF1bHRlZE9wdGlvbnMuc3RhbGVUaW1lKSA/IHF1ZXJ5LmZldGNoKGRlZmF1bHRlZE9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5LnN0YXRlLmRhdGEpO1xuICB9XG5cbiAgcHJlZmV0Y2hRdWVyeShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hRdWVyeShhcmcxLCBhcmcyLCBhcmczKS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApO1xuICB9XG5cbiAgZmV0Y2hJbmZpbml0ZVF1ZXJ5KGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCBwYXJzZWRPcHRpb25zID0gcGFyc2VRdWVyeUFyZ3MoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgcGFyc2VkT3B0aW9ucy5iZWhhdmlvciA9IGluZmluaXRlUXVlcnlCZWhhdmlvcigpO1xuICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkocGFyc2VkT3B0aW9ucyk7XG4gIH1cblxuICBwcmVmZXRjaEluZmluaXRlUXVlcnkoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHJldHVybiB0aGlzLmZldGNoSW5maW5pdGVRdWVyeShhcmcxLCBhcmcyLCBhcmczKS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApO1xuICB9XG5cbiAgcmVzdW1lUGF1c2VkTXV0YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm11dGF0aW9uQ2FjaGUucmVzdW1lUGF1c2VkTXV0YXRpb25zKCk7XG4gIH1cblxuICBnZXRRdWVyeUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5Q2FjaGU7XG4gIH1cblxuICBnZXRNdXRhdGlvbkNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLm11dGF0aW9uQ2FjaGU7XG4gIH1cblxuICBnZXRMb2dnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyO1xuICB9XG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdE9wdGlvbnM7XG4gIH1cblxuICBzZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBzZXRRdWVyeURlZmF1bHRzKHF1ZXJ5S2V5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5xdWVyeURlZmF1bHRzLmZpbmQoeCA9PiBoYXNoUXVlcnlLZXkocXVlcnlLZXkpID09PSBoYXNoUXVlcnlLZXkoeC5xdWVyeUtleSkpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5xdWVyeURlZmF1bHRzLnB1c2goe1xuICAgICAgICBxdWVyeUtleSxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldFF1ZXJ5RGVmYXVsdHMocXVlcnlLZXkpIHtcbiAgICBpZiAoIXF1ZXJ5S2V5KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gR2V0IHRoZSBmaXJzdCBtYXRjaGluZyBkZWZhdWx0c1xuXG5cbiAgICBjb25zdCBmaXJzdE1hdGNoaW5nRGVmYXVsdHMgPSB0aGlzLnF1ZXJ5RGVmYXVsdHMuZmluZCh4ID0+IHBhcnRpYWxNYXRjaEtleShxdWVyeUtleSwgeC5xdWVyeUtleSkpOyAvLyBBZGRpdGlvbmFsIGNoZWNrcyBhbmQgZXJyb3IgaW4gZGV2IG1vZGVcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZXRyaWV2ZSBhbGwgbWF0Y2hpbmcgZGVmYXVsdHMgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgIGNvbnN0IG1hdGNoaW5nRGVmYXVsdHMgPSB0aGlzLnF1ZXJ5RGVmYXVsdHMuZmlsdGVyKHggPT4gcGFydGlhbE1hdGNoS2V5KHF1ZXJ5S2V5LCB4LnF1ZXJ5S2V5KSk7IC8vIEl0IGlzIG9rIG5vdCBoYXZpbmcgZGVmYXVsdHMsIGJ1dCBpdCBpcyBlcnJvciBwcm9uZSB0byBoYXZlIG1vcmUgdGhhbiAxIGRlZmF1bHQgZm9yIGEgZ2l2ZW4ga2V5XG5cbiAgICAgIGlmIChtYXRjaGluZ0RlZmF1bHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJbUXVlcnlDbGllbnRdIFNldmVyYWwgcXVlcnkgZGVmYXVsdHMgbWF0Y2ggd2l0aCBrZXkgJ1wiICsgSlNPTi5zdHJpbmdpZnkocXVlcnlLZXkpICsgXCInLiBUaGUgZmlyc3QgbWF0Y2hpbmcgcXVlcnkgZGVmYXVsdHMgYXJlIHVzZWQuIFBsZWFzZSBjaGVjayBob3cgcXVlcnkgZGVmYXVsdHMgYXJlIHJlZ2lzdGVyZWQuIE9yZGVyIGRvZXMgbWF0dGVyIGhlcmUuIGNmLiBodHRwczovL3JlYWN0LXF1ZXJ5LnRhbnN0YWNrLmNvbS9yZWZlcmVuY2UvUXVlcnlDbGllbnQjcXVlcnljbGllbnRzZXRxdWVyeWRlZmF1bHRzLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlyc3RNYXRjaGluZ0RlZmF1bHRzID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdE1hdGNoaW5nRGVmYXVsdHMuZGVmYXVsdE9wdGlvbnM7XG4gIH1cblxuICBzZXRNdXRhdGlvbkRlZmF1bHRzKG11dGF0aW9uS2V5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5tdXRhdGlvbkRlZmF1bHRzLmZpbmQoeCA9PiBoYXNoUXVlcnlLZXkobXV0YXRpb25LZXkpID09PSBoYXNoUXVlcnlLZXkoeC5tdXRhdGlvbktleSkpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tdXRhdGlvbkRlZmF1bHRzLnB1c2goe1xuICAgICAgICBtdXRhdGlvbktleSxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldE11dGF0aW9uRGVmYXVsdHMobXV0YXRpb25LZXkpIHtcbiAgICBpZiAoIW11dGF0aW9uS2V5KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gR2V0IHRoZSBmaXJzdCBtYXRjaGluZyBkZWZhdWx0c1xuXG5cbiAgICBjb25zdCBmaXJzdE1hdGNoaW5nRGVmYXVsdHMgPSB0aGlzLm11dGF0aW9uRGVmYXVsdHMuZmluZCh4ID0+IHBhcnRpYWxNYXRjaEtleShtdXRhdGlvbktleSwgeC5tdXRhdGlvbktleSkpOyAvLyBBZGRpdGlvbmFsIGNoZWNrcyBhbmQgZXJyb3IgaW4gZGV2IG1vZGVcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZXRyaWV2ZSBhbGwgbWF0Y2hpbmcgZGVmYXVsdHMgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgIGNvbnN0IG1hdGNoaW5nRGVmYXVsdHMgPSB0aGlzLm11dGF0aW9uRGVmYXVsdHMuZmlsdGVyKHggPT4gcGFydGlhbE1hdGNoS2V5KG11dGF0aW9uS2V5LCB4Lm11dGF0aW9uS2V5KSk7IC8vIEl0IGlzIG9rIG5vdCBoYXZpbmcgZGVmYXVsdHMsIGJ1dCBpdCBpcyBlcnJvciBwcm9uZSB0byBoYXZlIG1vcmUgdGhhbiAxIGRlZmF1bHQgZm9yIGEgZ2l2ZW4ga2V5XG5cbiAgICAgIGlmIChtYXRjaGluZ0RlZmF1bHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJbUXVlcnlDbGllbnRdIFNldmVyYWwgbXV0YXRpb24gZGVmYXVsdHMgbWF0Y2ggd2l0aCBrZXkgJ1wiICsgSlNPTi5zdHJpbmdpZnkobXV0YXRpb25LZXkpICsgXCInLiBUaGUgZmlyc3QgbWF0Y2hpbmcgbXV0YXRpb24gZGVmYXVsdHMgYXJlIHVzZWQuIFBsZWFzZSBjaGVjayBob3cgbXV0YXRpb24gZGVmYXVsdHMgYXJlIHJlZ2lzdGVyZWQuIE9yZGVyIGRvZXMgbWF0dGVyIGhlcmUuIGNmLiBodHRwczovL3JlYWN0LXF1ZXJ5LnRhbnN0YWNrLmNvbS9yZWZlcmVuY2UvUXVlcnlDbGllbnQjcXVlcnljbGllbnRzZXRtdXRhdGlvbmRlZmF1bHRzLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlyc3RNYXRjaGluZ0RlZmF1bHRzID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdE1hdGNoaW5nRGVmYXVsdHMuZGVmYXVsdE9wdGlvbnM7XG4gIH1cblxuICBkZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuX2RlZmF1bHRlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdGVkT3B0aW9ucyA9IHsgLi4udGhpcy5kZWZhdWx0T3B0aW9ucy5xdWVyaWVzLFxuICAgICAgLi4udGhpcy5nZXRRdWVyeURlZmF1bHRzKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnlLZXkpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIF9kZWZhdWx0ZWQ6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKCFkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5SGFzaCAmJiBkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5S2V5KSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5SGFzaCA9IGhhc2hRdWVyeUtleUJ5T3B0aW9ucyhkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5S2V5LCBkZWZhdWx0ZWRPcHRpb25zKTtcbiAgICB9IC8vIGRlcGVuZGVudCBkZWZhdWx0IHZhbHVlc1xuXG5cbiAgICBpZiAodHlwZW9mIGRlZmF1bHRlZE9wdGlvbnMucmVmZXRjaE9uUmVjb25uZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5yZWZldGNoT25SZWNvbm5lY3QgPSBkZWZhdWx0ZWRPcHRpb25zLm5ldHdvcmtNb2RlICE9PSAnYWx3YXlzJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlZmF1bHRlZE9wdGlvbnMudXNlRXJyb3JCb3VuZGFyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMudXNlRXJyb3JCb3VuZGFyeSA9ICEhZGVmYXVsdGVkT3B0aW9ucy5zdXNwZW5zZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdGVkT3B0aW9ucztcbiAgfVxuXG4gIGRlZmF1bHRNdXRhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5fZGVmYXVsdGVkKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4geyAuLi50aGlzLmRlZmF1bHRPcHRpb25zLm11dGF0aW9ucyxcbiAgICAgIC4uLnRoaXMuZ2V0TXV0YXRpb25EZWZhdWx0cyhvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm11dGF0aW9uS2V5KSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBfZGVmYXVsdGVkOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVlcnlDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMubXV0YXRpb25DYWNoZS5jbGVhcigpO1xuICB9XG5cbn1cblxuZXhwb3J0IHsgUXVlcnlDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5Q2xpZW50Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJwYXJzZUZpbHRlckFyZ3MiLCJwYXJzZVF1ZXJ5QXJncyIsImZ1bmN0aW9uYWxVcGRhdGUiLCJub29wIiwiaGFzaFF1ZXJ5S2V5IiwicGFydGlhbE1hdGNoS2V5IiwiaGFzaFF1ZXJ5S2V5QnlPcHRpb25zIiwiUXVlcnlDYWNoZSIsIk11dGF0aW9uQ2FjaGUiLCJmb2N1c01hbmFnZXIiLCJvbmxpbmVNYW5hZ2VyIiwibm90aWZ5TWFuYWdlciIsImluZmluaXRlUXVlcnlCZWhhdmlvciIsImRlZmF1bHRMb2dnZXIiLCJRdWVyeUNsaWVudCIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwicXVlcnlDYWNoZSIsIm11dGF0aW9uQ2FjaGUiLCJsb2dnZXIiLCJkZWZhdWx0T3B0aW9ucyIsInF1ZXJ5RGVmYXVsdHMiLCJtdXRhdGlvbkRlZmF1bHRzIiwibW91bnRDb3VudCIsInByb2Nlc3MiLCJlcnJvciIsIm1vdW50IiwidW5zdWJzY3JpYmVGb2N1cyIsInN1YnNjcmliZSIsImlzRm9jdXNlZCIsInJlc3VtZVBhdXNlZE11dGF0aW9ucyIsIm9uRm9jdXMiLCJ1bnN1YnNjcmliZU9ubGluZSIsImlzT25saW5lIiwib25PbmxpbmUiLCJ1bm1vdW50IiwiX3RoaXMkdW5zdWJzY3JpYmVGb2N1IiwiX3RoaXMkdW5zdWJzY3JpYmVPbmxpIiwiY2FsbCIsInVuZGVmaW5lZCIsImlzRmV0Y2hpbmciLCJhcmcxIiwiYXJnMiIsImZpbHRlcnMiLCJmZXRjaFN0YXR1cyIsImZpbmRBbGwiLCJsZW5ndGgiLCJpc011dGF0aW5nIiwiZmV0Y2hpbmciLCJnZXRRdWVyeURhdGEiLCJxdWVyeUtleSIsIl90aGlzJHF1ZXJ5Q2FjaGUkZmluZCIsImZpbmQiLCJzdGF0ZSIsImRhdGEiLCJlbnN1cmVRdWVyeURhdGEiLCJhcmczIiwicGFyc2VkT3B0aW9ucyIsImNhY2hlZERhdGEiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZldGNoUXVlcnkiLCJnZXRRdWVyaWVzRGF0YSIsInF1ZXJ5S2V5T3JGaWx0ZXJzIiwiZ2V0UXVlcnlDYWNoZSIsIm1hcCIsInNldFF1ZXJ5RGF0YSIsInVwZGF0ZXIiLCJvcHRpb25zIiwicXVlcnkiLCJwcmV2RGF0YSIsImRlZmF1bHRlZE9wdGlvbnMiLCJkZWZhdWx0UXVlcnlPcHRpb25zIiwiYnVpbGQiLCJzZXREYXRhIiwibWFudWFsIiwic2V0UXVlcmllc0RhdGEiLCJiYXRjaCIsImdldFF1ZXJ5U3RhdGUiLCJfdGhpcyRxdWVyeUNhY2hlJGZpbmQyIiwicmVtb3ZlUXVlcmllcyIsImZvckVhY2giLCJyZW1vdmUiLCJyZXNldFF1ZXJpZXMiLCJyZWZldGNoRmlsdGVycyIsInR5cGUiLCJyZXNldCIsInJlZmV0Y2hRdWVyaWVzIiwiY2FuY2VsUXVlcmllcyIsImNhbmNlbE9wdGlvbnMiLCJyZXZlcnQiLCJwcm9taXNlcyIsImNhbmNlbCIsImFsbCIsInRoZW4iLCJjYXRjaCIsImludmFsaWRhdGVRdWVyaWVzIiwiX3JlZiIsIl9maWx0ZXJzJHJlZmV0Y2hUeXBlIiwiaW52YWxpZGF0ZSIsInJlZmV0Y2hUeXBlIiwiZmlsdGVyIiwiaXNEaXNhYmxlZCIsIl9vcHRpb25zJGNhbmNlbFJlZmV0YyIsImZldGNoIiwiY2FuY2VsUmVmZXRjaCIsIm1ldGEiLCJyZWZldGNoUGFnZSIsInByb21pc2UiLCJ0aHJvd09uRXJyb3IiLCJyZXRyeSIsImlzU3RhbGVCeVRpbWUiLCJzdGFsZVRpbWUiLCJwcmVmZXRjaFF1ZXJ5IiwiZmV0Y2hJbmZpbml0ZVF1ZXJ5IiwiYmVoYXZpb3IiLCJwcmVmZXRjaEluZmluaXRlUXVlcnkiLCJnZXRNdXRhdGlvbkNhY2hlIiwiZ2V0TG9nZ2VyIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJzZXREZWZhdWx0T3B0aW9ucyIsInNldFF1ZXJ5RGVmYXVsdHMiLCJyZXN1bHQiLCJ4IiwicHVzaCIsImdldFF1ZXJ5RGVmYXVsdHMiLCJmaXJzdE1hdGNoaW5nRGVmYXVsdHMiLCJtYXRjaGluZ0RlZmF1bHRzIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldE11dGF0aW9uRGVmYXVsdHMiLCJtdXRhdGlvbktleSIsImdldE11dGF0aW9uRGVmYXVsdHMiLCJfZGVmYXVsdGVkIiwicXVlcmllcyIsInF1ZXJ5SGFzaCIsInJlZmV0Y2hPblJlY29ubmVjdCIsIm5ldHdvcmtNb2RlIiwidXNlRXJyb3JCb3VuZGFyeSIsInN1c3BlbnNlIiwiZGVmYXVsdE11dGF0aW9uT3B0aW9ucyIsIm11dGF0aW9ucyIsImNsZWFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/queryClient.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/removable.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/removable.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Removable: () => (/* binding */ Removable)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n\nclass Removable {\n    destroy() {\n        this.clearGcTimeout();\n    }\n    scheduleGc() {\n        this.clearGcTimeout();\n        if ((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isValidTimeout)(this.cacheTime)) {\n            this.gcTimeout = setTimeout(()=>{\n                this.optionalRemove();\n            }, this.cacheTime);\n        }\n    }\n    updateCacheTime(newCacheTime) {\n        // Default to 5 minutes (Infinity for server-side) if no cache time is set\n        this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : _utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isServer ? Infinity : 5 * 60 * 1000);\n    }\n    clearGcTimeout() {\n        if (this.gcTimeout) {\n            clearTimeout(this.gcTimeout);\n            this.gcTimeout = undefined;\n        }\n    }\n}\n //# sourceMappingURL=removable.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3JlbW92YWJsZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUQ7QUFFdkQsTUFBTUU7SUFDSkMsVUFBVTtRQUNSLElBQUksQ0FBQ0MsY0FBYztJQUNyQjtJQUVBQyxhQUFhO1FBQ1gsSUFBSSxDQUFDRCxjQUFjO1FBRW5CLElBQUlKLDBEQUFjQSxDQUFDLElBQUksQ0FBQ00sU0FBUyxHQUFHO1lBQ2xDLElBQUksQ0FBQ0MsU0FBUyxHQUFHQyxXQUFXO2dCQUMxQixJQUFJLENBQUNDLGNBQWM7WUFDckIsR0FBRyxJQUFJLENBQUNILFNBQVM7UUFDbkI7SUFDRjtJQUVBSSxnQkFBZ0JDLFlBQVksRUFBRTtRQUM1QiwwRUFBMEU7UUFDMUUsSUFBSSxDQUFDTCxTQUFTLEdBQUdNLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFNBQVMsSUFBSSxHQUFHSyxnQkFBZ0IsT0FBT0EsZUFBZVYsZ0RBQVFBLEdBQUdhLFdBQVcsSUFBSSxLQUFLO0lBQ3RIO0lBRUFWLGlCQUFpQjtRQUNmLElBQUksSUFBSSxDQUFDRyxTQUFTLEVBQUU7WUFDbEJRLGFBQWEsSUFBSSxDQUFDUixTQUFTO1lBQzNCLElBQUksQ0FBQ0EsU0FBUyxHQUFHUztRQUNuQjtJQUNGO0FBRUY7QUFFcUIsQ0FDckIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dDEzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9yZW1vdmFibGUubWpzPzBiMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNWYWxpZFRpbWVvdXQsIGlzU2VydmVyIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5jbGFzcyBSZW1vdmFibGUge1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgfVxuXG4gIHNjaGVkdWxlR2MoKSB7XG4gICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuXG4gICAgaWYgKGlzVmFsaWRUaW1lb3V0KHRoaXMuY2FjaGVUaW1lKSkge1xuICAgICAgdGhpcy5nY1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5vcHRpb25hbFJlbW92ZSgpO1xuICAgICAgfSwgdGhpcy5jYWNoZVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNhY2hlVGltZShuZXdDYWNoZVRpbWUpIHtcbiAgICAvLyBEZWZhdWx0IHRvIDUgbWludXRlcyAoSW5maW5pdHkgZm9yIHNlcnZlci1zaWRlKSBpZiBubyBjYWNoZSB0aW1lIGlzIHNldFxuICAgIHRoaXMuY2FjaGVUaW1lID0gTWF0aC5tYXgodGhpcy5jYWNoZVRpbWUgfHwgMCwgbmV3Q2FjaGVUaW1lICE9IG51bGwgPyBuZXdDYWNoZVRpbWUgOiBpc1NlcnZlciA/IEluZmluaXR5IDogNSAqIDYwICogMTAwMCk7XG4gIH1cblxuICBjbGVhckdjVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5nY1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmdjVGltZW91dCk7XG4gICAgICB0aGlzLmdjVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgeyBSZW1vdmFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92YWJsZS5tanMubWFwXG4iXSwibmFtZXMiOlsiaXNWYWxpZFRpbWVvdXQiLCJpc1NlcnZlciIsIlJlbW92YWJsZSIsImRlc3Ryb3kiLCJjbGVhckdjVGltZW91dCIsInNjaGVkdWxlR2MiLCJjYWNoZVRpbWUiLCJnY1RpbWVvdXQiLCJzZXRUaW1lb3V0Iiwib3B0aW9uYWxSZW1vdmUiLCJ1cGRhdGVDYWNoZVRpbWUiLCJuZXdDYWNoZVRpbWUiLCJNYXRoIiwibWF4IiwiSW5maW5pdHkiLCJjbGVhclRpbWVvdXQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/removable.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/retryer.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/retryer.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancelledError: () => (/* binding */ CancelledError),\n/* harmony export */   canFetch: () => (/* binding */ canFetch),\n/* harmony export */   createRetryer: () => (/* binding */ createRetryer),\n/* harmony export */   isCancelledError: () => (/* binding */ isCancelledError)\n/* harmony export */ });\n/* harmony import */ var _focusManager_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./focusManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/focusManager.mjs\");\n/* harmony import */ var _onlineManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./onlineManager.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/onlineManager.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\");\n\n\n\nfunction defaultRetryDelay(failureCount) {\n    return Math.min(1000 * 2 ** failureCount, 30000);\n}\nfunction canFetch(networkMode) {\n    return (networkMode != null ? networkMode : \"online\") === \"online\" ? _onlineManager_mjs__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline() : true;\n}\nclass CancelledError {\n    constructor(options){\n        this.revert = options == null ? void 0 : options.revert;\n        this.silent = options == null ? void 0 : options.silent;\n    }\n}\nfunction isCancelledError(value) {\n    return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n    let isRetryCancelled = false;\n    let failureCount = 0;\n    let isResolved = false;\n    let continueFn;\n    let promiseResolve;\n    let promiseReject;\n    const promise = new Promise((outerResolve, outerReject)=>{\n        promiseResolve = outerResolve;\n        promiseReject = outerReject;\n    });\n    const cancel = (cancelOptions)=>{\n        if (!isResolved) {\n            reject(new CancelledError(cancelOptions));\n            config.abort == null ? void 0 : config.abort();\n        }\n    };\n    const cancelRetry = ()=>{\n        isRetryCancelled = true;\n    };\n    const continueRetry = ()=>{\n        isRetryCancelled = false;\n    };\n    const shouldPause = ()=>!_focusManager_mjs__WEBPACK_IMPORTED_MODULE_1__.focusManager.isFocused() || config.networkMode !== \"always\" && !_onlineManager_mjs__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline();\n    const resolve = (value)=>{\n        if (!isResolved) {\n            isResolved = true;\n            config.onSuccess == null ? void 0 : config.onSuccess(value);\n            continueFn == null ? void 0 : continueFn();\n            promiseResolve(value);\n        }\n    };\n    const reject = (value)=>{\n        if (!isResolved) {\n            isResolved = true;\n            config.onError == null ? void 0 : config.onError(value);\n            continueFn == null ? void 0 : continueFn();\n            promiseReject(value);\n        }\n    };\n    const pause = ()=>{\n        return new Promise((continueResolve)=>{\n            continueFn = (value)=>{\n                const canContinue = isResolved || !shouldPause();\n                if (canContinue) {\n                    continueResolve(value);\n                }\n                return canContinue;\n            };\n            config.onPause == null ? void 0 : config.onPause();\n        }).then(()=>{\n            continueFn = undefined;\n            if (!isResolved) {\n                config.onContinue == null ? void 0 : config.onContinue();\n            }\n        });\n    }; // Create loop function\n    const run = ()=>{\n        // Do nothing if already resolved\n        if (isResolved) {\n            return;\n        }\n        let promiseOrValue; // Execute query\n        try {\n            promiseOrValue = config.fn();\n        } catch (error) {\n            promiseOrValue = Promise.reject(error);\n        }\n        Promise.resolve(promiseOrValue).then(resolve).catch((error)=>{\n            var _config$retry, _config$retryDelay;\n            // Stop if the fetch is already resolved\n            if (isResolved) {\n                return;\n            } // Do we need to retry the request?\n            const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n            const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n            const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n            const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n            if (isRetryCancelled || !shouldRetry) {\n                // We are done if the query does not need to be retried\n                reject(error);\n                return;\n            }\n            failureCount++; // Notify on fail\n            config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_2__.sleep)(delay) // Pause if the document is not visible or when the device is offline\n            .then(()=>{\n                if (shouldPause()) {\n                    return pause();\n                }\n                return;\n            }).then(()=>{\n                if (isRetryCancelled) {\n                    reject(error);\n                } else {\n                    run();\n                }\n            });\n        });\n    }; // Start loop\n    if (canFetch(config.networkMode)) {\n        run();\n    } else {\n        pause().then(run);\n    }\n    return {\n        promise,\n        cancel,\n        continue: ()=>{\n            const didContinue = continueFn == null ? void 0 : continueFn();\n            return didContinue ? promise : Promise.resolve();\n        },\n        cancelRetry,\n        continueRetry\n    };\n}\n //# sourceMappingURL=retryer.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3JldHJ5ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBa0Q7QUFDRTtBQUNoQjtBQUVwQyxTQUFTRyxrQkFBa0JDLFlBQVk7SUFDckMsT0FBT0MsS0FBS0MsR0FBRyxDQUFDLE9BQU8sS0FBS0YsY0FBYztBQUM1QztBQUVBLFNBQVNHLFNBQVNDLFdBQVc7SUFDM0IsT0FBTyxDQUFDQSxlQUFlLE9BQU9BLGNBQWMsUUFBTyxNQUFPLFdBQVdQLDZEQUFhQSxDQUFDUSxRQUFRLEtBQUs7QUFDbEc7QUFDQSxNQUFNQztJQUNKQyxZQUFZQyxPQUFPLENBQUU7UUFDbkIsSUFBSSxDQUFDQyxNQUFNLEdBQUdELFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFDLE1BQU07UUFDdkQsSUFBSSxDQUFDQyxNQUFNLEdBQUdGLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFFLE1BQU07SUFDekQ7QUFFRjtBQUNBLFNBQVNDLGlCQUFpQkMsS0FBSztJQUM3QixPQUFPQSxpQkFBaUJOO0FBQzFCO0FBQ0EsU0FBU08sY0FBY0MsTUFBTTtJQUMzQixJQUFJQyxtQkFBbUI7SUFDdkIsSUFBSWYsZUFBZTtJQUNuQixJQUFJZ0IsYUFBYTtJQUNqQixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixNQUFNQyxVQUFVLElBQUlDLFFBQVEsQ0FBQ0MsY0FBY0M7UUFDekNMLGlCQUFpQkk7UUFDakJILGdCQUFnQkk7SUFDbEI7SUFFQSxNQUFNQyxTQUFTQyxDQUFBQTtRQUNiLElBQUksQ0FBQ1QsWUFBWTtZQUNmVSxPQUFPLElBQUlwQixlQUFlbUI7WUFDMUJYLE9BQU9hLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSWIsT0FBT2EsS0FBSztRQUM5QztJQUNGO0lBRUEsTUFBTUMsY0FBYztRQUNsQmIsbUJBQW1CO0lBQ3JCO0lBRUEsTUFBTWMsZ0JBQWdCO1FBQ3BCZCxtQkFBbUI7SUFD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TFAsUUFBUUksSUFBSSxDQUFDRztJQUNmO0lBRUEsT0FBTztRQUNMdEI7UUFDQUk7UUFDQThCLFVBQVU7WUFDUixNQUFNQyxjQUFjdEMsY0FBYyxPQUFPLEtBQUssSUFBSUE7WUFDbEQsT0FBT3NDLGNBQWNuQyxVQUFVQyxRQUFRVyxPQUFPO1FBQ2hEO1FBQ0FKO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVxRSxDQUNyRSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3JldHJ5ZXIubWpzP2U2NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9jdXNNYW5hZ2VyIH0gZnJvbSAnLi9mb2N1c01hbmFnZXIubWpzJztcbmltcG9ydCB7IG9ubGluZU1hbmFnZXIgfSBmcm9tICcuL29ubGluZU1hbmFnZXIubWpzJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5mdW5jdGlvbiBkZWZhdWx0UmV0cnlEZWxheShmYWlsdXJlQ291bnQpIHtcbiAgcmV0dXJuIE1hdGgubWluKDEwMDAgKiAyICoqIGZhaWx1cmVDb3VudCwgMzAwMDApO1xufVxuXG5mdW5jdGlvbiBjYW5GZXRjaChuZXR3b3JrTW9kZSkge1xuICByZXR1cm4gKG5ldHdvcmtNb2RlICE9IG51bGwgPyBuZXR3b3JrTW9kZSA6ICdvbmxpbmUnKSA9PT0gJ29ubGluZScgPyBvbmxpbmVNYW5hZ2VyLmlzT25saW5lKCkgOiB0cnVlO1xufVxuY2xhc3MgQ2FuY2VsbGVkRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5yZXZlcnQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJldmVydDtcbiAgICB0aGlzLnNpbGVudCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lsZW50O1xuICB9XG5cbn1cbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkRXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2FuY2VsbGVkRXJyb3I7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXRyeWVyKGNvbmZpZykge1xuICBsZXQgaXNSZXRyeUNhbmNlbGxlZCA9IGZhbHNlO1xuICBsZXQgZmFpbHVyZUNvdW50ID0gMDtcbiAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgbGV0IGNvbnRpbnVlRm47XG4gIGxldCBwcm9taXNlUmVzb2x2ZTtcbiAgbGV0IHByb21pc2VSZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgob3V0ZXJSZXNvbHZlLCBvdXRlclJlamVjdCkgPT4ge1xuICAgIHByb21pc2VSZXNvbHZlID0gb3V0ZXJSZXNvbHZlO1xuICAgIHByb21pc2VSZWplY3QgPSBvdXRlclJlamVjdDtcbiAgfSk7XG5cbiAgY29uc3QgY2FuY2VsID0gY2FuY2VsT3B0aW9ucyA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICByZWplY3QobmV3IENhbmNlbGxlZEVycm9yKGNhbmNlbE9wdGlvbnMpKTtcbiAgICAgIGNvbmZpZy5hYm9ydCA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmFib3J0KCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNhbmNlbFJldHJ5ID0gKCkgPT4ge1xuICAgIGlzUmV0cnlDYW5jZWxsZWQgPSB0cnVlO1xuICB9O1xuXG4gIGNvbnN0IGNvbnRpbnVlUmV0cnkgPSAoKSA9PiB7XG4gICAgaXNSZXRyeUNhbmNlbGxlZCA9IGZhbHNlO1xuICB9O1xuXG4gIGNvbnN0IHNob3VsZFBhdXNlID0gKCkgPT4gIWZvY3VzTWFuYWdlci5pc0ZvY3VzZWQoKSB8fCBjb25maWcubmV0d29ya01vZGUgIT09ICdhbHdheXMnICYmICFvbmxpbmVNYW5hZ2VyLmlzT25saW5lKCk7XG5cbiAgY29uc3QgcmVzb2x2ZSA9IHZhbHVlID0+IHtcbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgY29uZmlnLm9uU3VjY2VzcyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLm9uU3VjY2Vzcyh2YWx1ZSk7XG4gICAgICBjb250aW51ZUZuID09IG51bGwgPyB2b2lkIDAgOiBjb250aW51ZUZuKCk7XG4gICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlamVjdCA9IHZhbHVlID0+IHtcbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgY29uZmlnLm9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5vbkVycm9yKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlRm4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRpbnVlRm4oKTtcbiAgICAgIHByb21pc2VSZWplY3QodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwYXVzZSA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoY29udGludWVSZXNvbHZlID0+IHtcbiAgICAgIGNvbnRpbnVlRm4gPSB2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbkNvbnRpbnVlID0gaXNSZXNvbHZlZCB8fCAhc2hvdWxkUGF1c2UoKTtcblxuICAgICAgICBpZiAoY2FuQ29udGludWUpIHtcbiAgICAgICAgICBjb250aW51ZVJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbkNvbnRpbnVlO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLm9uUGF1c2UgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5vblBhdXNlKCk7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBjb250aW51ZUZuID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgY29uZmlnLm9uQ29udGludWUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5vbkNvbnRpbnVlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07IC8vIENyZWF0ZSBsb29wIGZ1bmN0aW9uXG5cblxuICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgLy8gRG8gbm90aGluZyBpZiBhbHJlYWR5IHJlc29sdmVkXG4gICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcHJvbWlzZU9yVmFsdWU7IC8vIEV4ZWN1dGUgcXVlcnlcblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlT3JWYWx1ZSA9IGNvbmZpZy5mbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwcm9taXNlT3JWYWx1ZSA9IFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBQcm9taXNlLnJlc29sdmUocHJvbWlzZU9yVmFsdWUpLnRoZW4ocmVzb2x2ZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdmFyIF9jb25maWckcmV0cnksIF9jb25maWckcmV0cnlEZWxheTtcblxuICAgICAgLy8gU3RvcCBpZiB0aGUgZmV0Y2ggaXMgYWxyZWFkeSByZXNvbHZlZFxuICAgICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEbyB3ZSBuZWVkIHRvIHJldHJ5IHRoZSByZXF1ZXN0P1xuXG5cbiAgICAgIGNvbnN0IHJldHJ5ID0gKF9jb25maWckcmV0cnkgPSBjb25maWcucmV0cnkpICE9IG51bGwgPyBfY29uZmlnJHJldHJ5IDogMztcbiAgICAgIGNvbnN0IHJldHJ5RGVsYXkgPSAoX2NvbmZpZyRyZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXkpICE9IG51bGwgPyBfY29uZmlnJHJldHJ5RGVsYXkgOiBkZWZhdWx0UmV0cnlEZWxheTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gdHlwZW9mIHJldHJ5RGVsYXkgPT09ICdmdW5jdGlvbicgPyByZXRyeURlbGF5KGZhaWx1cmVDb3VudCwgZXJyb3IpIDogcmV0cnlEZWxheTtcbiAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gcmV0cnkgPT09IHRydWUgfHwgdHlwZW9mIHJldHJ5ID09PSAnbnVtYmVyJyAmJiBmYWlsdXJlQ291bnQgPCByZXRyeSB8fCB0eXBlb2YgcmV0cnkgPT09ICdmdW5jdGlvbicgJiYgcmV0cnkoZmFpbHVyZUNvdW50LCBlcnJvcik7XG5cbiAgICAgIGlmIChpc1JldHJ5Q2FuY2VsbGVkIHx8ICFzaG91bGRSZXRyeSkge1xuICAgICAgICAvLyBXZSBhcmUgZG9uZSBpZiB0aGUgcXVlcnkgZG9lcyBub3QgbmVlZCB0byBiZSByZXRyaWVkXG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmFpbHVyZUNvdW50Kys7IC8vIE5vdGlmeSBvbiBmYWlsXG5cbiAgICAgIGNvbmZpZy5vbkZhaWwgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5vbkZhaWwoZmFpbHVyZUNvdW50LCBlcnJvcik7IC8vIERlbGF5XG5cbiAgICAgIHNsZWVwKGRlbGF5KSAvLyBQYXVzZSBpZiB0aGUgZG9jdW1lbnQgaXMgbm90IHZpc2libGUgb3Igd2hlbiB0aGUgZGV2aWNlIGlzIG9mZmxpbmVcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZFBhdXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNSZXRyeUNhbmNlbGxlZCkge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9OyAvLyBTdGFydCBsb29wXG5cblxuICBpZiAoY2FuRmV0Y2goY29uZmlnLm5ldHdvcmtNb2RlKSkge1xuICAgIHJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHBhdXNlKCkudGhlbihydW4pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIGNhbmNlbCxcbiAgICBjb250aW51ZTogKCkgPT4ge1xuICAgICAgY29uc3QgZGlkQ29udGludWUgPSBjb250aW51ZUZuID09IG51bGwgPyB2b2lkIDAgOiBjb250aW51ZUZuKCk7XG4gICAgICByZXR1cm4gZGlkQ29udGludWUgPyBwcm9taXNlIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICBjYW5jZWxSZXRyeSxcbiAgICBjb250aW51ZVJldHJ5XG4gIH07XG59XG5cbmV4cG9ydCB7IENhbmNlbGxlZEVycm9yLCBjYW5GZXRjaCwgY3JlYXRlUmV0cnllciwgaXNDYW5jZWxsZWRFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnllci5tanMubWFwXG4iXSwibmFtZXMiOlsiZm9jdXNNYW5hZ2VyIiwib25saW5lTWFuYWdlciIsInNsZWVwIiwiZGVmYXVsdFJldHJ5RGVsYXkiLCJmYWlsdXJlQ291bnQiLCJNYXRoIiwibWluIiwiY2FuRmV0Y2giLCJuZXR3b3JrTW9kZSIsImlzT25saW5lIiwiQ2FuY2VsbGVkRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJyZXZlcnQiLCJzaWxlbnQiLCJpc0NhbmNlbGxlZEVycm9yIiwidmFsdWUiLCJjcmVhdGVSZXRyeWVyIiwiY29uZmlnIiwiaXNSZXRyeUNhbmNlbGxlZCIsImlzUmVzb2x2ZWQiLCJjb250aW51ZUZuIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlUmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJvdXRlclJlc29sdmUiLCJvdXRlclJlamVjdCIsImNhbmNlbCIsImNhbmNlbE9wdGlvbnMiLCJyZWplY3QiLCJhYm9ydCIsImNhbmNlbFJldHJ5IiwiY29udGludWVSZXRyeSIsInNob3VsZFBhdXNlIiwiaXNGb2N1c2VkIiwicmVzb2x2ZSIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJwYXVzZSIsImNvbnRpbnVlUmVzb2x2ZSIsImNhbkNvbnRpbnVlIiwib25QYXVzZSIsInRoZW4iLCJ1bmRlZmluZWQiLCJvbkNvbnRpbnVlIiwicnVuIiwicHJvbWlzZU9yVmFsdWUiLCJmbiIsImVycm9yIiwiY2F0Y2giLCJfY29uZmlnJHJldHJ5IiwiX2NvbmZpZyRyZXRyeURlbGF5IiwicmV0cnkiLCJyZXRyeURlbGF5IiwiZGVsYXkiLCJzaG91bGRSZXRyeSIsIm9uRmFpbCIsImNvbnRpbnVlIiwiZGlkQ29udGludWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/retryer.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/subscribable.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/subscribable.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subscribable: () => (/* binding */ Subscribable)\n/* harmony export */ });\nclass Subscribable {\n    constructor(){\n        this.listeners = new Set();\n        this.subscribe = this.subscribe.bind(this);\n    }\n    subscribe(listener) {\n        const identity = {\n            listener\n        };\n        this.listeners.add(identity);\n        this.onSubscribe();\n        return ()=>{\n            this.listeners.delete(identity);\n            this.onUnsubscribe();\n        };\n    }\n    hasListeners() {\n        return this.listeners.size > 0;\n    }\n    onSubscribe() {}\n    onUnsubscribe() {}\n}\n //# sourceMappingURL=subscribable.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3N1YnNjcmliYWJsZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BO0lBQ0pDLGFBQWM7UUFDWixJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJQztRQUNyQixJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDM0M7SUFFQUQsVUFBVUUsUUFBUSxFQUFFO1FBQ2xCLE1BQU1DLFdBQVc7WUFDZkQ7UUFDRjtRQUNBLElBQUksQ0FBQ0osU0FBUyxDQUFDTSxHQUFHLENBQUNEO1FBQ25CLElBQUksQ0FBQ0UsV0FBVztRQUNoQixPQUFPO1lBQ0wsSUFBSSxDQUFDUCxTQUFTLENBQUNRLE1BQU0sQ0FBQ0g7WUFDdEIsSUFBSSxDQUFDSSxhQUFhO1FBQ3BCO0lBQ0Y7SUFFQUMsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDVixTQUFTLENBQUNXLElBQUksR0FBRztJQUMvQjtJQUVBSixjQUFjLENBQ2Q7SUFFQUUsZ0JBQWdCLENBQ2hCO0FBRUY7QUFFd0IsQ0FDeEIseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dDEzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi9zdWJzY3JpYmFibGUubWpzPzY2OTIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgaWRlbnRpdHkgPSB7XG4gICAgICBsaXN0ZW5lclxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGlkZW50aXR5KTtcbiAgICB0aGlzLm9uU3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShpZGVudGl0eSk7XG4gICAgICB0aGlzLm9uVW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9XG5cbiAgaGFzTGlzdGVuZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zaXplID4gMDtcbiAgfVxuXG4gIG9uU3Vic2NyaWJlKCkgey8vIERvIG5vdGhpbmdcbiAgfVxuXG4gIG9uVW5zdWJzY3JpYmUoKSB7Ly8gRG8gbm90aGluZ1xuICB9XG5cbn1cblxuZXhwb3J0IHsgU3Vic2NyaWJhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmFibGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlN1YnNjcmliYWJsZSIsImNvbnN0cnVjdG9yIiwibGlzdGVuZXJzIiwiU2V0Iiwic3Vic2NyaWJlIiwiYmluZCIsImxpc3RlbmVyIiwiaWRlbnRpdHkiLCJhZGQiLCJvblN1YnNjcmliZSIsImRlbGV0ZSIsIm9uVW5zdWJzY3JpYmUiLCJoYXNMaXN0ZW5lcnMiLCJzaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/subscribable.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/lib/utils.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getAbortController: () => (/* binding */ getAbortController),\n/* harmony export */   hashQueryKey: () => (/* binding */ hashQueryKey),\n/* harmony export */   hashQueryKeyByOptions: () => (/* binding */ hashQueryKeyByOptions),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   isPlainArray: () => (/* binding */ isPlainArray),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isQueryKey: () => (/* binding */ isQueryKey),\n/* harmony export */   isServer: () => (/* binding */ isServer),\n/* harmony export */   isValidTimeout: () => (/* binding */ isValidTimeout),\n/* harmony export */   matchMutation: () => (/* binding */ matchMutation),\n/* harmony export */   matchQuery: () => (/* binding */ matchQuery),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   parseFilterArgs: () => (/* binding */ parseFilterArgs),\n/* harmony export */   parseMutationArgs: () => (/* binding */ parseMutationArgs),\n/* harmony export */   parseMutationFilterArgs: () => (/* binding */ parseMutationFilterArgs),\n/* harmony export */   parseQueryArgs: () => (/* binding */ parseQueryArgs),\n/* harmony export */   partialDeepEqual: () => (/* binding */ partialDeepEqual),\n/* harmony export */   partialMatchKey: () => (/* binding */ partialMatchKey),\n/* harmony export */   replaceAt: () => (/* binding */ replaceAt),\n/* harmony export */   replaceData: () => (/* binding */ replaceData),\n/* harmony export */   replaceEqualDeep: () => (/* binding */ replaceEqualDeep),\n/* harmony export */   scheduleMicrotask: () => (/* binding */ scheduleMicrotask),\n/* harmony export */   shallowEqualObjects: () => (/* binding */ shallowEqualObjects),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeUntilStale: () => (/* binding */ timeUntilStale)\n/* harmony export */ });\n// TYPES\n// UTILS\nconst isServer =  true || 0;\nfunction noop() {\n    return undefined;\n}\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n    return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n    return array1.filter((x)=>!array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n    const copy = array.slice(0);\n    copy[index] = value;\n    return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n    if (!isQueryKey(arg1)) {\n        return arg1;\n    }\n    if (typeof arg2 === \"function\") {\n        return {\n            ...arg3,\n            queryKey: arg1,\n            queryFn: arg2\n        };\n    }\n    return {\n        ...arg2,\n        queryKey: arg1\n    };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n    if (isQueryKey(arg1)) {\n        if (typeof arg2 === \"function\") {\n            return {\n                ...arg3,\n                mutationKey: arg1,\n                mutationFn: arg2\n            };\n        }\n        return {\n            ...arg2,\n            mutationKey: arg1\n        };\n    }\n    if (typeof arg1 === \"function\") {\n        return {\n            ...arg2,\n            mutationFn: arg1\n        };\n    }\n    return {\n        ...arg1\n    };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n    return isQueryKey(arg1) ? [\n        {\n            ...arg2,\n            queryKey: arg1\n        },\n        arg3\n    ] : [\n        arg1 || {},\n        arg2\n    ];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n    return isQueryKey(arg1) ? [\n        {\n            ...arg2,\n            mutationKey: arg1\n        },\n        arg3\n    ] : [\n        arg1 || {},\n        arg2\n    ];\n}\nfunction matchQuery(filters, query) {\n    const { type = \"all\", exact, fetchStatus, predicate, queryKey, stale } = filters;\n    if (isQueryKey(queryKey)) {\n        if (exact) {\n            if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n                return false;\n            }\n        } else if (!partialMatchKey(query.queryKey, queryKey)) {\n            return false;\n        }\n    }\n    if (type !== \"all\") {\n        const isActive = query.isActive();\n        if (type === \"active\" && !isActive) {\n            return false;\n        }\n        if (type === \"inactive\" && isActive) {\n            return false;\n        }\n    }\n    if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n        return false;\n    }\n    if (typeof fetchStatus !== \"undefined\" && fetchStatus !== query.state.fetchStatus) {\n        return false;\n    }\n    if (predicate && !predicate(query)) {\n        return false;\n    }\n    return true;\n}\nfunction matchMutation(filters, mutation) {\n    const { exact, fetching, predicate, mutationKey } = filters;\n    if (isQueryKey(mutationKey)) {\n        if (!mutation.options.mutationKey) {\n            return false;\n        }\n        if (exact) {\n            if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n                return false;\n            }\n        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n            return false;\n        }\n    }\n    if (typeof fetching === \"boolean\" && mutation.state.status === \"loading\" !== fetching) {\n        return false;\n    }\n    if (predicate && !predicate(mutation)) {\n        return false;\n    }\n    return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n    const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n    return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */ function hashQueryKey(queryKey) {\n    return JSON.stringify(queryKey, (_, val)=>isPlainObject(val) ? Object.keys(val).sort().reduce((result, key)=>{\n            result[key] = val[key];\n            return result;\n        }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */ function partialMatchKey(a, b) {\n    return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */ function partialDeepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n        return !Object.keys(b).some((key)=>!partialDeepEqual(a[key], b[key]));\n    }\n    return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */ function replaceEqualDeep(a, b) {\n    if (a === b) {\n        return a;\n    }\n    const array = isPlainArray(a) && isPlainArray(b);\n    if (array || isPlainObject(a) && isPlainObject(b)) {\n        const aSize = array ? a.length : Object.keys(a).length;\n        const bItems = array ? b : Object.keys(b);\n        const bSize = bItems.length;\n        const copy = array ? [] : {};\n        let equalItems = 0;\n        for(let i = 0; i < bSize; i++){\n            const key = array ? i : bItems[i];\n            copy[key] = replaceEqualDeep(a[key], b[key]);\n            if (copy[key] === a[key]) {\n                equalItems++;\n            }\n        }\n        return aSize === bSize && equalItems === aSize ? a : copy;\n    }\n    return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */ function shallowEqualObjects(a, b) {\n    if (a && !b || b && !a) {\n        return false;\n    }\n    for(const key in a){\n        if (a[key] !== b[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isPlainArray(value) {\n    return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o) {\n    if (!hasObjectPrototype(o)) {\n        return false;\n    } // If has modified constructor\n    const ctor = o.constructor;\n    if (typeof ctor === \"undefined\") {\n        return true;\n    } // If has modified prototype\n    const prot = ctor.prototype;\n    if (!hasObjectPrototype(prot)) {\n        return false;\n    } // If constructor does not have an Object-specific method\n    if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n        return false;\n    } // Most likely a plain Object\n    return true;\n}\nfunction hasObjectPrototype(o) {\n    return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isQueryKey(value) {\n    return Array.isArray(value);\n}\nfunction isError(value) {\n    return value instanceof Error;\n}\nfunction sleep(timeout) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, timeout);\n    });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */ function scheduleMicrotask(callback) {\n    sleep(0).then(callback);\n}\nfunction getAbortController() {\n    if (typeof AbortController === \"function\") {\n        return new AbortController();\n    }\n    return;\n}\nfunction replaceData(prevData, data, options) {\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n        return prevData;\n    } else if (typeof options.structuralSharing === \"function\") {\n        return options.structuralSharing(prevData, data);\n    } else if (options.structuralSharing !== false) {\n        // Structurally share data between prev and new data if needed\n        return replaceEqualDeep(prevData, data);\n    }\n    return data;\n}\n //# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbGliL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxRQUFRO0FBQ1IsUUFBUTtBQUNSLE1BQU1BLFdBQVcsS0FBa0IsSUFBZSxDQUFnQkM7QUFDbEUsU0FBU0M7SUFDUCxPQUFPQztBQUNUO0FBQ0EsU0FBU0MsaUJBQWlCQyxPQUFPLEVBQUVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPRCxZQUFZLGFBQWFBLFFBQVFDLFNBQVNEO0FBQzFEO0FBQ0EsU0FBU0UsZUFBZUMsS0FBSztJQUMzQixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsU0FBUyxLQUFLQSxVQUFVQztBQUM5RDtBQUNBLFNBQVNDLFdBQVdDLE1BQU0sRUFBRUMsTUFBTTtJQUNoQyxPQUFPRCxPQUFPRSxNQUFNLENBQUNDLENBQUFBLElBQUssQ0FBQ0YsT0FBT0csUUFBUSxDQUFDRDtBQUM3QztBQUNBLFNBQVNFLFVBQVVDLEtBQUssRUFBRUMsS0FBSyxFQUFFVixLQUFLO0lBQ3BDLE1BQU1XLE9BQU9GLE1BQU1HLEtBQUssQ0FBQztJQUN6QkQsSUFBSSxDQUFDRCxNQUFNLEdBQUdWO0lBQ2QsT0FBT1c7QUFDVDtBQUNBLFNBQVNFLGVBQWVDLFNBQVMsRUFBRUMsU0FBUztJQUMxQyxPQUFPQyxLQUFLQyxHQUFHLENBQUNILFlBQWFDLENBQUFBLGFBQWEsS0FBS0csS0FBS0MsR0FBRyxJQUFJO0FBQzdEO0FBQ0EsU0FBU0MsZUFBZUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDdEMsSUFBSSxDQUFDQyxXQUFXSCxPQUFPO1FBQ3JCLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJLE9BQU9DLFNBQVMsWUFBWTtRQUM5QixPQUFPO1lBQUUsR0FBR0MsSUFBSTtZQUNkRSxVQUFVSjtZQUNWSyxTQUFTSjtRQUNYO0lBQ0Y7SUFFQSxPQUFPO1FBQUUsR0FBR0EsSUFBSTtRQUNk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T0FBTztRQUN0RSxPQUFPRDtJQUNULE9BQU8sSUFBSSxPQUFPNUQsUUFBUStELGlCQUFpQixLQUFLLFlBQVk7UUFDMUQsT0FBTy9ELFFBQVErRCxpQkFBaUIsQ0FBQ0gsVUFBVUM7SUFDN0MsT0FBTyxJQUFJN0QsUUFBUStELGlCQUFpQixLQUFLLE9BQU87UUFDOUMsOERBQThEO1FBQzlELE9BQU9wQyxpQkFBaUJpQyxVQUFVQztJQUNwQztJQUVBLE9BQU9BO0FBQ1Q7QUFFdWEsQ0FDdmEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dDEzLWJvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL2xpYi91dGlscy5tanM/OGM1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUWVBFU1xuLy8gVVRJTFNcbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgJ0Rlbm8nIGluIHdpbmRvdztcbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID49IDAgJiYgdmFsdWUgIT09IEluZmluaXR5O1xufVxuZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheTEsIGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkxLmZpbHRlcih4ID0+ICFhcnJheTIuaW5jbHVkZXMoeCkpO1xufVxuZnVuY3Rpb24gcmVwbGFjZUF0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgY29uc3QgY29weSA9IGFycmF5LnNsaWNlKDApO1xuICBjb3B5W2luZGV4XSA9IHZhbHVlO1xuICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIHRpbWVVbnRpbFN0YWxlKHVwZGF0ZWRBdCwgc3RhbGVUaW1lKSB7XG4gIHJldHVybiBNYXRoLm1heCh1cGRhdGVkQXQgKyAoc3RhbGVUaW1lIHx8IDApIC0gRGF0ZS5ub3coKSwgMCk7XG59XG5mdW5jdGlvbiBwYXJzZVF1ZXJ5QXJncyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICghaXNRdWVyeUtleShhcmcxKSkge1xuICAgIHJldHVybiBhcmcxO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmcyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHsgLi4uYXJnMyxcbiAgICAgIHF1ZXJ5S2V5OiBhcmcxLFxuICAgICAgcXVlcnlGbjogYXJnMlxuICAgIH07XG4gIH1cblxuICByZXR1cm4geyAuLi5hcmcyLFxuICAgIHF1ZXJ5S2V5OiBhcmcxXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU11dGF0aW9uQXJncyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc1F1ZXJ5S2V5KGFyZzEpKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4geyAuLi5hcmczLFxuICAgICAgICBtdXRhdGlvbktleTogYXJnMSxcbiAgICAgICAgbXV0YXRpb25GbjogYXJnMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyAuLi5hcmcyLFxuICAgICAgbXV0YXRpb25LZXk6IGFyZzFcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmcxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHsgLi4uYXJnMixcbiAgICAgIG11dGF0aW9uRm46IGFyZzFcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgLi4uYXJnMVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJBcmdzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgcmV0dXJuIGlzUXVlcnlLZXkoYXJnMSkgPyBbeyAuLi5hcmcyLFxuICAgIHF1ZXJ5S2V5OiBhcmcxXG4gIH0sIGFyZzNdIDogW2FyZzEgfHwge30sIGFyZzJdO1xufVxuZnVuY3Rpb24gcGFyc2VNdXRhdGlvbkZpbHRlckFyZ3MoYXJnMSwgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaXNRdWVyeUtleShhcmcxKSA/IFt7IC4uLmFyZzIsXG4gICAgbXV0YXRpb25LZXk6IGFyZzFcbiAgfSwgYXJnM10gOiBbYXJnMSB8fCB7fSwgYXJnMl07XG59XG5mdW5jdGlvbiBtYXRjaFF1ZXJ5KGZpbHRlcnMsIHF1ZXJ5KSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlID0gJ2FsbCcsXG4gICAgZXhhY3QsXG4gICAgZmV0Y2hTdGF0dXMsXG4gICAgcHJlZGljYXRlLFxuICAgIHF1ZXJ5S2V5LFxuICAgIHN0YWxlXG4gIH0gPSBmaWx0ZXJzO1xuXG4gIGlmIChpc1F1ZXJ5S2V5KHF1ZXJ5S2V5KSkge1xuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5SGFzaCAhPT0gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBxdWVyeS5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcGFydGlhbE1hdGNoS2V5KHF1ZXJ5LnF1ZXJ5S2V5LCBxdWVyeUtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2FsbCcpIHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHF1ZXJ5LmlzQWN0aXZlKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2FjdGl2ZScgJiYgIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdpbmFjdGl2ZScgJiYgaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHN0YWxlID09PSAnYm9vbGVhbicgJiYgcXVlcnkuaXNTdGFsZSgpICE9PSBzdGFsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZmV0Y2hTdGF0dXMgIT09ICd1bmRlZmluZWQnICYmIGZldGNoU3RhdHVzICE9PSBxdWVyeS5zdGF0ZS5mZXRjaFN0YXR1cykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcmVkaWNhdGUgJiYgIXByZWRpY2F0ZShxdWVyeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoTXV0YXRpb24oZmlsdGVycywgbXV0YXRpb24pIHtcbiAgY29uc3Qge1xuICAgIGV4YWN0LFxuICAgIGZldGNoaW5nLFxuICAgIHByZWRpY2F0ZSxcbiAgICBtdXRhdGlvbktleVxuICB9ID0gZmlsdGVycztcblxuICBpZiAoaXNRdWVyeUtleShtdXRhdGlvbktleSkpIHtcbiAgICBpZiAoIW11dGF0aW9uLm9wdGlvbnMubXV0YXRpb25LZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZXhhY3QpIHtcbiAgICAgIGlmIChoYXNoUXVlcnlLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSkgIT09IGhhc2hRdWVyeUtleShtdXRhdGlvbktleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXBhcnRpYWxNYXRjaEtleShtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5LCBtdXRhdGlvbktleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGZldGNoaW5nID09PSAnYm9vbGVhbicgJiYgbXV0YXRpb24uc3RhdGUuc3RhdHVzID09PSAnbG9hZGluZycgIT09IGZldGNoaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKG11dGF0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGhhc2hGbiA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5S2V5SGFzaEZuKSB8fCBoYXNoUXVlcnlLZXk7XG4gIHJldHVybiBoYXNoRm4ocXVlcnlLZXkpO1xufVxuLyoqXG4gKiBEZWZhdWx0IHF1ZXJ5IGtleXMgaGFzaCBmdW5jdGlvbi5cbiAqIEhhc2hlcyB0aGUgdmFsdWUgaW50byBhIHN0YWJsZSBoYXNoLlxuICovXG5cbmZ1bmN0aW9uIGhhc2hRdWVyeUtleShxdWVyeUtleSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocXVlcnlLZXksIChfLCB2YWwpID0+IGlzUGxhaW5PYmplY3QodmFsKSA/IE9iamVjdC5rZXlzKHZhbCkuc29ydCgpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHZhbFtrZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KSA6IHZhbCk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBrZXkgYGJgIHBhcnRpYWxseSBtYXRjaGVzIHdpdGgga2V5IGBhYC5cbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsTWF0Y2hLZXkoYSwgYikge1xuICByZXR1cm4gcGFydGlhbERlZXBFcXVhbChhLCBiKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGBiYCBwYXJ0aWFsbHkgbWF0Y2hlcyB3aXRoIGBhYC5cbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsRGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKGIpLnNvbWUoa2V5ID0+ICFwYXJ0aWFsRGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgYWAgaWYgYGJgIGlzIGRlZXBseSBlcXVhbC5cbiAqIElmIG5vdCwgaXQgd2lsbCByZXBsYWNlIGFueSBkZWVwbHkgZXF1YWwgY2hpbGRyZW4gb2YgYGJgIHdpdGggdGhvc2Ugb2YgYGFgLlxuICogVGhpcyBjYW4gYmUgdXNlZCBmb3Igc3RydWN0dXJhbCBzaGFyaW5nIGJldHdlZW4gSlNPTiB2YWx1ZXMgZm9yIGV4YW1wbGUuXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZUVxdWFsRGVlcChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBjb25zdCBhcnJheSA9IGlzUGxhaW5BcnJheShhKSAmJiBpc1BsYWluQXJyYXkoYik7XG5cbiAgaWYgKGFycmF5IHx8IGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgIGNvbnN0IGFTaXplID0gYXJyYXkgPyBhLmxlbmd0aCA6IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICBjb25zdCBiSXRlbXMgPSBhcnJheSA/IGIgOiBPYmplY3Qua2V5cyhiKTtcbiAgICBjb25zdCBiU2l6ZSA9IGJJdGVtcy5sZW5ndGg7XG4gICAgY29uc3QgY29weSA9IGFycmF5ID8gW10gOiB7fTtcbiAgICBsZXQgZXF1YWxJdGVtcyA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGFycmF5ID8gaSA6IGJJdGVtc1tpXTtcbiAgICAgIGNvcHlba2V5XSA9IHJlcGxhY2VFcXVhbERlZXAoYVtrZXldLCBiW2tleV0pO1xuXG4gICAgICBpZiAoY29weVtrZXldID09PSBhW2tleV0pIHtcbiAgICAgICAgZXF1YWxJdGVtcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhU2l6ZSA9PT0gYlNpemUgJiYgZXF1YWxJdGVtcyA9PT0gYVNpemUgPyBhIDogY29weTtcbiAgfVxuXG4gIHJldHVybiBiO1xufVxuLyoqXG4gKiBTaGFsbG93IGNvbXBhcmUgb2JqZWN0cy4gT25seSB3b3JrcyB3aXRoIG9iamVjdHMgdGhhdCBhbHdheXMgaGF2ZSB0aGUgc2FtZSBwcm9wZXJ0aWVzLlxuICovXG5cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbE9iamVjdHMoYSwgYikge1xuICBpZiAoYSAmJiAhYiB8fCBiICYmICFhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNQbGFpbkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG59IC8vIENvcGllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3RcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuXG5cbiAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cbiAgaWYgKHR5cGVvZiBjdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcblxuXG4gIGNvbnN0IHByb3QgPSBjdG9yLnByb3RvdHlwZTtcblxuICBpZiAoIWhhc09iamVjdFByb3RvdHlwZShwcm90KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcblxuXG4gIGlmICghcHJvdC5oYXNPd25Qcm9wZXJ0eSgnaXNQcm90b3R5cGVPZicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIE1vc3QgbGlrZWx5IGEgcGxhaW4gT2JqZWN0XG5cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzT2JqZWN0UHJvdG90eXBlKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUXVlcnlLZXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmZ1bmN0aW9uIHNsZWVwKHRpbWVvdXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gIH0pO1xufVxuLyoqXG4gKiBTY2hlZHVsZXMgYSBtaWNyb3Rhc2suXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gc2NoZWR1bGUgc3RhdGUgdXBkYXRlcyBhZnRlciByZW5kZXJpbmcuXG4gKi9cblxuZnVuY3Rpb24gc2NoZWR1bGVNaWNyb3Rhc2soY2FsbGJhY2spIHtcbiAgc2xlZXAoMCkudGhlbihjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBnZXRBYm9ydENvbnRyb2xsZXIoKSB7XG4gIGlmICh0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgfVxuXG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VEYXRhKHByZXZEYXRhLCBkYXRhLCBvcHRpb25zKSB7XG4gIC8vIFVzZSBwcmV2IGRhdGEgaWYgYW4gaXNEYXRhRXF1YWwgZnVuY3Rpb24gaXMgZGVmaW5lZCBhbmQgcmV0dXJucyBgdHJ1ZWBcbiAgaWYgKG9wdGlvbnMuaXNEYXRhRXF1YWwgIT0gbnVsbCAmJiBvcHRpb25zLmlzRGF0YUVxdWFsKHByZXZEYXRhLCBkYXRhKSkge1xuICAgIHJldHVybiBwcmV2RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5zdHJ1Y3R1cmFsU2hhcmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRpb25zLnN0cnVjdHVyYWxTaGFyaW5nKHByZXZEYXRhLCBkYXRhKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnN0cnVjdHVyYWxTaGFyaW5nICE9PSBmYWxzZSkge1xuICAgIC8vIFN0cnVjdHVyYWxseSBzaGFyZSBkYXRhIGJldHdlZW4gcHJldiBhbmQgbmV3IGRhdGEgaWYgbmVlZGVkXG4gICAgcmV0dXJuIHJlcGxhY2VFcXVhbERlZXAocHJldkRhdGEsIGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCB7IGRpZmZlcmVuY2UsIGZ1bmN0aW9uYWxVcGRhdGUsIGdldEFib3J0Q29udHJvbGxlciwgaGFzaFF1ZXJ5S2V5LCBoYXNoUXVlcnlLZXlCeU9wdGlvbnMsIGlzRXJyb3IsIGlzUGxhaW5BcnJheSwgaXNQbGFpbk9iamVjdCwgaXNRdWVyeUtleSwgaXNTZXJ2ZXIsIGlzVmFsaWRUaW1lb3V0LCBtYXRjaE11dGF0aW9uLCBtYXRjaFF1ZXJ5LCBub29wLCBwYXJzZUZpbHRlckFyZ3MsIHBhcnNlTXV0YXRpb25BcmdzLCBwYXJzZU11dGF0aW9uRmlsdGVyQXJncywgcGFyc2VRdWVyeUFyZ3MsIHBhcnRpYWxEZWVwRXF1YWwsIHBhcnRpYWxNYXRjaEtleSwgcmVwbGFjZUF0LCByZXBsYWNlRGF0YSwgcmVwbGFjZUVxdWFsRGVlcCwgc2NoZWR1bGVNaWNyb3Rhc2ssIHNoYWxsb3dFcXVhbE9iamVjdHMsIHNsZWVwLCB0aW1lVW50aWxTdGFsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbImlzU2VydmVyIiwid2luZG93Iiwibm9vcCIsInVuZGVmaW5lZCIsImZ1bmN0aW9uYWxVcGRhdGUiLCJ1cGRhdGVyIiwiaW5wdXQiLCJpc1ZhbGlkVGltZW91dCIsInZhbHVlIiwiSW5maW5pdHkiLCJkaWZmZXJlbmNlIiwiYXJyYXkxIiwiYXJyYXkyIiwiZmlsdGVyIiwieCIsImluY2x1ZGVzIiwicmVwbGFjZUF0IiwiYXJyYXkiLCJpbmRleCIsImNvcHkiLCJzbGljZSIsInRpbWVVbnRpbFN0YWxlIiwidXBkYXRlZEF0Iiwic3RhbGVUaW1lIiwiTWF0aCIsIm1heCIsIkRhdGUiLCJub3ciLCJwYXJzZVF1ZXJ5QXJncyIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImlzUXVlcnlLZXkiLCJxdWVyeUtleSIsInF1ZXJ5Rm4iLCJwYXJzZU11dGF0aW9uQXJncyIsIm11dGF0aW9uS2V5IiwibXV0YXRpb25GbiIsInBhcnNlRmlsdGVyQXJncyIsInBhcnNlTXV0YXRpb25GaWx0ZXJBcmdzIiwibWF0Y2hRdWVyeSIsImZpbHRlcnMiLCJxdWVyeSIsInR5cGUiLCJleGFjdCIsImZldGNoU3RhdHVzIiwicHJlZGljYXRlIiwic3RhbGUiLCJxdWVyeUhhc2giLCJoYXNoUXVlcnlLZXlCeU9wdGlvbnMiLCJvcHRpb25zIiwicGFydGlhbE1hdGNoS2V5IiwiaXNBY3RpdmUiLCJpc1N0YWxlIiwic3RhdGUiLCJtYXRjaE11dGF0aW9uIiwibXV0YXRpb24iLCJmZXRjaGluZyIsImhhc2hRdWVyeUtleSIsInN0YXR1cyIsImhhc2hGbiIsInF1ZXJ5S2V5SGFzaEZuIiwiSlNPTiIsInN0cmluZ2lmeSIsIl8iLCJ2YWwiLCJpc1BsYWluT2JqZWN0IiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJyZWR1Y2UiLCJyZXN1bHQiLCJrZXkiLCJhIiwiYiIsInBhcnRpYWxEZWVwRXF1YWwiLCJzb21lIiwicmVwbGFjZUVxdWFsRGVlcCIsImlzUGxhaW5BcnJheSIsImFTaXplIiwibGVuZ3RoIiwiYkl0ZW1zIiwiYlNpemUiLCJlcXVhbEl0ZW1zIiwiaSIsInNoYWxsb3dFcXVhbE9iamVjdHMiLCJBcnJheSIsImlzQXJyYXkiLCJvIiwiaGFzT2JqZWN0UHJvdG90eXBlIiwiY3RvciIsImNvbnN0cnVjdG9yIiwicHJvdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwidG9TdHJpbmciLCJjYWxsIiwiaXNFcnJvciIsIkVycm9yIiwic2xlZXAiLCJ0aW1lb3V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic2NoZWR1bGVNaWNyb3Rhc2siLCJjYWxsYmFjayIsInRoZW4iLCJnZXRBYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXBsYWNlRGF0YSIsInByZXZEYXRhIiwiZGF0YSIsImlzRGF0YUVxdWFsIiwic3RydWN0dXJhbFNoYXJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/query-core/build/lib/utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClientProvider: () => (/* binding */ QueryClientProvider),\n/* harmony export */   defaultContext: () => (/* binding */ defaultContext),\n/* harmony export */   useQueryClient: () => (/* binding */ useQueryClient)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ QueryClientProvider,defaultContext,useQueryClient auto */ \nconst defaultContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(undefined);\nconst QueryClientSharingContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(false); // If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(context, contextSharing) {\n    if (context) {\n        return context;\n    }\n    if (contextSharing && \"undefined\" !== \"undefined\") {}\n    return defaultContext;\n}\nconst useQueryClient = ({ context } = {})=>{\n    const queryClient = react__WEBPACK_IMPORTED_MODULE_0__.useContext(getQueryClientContext(context, react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryClientSharingContext)));\n    if (!queryClient) {\n        throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    }\n    return queryClient;\n};\nconst QueryClientProvider = ({ client, children, context, contextSharing = false })=>{\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        client.mount();\n        return ()=>{\n            client.unmount();\n        };\n    }, [\n        client\n    ]);\n    if ( true && contextSharing) {\n        client.getLogger().error(\"The contextSharing option has been deprecated and will be removed in the next major version\");\n    }\n    const Context = getQueryClientContext(context, contextSharing);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(QueryClientSharingContext.Provider, {\n        value: !context && contextSharing\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n        value: client\n    }, children));\n};\n //# sourceMappingURL=QueryClientProvider.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL2xpYi9RdWVyeUNsaWVudFByb3ZpZGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O3VHQUMrQjtBQUUvQixNQUFNQyxpQkFBaUIsV0FBVyxHQUFFRCxnREFBbUIsQ0FBQ0c7QUFDeEQsTUFBTUMsNEJBQTRCLFdBQVcsR0FBRUosZ0RBQW1CLENBQUMsUUFBUSw2Q0FBNkM7QUFDeEgsMEVBQTBFO0FBQzFFLDRDQUE0QztBQUM1QywrQ0FBK0M7QUFDL0MsZ0RBQWdEO0FBQ2hELHVEQUF1RDtBQUN2RCxxQkFBcUI7QUFFckIsU0FBU0ssc0JBQXNCQyxPQUFPLEVBQUVDLGNBQWM7SUFDcEQsSUFBSUQsU0FBUztRQUNYLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJQyxrQkFBa0IsZ0JBQWtCLGFBQWEsRUFNcEQ7SUFFRCxPQUFPTjtBQUNUO0FBRUEsTUFBTVMsaUJBQWlCLENBQUMsRUFDdEJKLE9BQU8sRUFDUixHQUFHLENBQUMsQ0FBQztJQUNKLE1BQU1LLGNBQWNYLDZDQUFnQixDQUFDSyxzQkFBc0JDLFNBQVNOLDZDQUFnQixDQUFDSTtJQUVyRixJQUFJLENBQUNPLGFBQWE7UUFDaEIsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsT0FBT0Y7QUFDVDtBQUNBLE1BQU1HLHNCQUFzQixDQUFDLEVBQzNCQyxNQUFNLEVBQ05DLFFBQVEsRUFDUlYsT0FBTyxFQUNQQyxpQkFBaUIsS0FBSyxFQUN2QjtJQUNDUCw0Q0FBZSxDQUFDO1FBQ2RlLE9BQU9HLEtBQUs7UUFDWixPQUFPO1lBQ0xILE9BQU9JLE9BQU87UUFDaEI7SUFDRixHQUFHO1FBQUNKO0tBQU87SUFFWCxJQUFJSyxLQUF5QixJQUFnQmIsZ0JBQWdCO1FBQzNEUSxPQUFPTSxTQUFTLEdBQUdDLEtBQUssQ0FBQztJQUMzQjtJQUVBLE1BQU1DLFVBQVVsQixzQkFBc0JDLFNBQVNDO0lBQy9DLE9BQU8sV0FBVyxHQUFFUCxnREFBbUIsQ0FBQ0ksMEJBQTBCcUIsUUFBUSxFQUFFO1FBQzFFQyxPQUFPLENBQUNwQixXQUFXQztJQUNyQixHQUFHLFdBQVcsR0FBRVAsZ0RBQW1CLENBQUN1QixRQUFRRSxRQUFRLEVBQUU7UUFDcERDLE9BQU9YO0lBQ1QsR0FBR0M7QUFDTDtBQUUrRCxDQUMvRCxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL2xpYi9RdWVyeUNsaWVudFByb3ZpZGVyLm1qcz8zYWNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgZGVmYXVsdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuY29uc3QgUXVlcnlDbGllbnRTaGFyaW5nQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KGZhbHNlKTsgLy8gSWYgd2UgYXJlIGdpdmVuIGEgY29udGV4dCwgd2Ugd2lsbCB1c2UgaXQuXG4vLyBPdGhlcndpc2UsIGlmIGNvbnRleHRTaGFyaW5nIGlzIG9uLCB3ZSBzaGFyZSB0aGUgZmlyc3QgYW5kIGF0IGxlYXN0IG9uZVxuLy8gaW5zdGFuY2Ugb2YgdGhlIGNvbnRleHQgYWNyb3NzIHRoZSB3aW5kb3dcbi8vIHRvIGVuc3VyZSB0aGF0IGlmIFJlYWN0IFF1ZXJ5IGlzIHVzZWQgYWNyb3NzXG4vLyBkaWZmZXJlbnQgYnVuZGxlcyBvciBtaWNyb2Zyb250ZW5kcyB0aGV5IHdpbGxcbi8vIGFsbCB1c2UgdGhlIHNhbWUgKippbnN0YW5jZSoqIG9mIGNvbnRleHQsIHJlZ2FyZGxlc3Ncbi8vIG9mIG1vZHVsZSBzY29waW5nLlxuXG5mdW5jdGlvbiBnZXRRdWVyeUNsaWVudENvbnRleHQoY29udGV4dCwgY29udGV4dFNoYXJpbmcpIHtcbiAgaWYgKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuXG4gIGlmIChjb250ZXh0U2hhcmluZyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICghd2luZG93LlJlYWN0UXVlcnlDbGllbnRDb250ZXh0KSB7XG4gICAgICB3aW5kb3cuUmVhY3RRdWVyeUNsaWVudENvbnRleHQgPSBkZWZhdWx0Q29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gd2luZG93LlJlYWN0UXVlcnlDbGllbnRDb250ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRDb250ZXh0O1xufVxuXG5jb25zdCB1c2VRdWVyeUNsaWVudCA9ICh7XG4gIGNvbnRleHRcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBxdWVyeUNsaWVudCA9IFJlYWN0LnVzZUNvbnRleHQoZ2V0UXVlcnlDbGllbnRDb250ZXh0KGNvbnRleHQsIFJlYWN0LnVzZUNvbnRleHQoUXVlcnlDbGllbnRTaGFyaW5nQ29udGV4dCkpKTtcblxuICBpZiAoIXF1ZXJ5Q2xpZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBRdWVyeUNsaWVudCBzZXQsIHVzZSBRdWVyeUNsaWVudFByb3ZpZGVyIHRvIHNldCBvbmUnKTtcbiAgfVxuXG4gIHJldHVybiBxdWVyeUNsaWVudDtcbn07XG5jb25zdCBRdWVyeUNsaWVudFByb3ZpZGVyID0gKHtcbiAgY2xpZW50LFxuICBjaGlsZHJlbixcbiAgY29udGV4dCxcbiAgY29udGV4dFNoYXJpbmcgPSBmYWxzZVxufSkgPT4ge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNsaWVudC5tb3VudCgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGllbnQudW5tb3VudCgpO1xuICAgIH07XG4gIH0sIFtjbGllbnRdKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb250ZXh0U2hhcmluZykge1xuICAgIGNsaWVudC5nZXRMb2dnZXIoKS5lcnJvcihcIlRoZSBjb250ZXh0U2hhcmluZyBvcHRpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cIik7XG4gIH1cblxuICBjb25zdCBDb250ZXh0ID0gZ2V0UXVlcnlDbGllbnRDb250ZXh0KGNvbnRleHQsIGNvbnRleHRTaGFyaW5nKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFF1ZXJ5Q2xpZW50U2hhcmluZ0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogIWNvbnRleHQgJiYgY29udGV4dFNoYXJpbmdcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjbGllbnRcbiAgfSwgY2hpbGRyZW4pKTtcbn07XG5cbmV4cG9ydCB7IFF1ZXJ5Q2xpZW50UHJvdmlkZXIsIGRlZmF1bHRDb250ZXh0LCB1c2VRdWVyeUNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVlcnlDbGllbnRQcm92aWRlci5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJkZWZhdWx0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJRdWVyeUNsaWVudFNoYXJpbmdDb250ZXh0IiwiZ2V0UXVlcnlDbGllbnRDb250ZXh0IiwiY29udGV4dCIsImNvbnRleHRTaGFyaW5nIiwid2luZG93IiwiUmVhY3RRdWVyeUNsaWVudENvbnRleHQiLCJ1c2VRdWVyeUNsaWVudCIsInF1ZXJ5Q2xpZW50IiwidXNlQ29udGV4dCIsIkVycm9yIiwiUXVlcnlDbGllbnRQcm92aWRlciIsImNsaWVudCIsImNoaWxkcmVuIiwidXNlRWZmZWN0IiwibW91bnQiLCJ1bm1vdW50IiwicHJvY2VzcyIsImdldExvZ2dlciIsImVycm9yIiwiQ29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   Expanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Expanding),\n/* harmony export */   Filters: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Filters),\n/* harmony export */   Grouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Grouping),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   Ordering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Ordering),\n/* harmony export */   Pagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pagination),\n/* harmony export */   Pinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   Sorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Sorting),\n/* harmony export */   Visibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Visibility),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n * react-table\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUM4QjtBQUNvQjtBQUNkO0FBRXJDLEVBQUU7QUFDRjs7Q0FFQyxHQUNELFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUM3QixPQUFPLENBQUNELE9BQU8sT0FBT0UsaUJBQWlCRixRQUFRLFdBQVcsR0FBRUgsZ0RBQW1CLENBQUNHLE1BQU1DLFNBQVNEO0FBQ2pHO0FBQ0EsU0FBU0UsaUJBQWlCRSxTQUFTO0lBQ2pDLE9BQU9DLGlCQUFpQkQsY0FBYyxPQUFPQSxjQUFjLGNBQWNFLGtCQUFrQkY7QUFDN0Y7QUFDQSxTQUFTQyxpQkFBaUJELFNBQVM7SUFDakMsT0FBTyxPQUFPQSxjQUFjLGNBQWMsQ0FBQztRQUN6QyxNQUFNRyxRQUFRQyxPQUFPQyxjQUFjLENBQUNMO1FBQ3BDLE9BQU9HLE1BQU1HLFNBQVMsSUFBSUgsTUFBTUcsU0FBUyxDQUFDUixnQkFBZ0I7SUFDNUQ7QUFDRjtBQUNBLFNBQVNJLGtCQUFrQkYsU0FBUztJQUNsQyxPQUFPLE9BQU9BLGNBQWMsWUFBWSxPQUFPQSxVQUFVTyxRQUFRLEtBQUssWUFBWTtRQUFDO1FBQWM7S0FBb0IsQ0FBQ0MsUUFBUSxDQUFDUixVQUFVTyxRQUFRLENBQUNFLFdBQVc7QUFDL0o7QUFDQSxTQUFTQyxjQUFjQyxPQUFPO0lBQzVCLHFEQUFxRDtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEJDLE9BQU8sQ0FBQztRQUNSLGNBQWM7UUFDZEMsZUFBZSxLQUFPO1FBQ3RCLE9BQU87UUFDUEMscUJBQXFCO1FBQ3JCLEdBQUdKLE9BQU87SUFDWjtJQUVBLDJDQUEyQztJQUMzQyxNQUFNLENBQUNLLFNBQVMsR0FBR3ZCLDJDQUFjLENBQUMsSUFBTztZQUN2Q3lCLFNBQVN4QixpRUFBV0EsQ0FBQ2tCO1FBQ3ZCO0lBRUEsc0VBQXNFO0lBQ3RFLE1BQU0sQ0FBQ0MsT0FBT00sU0FBUyxHQUFHMUIsMkNBQWMsQ0FBQyxJQUFNdUIsU0FBU0UsT0FBTyxDQUFDRSxZQUFZO0lBRTVFLGdGQUFnRjtJQUNoRixvREFBb0Q7SUFDcERKLFNBQVNFLE9BQU8sQ0FBQ0csVUFBVSxDQUFDQyxDQUFBQSxPQUFTO1lBQ25DLEdBQUdBLElBQUk7WUFDUCxHQUFHWCxPQUFPO1lBQ1ZFLE9BQU87Z0JBQ0wsR0FBR0EsS0FBSztnQkFDUixHQUFHRixRQUFRRSxLQUFLO1lBQ2xCO1lBQ0EsMEVBQTBFO1lBQzFFLFNBQVM7WUFDVEMsZUFBZVMsQ0FBQUE7Z0JBQ2JKLFNBQVNJO2dCQUNUWixRQUFRRyxhQUFhLElBQUksUUFBUUgsUUFBUUcsYUFBYSxDQUFDUztZQUN6RDtRQUNGO0lBQ0EsT0FBT1AsU0FBU0UsT0FBTztBQUN6QjtBQUVxQyxDQUNyQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanM/YTE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlYWN0LXRhYmxlXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcblxuLy9cbi8qKlxuICogSWYgcmVuZGVyaW5nIGhlYWRlcnMsIGNlbGxzLCBvciBmb290ZXJzIHdpdGggY3VzdG9tIG1hcmt1cCwgdXNlIGZsZXhSZW5kZXIgaW5zdGVhZCBvZiBgY2VsbC5nZXRWYWx1ZSgpYCBvciBgY2VsbC5yZW5kZXJWYWx1ZSgpYC5cbiAqL1xuZnVuY3Rpb24gZmxleFJlbmRlcihDb21wLCBwcm9wcykge1xuICByZXR1cm4gIUNvbXAgPyBudWxsIDogaXNSZWFjdENvbXBvbmVudChDb21wKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXAsIHByb3BzKSA6IENvbXA7XG59XG5mdW5jdGlvbiBpc1JlYWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHx8IHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgfHwgaXNFeG90aWNDb21wb25lbnQoY29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmICgoKSA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcG9uZW50KTtcbiAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlICYmIHByb3RvLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gaXNFeG90aWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29tcG9uZW50LiQkdHlwZW9mID09PSAnc3ltYm9sJyAmJiBbJ3JlYWN0Lm1lbW8nLCAncmVhY3QuZm9yd2FyZF9yZWYnXS5pbmNsdWRlcyhjb21wb25lbnQuJCR0eXBlb2YuZGVzY3JpcHRpb24pO1xufVxuZnVuY3Rpb24gdXNlUmVhY3RUYWJsZShvcHRpb25zKSB7XG4gIC8vIENvbXBvc2UgaW4gdGhlIGdlbmVyaWMgb3B0aW9ucyB0byB0aGUgdXNlciBvcHRpb25zXG4gIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICBzdGF0ZToge30sXG4gICAgLy8gRHVtbXkgc3RhdGVcbiAgICBvblN0YXRlQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICAvLyBub29wXG4gICAgcmVuZGVyRmFsbGJhY2tWYWx1ZTogbnVsbCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHRhYmxlIGFuZCBzdG9yZSBpdCBpbiBzdGF0ZVxuICBjb25zdCBbdGFibGVSZWZdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICBjdXJyZW50OiBjcmVhdGVUYWJsZShyZXNvbHZlZE9wdGlvbnMpXG4gIH0pKTtcblxuICAvLyBCeSBkZWZhdWx0LCBtYW5hZ2UgdGFibGUgc3RhdGUgaGVyZSB1c2luZyB0aGUgdGFibGUncyBpbml0aWFsIHN0YXRlXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gdGFibGVSZWYuY3VycmVudC5pbml0aWFsU3RhdGUpO1xuXG4gIC8vIENvbXBvc2UgdGhlIGRlZmF1bHQgc3RhdGUgYWJvdmUgd2l0aCBhbnkgdXNlciBzdGF0ZS4gVGhpcyB3aWxsIGFsbG93IHRoZSB1c2VyXG4gIC8vIHRvIG9ubHkgY29udHJvbCBhIHN1YnNldCBvZiB0aGUgc3RhdGUgaWYgZGVzaXJlZC5cbiAgdGFibGVSZWYuY3VycmVudC5zZXRPcHRpb25zKHByZXYgPT4gKHtcbiAgICAuLi5wcmV2LFxuICAgIC4uLm9wdGlvbnMsXG4gICAgc3RhdGU6IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ub3B0aW9ucy5zdGF0ZVxuICAgIH0sXG4gICAgLy8gU2ltaWxhcmx5LCB3ZSdsbCBtYWludGFpbiBib3RoIG91ciBpbnRlcm5hbCBzdGF0ZSBhbmQgYW55IHVzZXItcHJvdmlkZWRcbiAgICAvLyBzdGF0ZS5cbiAgICBvblN0YXRlQ2hhbmdlOiB1cGRhdGVyID0+IHtcbiAgICAgIHNldFN0YXRlKHVwZGF0ZXIpO1xuICAgICAgb3B0aW9ucy5vblN0YXRlQ2hhbmdlID09IG51bGwgfHwgb3B0aW9ucy5vblN0YXRlQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH1cbiAgfSkpO1xuICByZXR1cm4gdGFibGVSZWYuY3VycmVudDtcbn1cblxuZXhwb3J0IHsgZmxleFJlbmRlciwgdXNlUmVhY3RUYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlVGFibGUiLCJmbGV4UmVuZGVyIiwiQ29tcCIsInByb3BzIiwiaXNSZWFjdENvbXBvbmVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb21wb25lbnQiLCJpc0NsYXNzQ29tcG9uZW50IiwiaXNFeG90aWNDb21wb25lbnQiLCJwcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiJCR0eXBlb2YiLCJpbmNsdWRlcyIsImRlc2NyaXB0aW9uIiwidXNlUmVhY3RUYWJsZSIsIm9wdGlvbnMiLCJyZXNvbHZlZE9wdGlvbnMiLCJzdGF0ZSIsIm9uU3RhdGVDaGFuZ2UiLCJyZW5kZXJGYWxsYmFja1ZhbHVlIiwidGFibGVSZWYiLCJ1c2VTdGF0ZSIsImN1cnJlbnQiLCJzZXRTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInNldE9wdGlvbnMiLCJwcmV2IiwidXBkYXRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   Expanding: () => (/* binding */ Expanding),\n/* harmony export */   Filters: () => (/* binding */ Filters),\n/* harmony export */   Grouping: () => (/* binding */ Grouping),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Ordering: () => (/* binding */ Ordering),\n/* harmony export */   Pagination: () => (/* binding */ Pagination),\n/* harmony export */   Pinning: () => (/* binding */ Pinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   Sorting: () => (/* binding */ Sorting),\n/* harmony export */   Visibility: () => (/* binding */ Visibility),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n * table-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ // Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return ()=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(\".\", \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            }\n        }),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        })\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to uknown, because we know more than the compiler here.\n    return column;\n}\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, {\n            key:  true && \"getHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugHeaders;\n            }\n        });\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, {\n            key:  true && \"getCenterHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, {\n            key:  true && \"getLeftHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugHeaders;\n            }\n        });\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, {\n            key:  true && \"getRightHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugHeaders;\n            }\n        });\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getLeftFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getCenterFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA7;\n                return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getRightFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugHeaders;\n            }\n        });\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA9;\n                return (_table$options$debugA9 = table.options.debugAll) != null ? _table$options$debugA9 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getLeftFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA10;\n                return (_table$options$debugA10 = table.options.debugAll) != null ? _table$options$debugA10 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getCenterFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA11;\n                return (_table$options$debugA11 = table.options.debugAll) != null ? _table$options$debugA11 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getRightFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA12;\n                return (_table$options$debugA12 = table.options.debugAll) != null ? _table$options$debugA12 : table.options.debugHeaders;\n            }\n        });\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, {\n            key:  true && \"getCenterLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA13;\n                return (_table$options$debugA13 = table.options.debugAll) != null ? _table$options$debugA13 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, {\n            key:  true && \"getLeftLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA14;\n                return (_table$options$debugA14 = table.options.debugAll) != null ? _table$options$debugA14 : table.options.debugHeaders;\n            }\n        });\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, {\n            key:  true && \"getRightLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA15;\n                return (_table$options$debugA15 = table.options.debugAll) != null ? _table$options$debugA15 : table.options.debugHeaders;\n            }\n        });\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, {\n            key:  true && \"getLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA16;\n                return (_table$options$debugA16 = table.options.debugAll) != null ? _table$options$debugA16 : table.options.debugHeaders;\n            }\n        });\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = (position)=>{\n            const columns = !position ? table.getVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n            const index = columns.findIndex((d)=>d.id === column.id);\n            if (index > 0) {\n                const prevSiblingColumn = columns[index - 1];\n                return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();\n            }\n            return 0;\n        };\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = ()=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaOffset = clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0);\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        document.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        document.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        document.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        document.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    document.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    document.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    document.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    document.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst Expanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _row$getValue;\n    const search = filterValue.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst Filters = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            globalFilter: undefined,\n            // filtersProgress: 1,\n            // facetProgress: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100,\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;\n            return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousfilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousfilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    // () => [column.getFacetedRowModel()],\n    // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n    },\n    createRow: (row, table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter3, _table$options$filter4;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn];\n        };\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst Grouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _ref, _ref2, _ref3, _column$columnDef$ena;\n            return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst Ordering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, {\n            key:  true && \"getOrderColumnsFn\"\n        });\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst Pagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, {\n            key:  true && \"getPageOptions\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);\n        };\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst Pinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table),\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref3)=>{\n                let { id } = _ref3;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref4;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _table$_getPinnedRows, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, {\n            key:  true && \"row.getCenterVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                , \n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getLeftVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getRightVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getLeftLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        });\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getRightLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        });\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, {\n            key:  true && \"getCenterLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugColumns;\n            }\n        });\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState2;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio2;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);\n        };\n        table._getPinnedRows = (position)=>memo(()=>[\n                    table.getRowModel().rows,\n                    table.getState().rowPinning[position]\n                ], (visibleRows, pinnedRowIds)=>{\n                var _table$options$keepPi;\n                const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n                //account for expanded parent rows, but not pagination or filtering\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                    const row = table.getRow(rowId, true);\n                    return row.getIsAllParentsExpanded() ? row : null;\n                }) : //else get only visible rows that are pinned\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n                return rows.filter(Boolean).map((d)=>({\n                        ...d,\n                        position\n                    }));\n            }, {\n                key:  true && `row.get${position === \"top\" ? \"Top\" : \"Bottom\"}Rows`,\n                debug: ()=>{\n                    var _table$options$debugA7;\n                    return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugRows;\n                }\n            })();\n        table.getTopRows = ()=>table._getPinnedRows(\"top\");\n        table.getBottomRows = ()=>table._getPinnedRows(\"bottom\");\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, {\n            key:  true && \"row.getCenterRows\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugRows;\n            }\n        });\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  true && \"getSelectedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugTable;\n            }\n        });\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugTable;\n            }\n        });\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst Sorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\n//\nconst Visibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            return (_table$getState$colum = (_table$getState$colum2 = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum2[column.id]) != null ? _table$getState$colum : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], {\n            key:  true && \"row.getVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, {\n                key,\n                debug: ()=>{\n                    var _table$options$debugA3;\n                    return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n                }\n            });\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst features = [\n    Headers,\n    Visibility,\n    Ordering,\n    Pinning,\n    Filters,\n    Sorting,\n    Grouping,\n    Expanding,\n    Pagination,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$initialState;\n    if (options.debugAll || options.debugTable) {\n        console.info(\"Creating Table Instance...\");\n    }\n    let table = {\n        _features: features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features: features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        getRow: (id, searchAll)=>{\n            const row = (searchAll ? table.getCoreRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                if (true) {\n                    throw new Error(`getRow expected an ID, but got ${id}`);\n                }\n                throw new Error();\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, {\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            },\n            key:  true && \"getDefaultColumnDef\"\n        }),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, {\n            key:  true && \"getAllColumns\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        }),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, {\n            key:  true && \"getAllFlatColumns\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n            }\n        }),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, {\n            key:  true && \"getAllFlatColumnsById\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        }),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, {\n            key:  true && \"getAllLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        }),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), {\n            key:  true && \"cell.getContext\",\n            debug: ()=>table.options.debugAll\n        })\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, {\n            key:  true && \"row.getAllCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        }),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        })\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, {\n            key:  true && \"getRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = columnFilters.map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFilteredRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFacetedRowModel_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, {\n            key:  true && \"getFacetedUniqueValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            var _facetedRowModel$flat;\n            if (!facetedRowModel) return undefined;\n            const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n            if (typeof firstValue === \"undefined\") {\n                return undefined;\n            }\n            let facetedMinMaxValues = [\n                firstValue,\n                firstValue\n            ];\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (value < facetedMinMaxValues[0]) {\n                        facetedMinMaxValues[0] = value;\n                    } else if (value > facetedMinMaxValues[1]) {\n                        facetedMinMaxValues[1] = value;\n                    }\n                }\n            }\n            return facetedMinMaxValues;\n        }, {\n            key:  true && \"getFacetedMinMaxValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (columnInfo.sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, {\n            key:  true && \"getSortedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Peform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, {\n            key:  true && \"getGroupedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._queue(()=>{\n                    table._autoResetExpanded();\n                    table._autoResetPageIndex();\n                });\n            }\n        });\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, {\n            key:  true && \"getExpandedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, {\n            key:  true && \"getPaginationRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDRCx3QkFBd0I7QUFFeEIscURBQXFEO0FBRXJELEdBQUc7QUFFSCxTQUFTQSxpQkFBaUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxPQUFPLE9BQU9ELFlBQVksYUFBYUEsUUFBUUMsU0FBU0Q7QUFDMUQ7QUFDQSxTQUFTRTtBQUNQLEVBQUU7QUFDSjtBQUNBLFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxRQUFRO0lBQ3JDLE9BQU9MLENBQUFBO1FBQ0xLLFNBQVNDLFFBQVEsQ0FBQ0MsQ0FBQUE7WUFDaEIsT0FBTztnQkFDTCxHQUFHQSxHQUFHO2dCQUNOLENBQUNILElBQUksRUFBRUwsaUJBQWlCQyxTQUFTTyxHQUFHLENBQUNILElBQUk7WUFDM0M7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTSSxXQUFXQyxDQUFDO0lBQ25CLE9BQU9BLGFBQWFDO0FBQ3RCO0FBQ0EsU0FBU0MsY0FBY0YsQ0FBQztJQUN0QixPQUFPRyxNQUFNQyxPQUFPLENBQUNKLE1BQU1BLEVBQUVLLEtBQUssQ0FBQ0MsQ0FBQUEsTUFBTyxPQUFPQSxRQUFRO0FBQzNEO0FBQ0EsU0FBU0MsVUFBVUMsR0FBRyxFQUFFQyxXQUFXO0lBQ2pDLE1BQU1DLE9BQU8sRUFBRTtJQUNmLE1BQU1DLFVBQVVDLENBQUFBO1FBQ2RBLE9BQU9DLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDYkosS0FBS0ssSUFBSSxDQUFDRDtZQUNWLE1BQU1FLFdBQVdQLFlBQVlLO1lBQzdCLElBQUlFLFlBQVksUUFBUUEsU0FBU0MsTUFBTSxFQUFFO2dCQUN2Q04sUUFBUUs7WUFDVjtRQUNGO0lBQ0Y7SUFDQUwsUUFBUUg7SUFDUixPQUFPRTtBQUNUO0FBQ0EsU0FBU1EsS0FB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SSxDQUFDcGpCLE9BQU8sQ0FBQzY1QjtZQUMvQixPQUFPRztRQUNULEdBQUc7WUFDRGw3QixLQUFLeUUsS0FBeUIsSUFBaUI7WUFDL0MzQyxPQUFPO2dCQUNMLElBQUltRDtnQkFDSixPQUFPLENBQUNBLHdCQUF3QjNCLE1BQU00QixPQUFPLENBQUNDLFFBQVEsS0FBSyxPQUFPRix3QkFBd0IzQixNQUFNNEIsT0FBTyxDQUFDMmUsVUFBVTtZQUNwSDtRQUNGO0FBQ0Y7QUFFc3JCLENBQ3RyQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0MTMtYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcz81NTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdGFibGUtY29yZVxuICpcbiAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLy8gSXMgdGhpcyB0eXBlIGEgdHVwbGU/XG5cbi8vIElmIHRoaXMgdHlwZSBpcyBhIHR1cGxlLCB3aGF0IGluZGljZXMgYXJlIGFsbG93ZWQ/XG5cbi8vL1xuXG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vXG59XG5mdW5jdGlvbiBtYWtlU3RhdGVVcGRhdGVyKGtleSwgaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHVwZGF0ZXIgPT4ge1xuICAgIGluc3RhbmNlLnNldFN0YXRlKG9sZCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIFtrZXldOiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZFtrZXldKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZCkge1xuICByZXR1cm4gZCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheShkKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGQpICYmIGQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5CeShhcnIsIGdldENoaWxkcmVuKSB7XG4gIGNvbnN0IGZsYXQgPSBbXTtcbiAgY29uc3QgcmVjdXJzZSA9IHN1YkFyciA9PiB7XG4gICAgc3ViQXJyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBmbGF0LnB1c2goaXRlbSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKGl0ZW0pO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJlY3Vyc2UoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZWN1cnNlKGFycik7XG4gIHJldHVybiBmbGF0O1xufVxuZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IFtdO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcygpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIG9wdHMgPT0gbnVsbCB8fCBvcHRzLm9uQ2hhbmdlID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZShyZXN1bHQpO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGVidWcoKSkge1xuICAgICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgICBzdHIgPSAnICcgKyBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLCBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKSl9ZGVnIDEwMCUgMzElKTtgLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KSB7XG4gIHZhciBfcmVmLCBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQ7XG4gIGNvbnN0IGRlZmF1bHRDb2x1bW4gPSB0YWJsZS5fZ2V0RGVmYXVsdENvbHVtbkRlZigpO1xuICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHtcbiAgICAuLi5kZWZhdWx0Q29sdW1uLFxuICAgIC4uLmNvbHVtbkRlZlxuICB9O1xuICBjb25zdCBhY2Nlc3NvcktleSA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICBsZXQgaWQgPSAoX3JlZiA9IChfcmVzb2x2ZWRDb2x1bW5EZWYkaWQgPSByZXNvbHZlZENvbHVtbkRlZi5pZCkgIT0gbnVsbCA/IF9yZXNvbHZlZENvbHVtbkRlZiRpZCA6IGFjY2Vzc29yS2V5ID8gYWNjZXNzb3JLZXkucmVwbGFjZSgnLicsICdfJykgOiB1bmRlZmluZWQpICE9IG51bGwgPyBfcmVmIDogdHlwZW9mIHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA9PT0gJ3N0cmluZycgPyByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXIgOiB1bmRlZmluZWQ7XG4gIGxldCBhY2Nlc3NvckZuO1xuICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgIGFjY2Vzc29yRm4gPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuO1xuICB9IGVsc2UgaWYgKGFjY2Vzc29yS2V5KSB7XG4gICAgLy8gU3VwcG9ydCBkZWVwIGFjY2Vzc29yIGtleXNcbiAgICBpZiAoYWNjZXNzb3JLZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsUm93O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY2Nlc3NvcktleS5zcGxpdCgnLicpKSB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0ID0gKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0W2tleV07XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCIke2tleX1cIiBpbiBkZWVwbHkgbmVzdGVkIGtleSBcIiR7YWNjZXNzb3JLZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IG9yaWdpbmFsUm93W3Jlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbiA/IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhbiBhY2Nlc3NvckZuYCA6IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhIG5vbi1zdHJpbmcgaGVhZGVyYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIGxldCBjb2x1bW4gPSB7XG4gICAgaWQ6IGAke1N0cmluZyhpZCl9YCxcbiAgICBhY2Nlc3NvckZuLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGRlcHRoLFxuICAgIGNvbHVtbkRlZjogcmVzb2x2ZWRDb2x1bW5EZWYsXG4gICAgY29sdW1uczogW10sXG4gICAgZ2V0RmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RydWVdLCAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zO1xuICAgICAgcmV0dXJuIFtjb2x1bW4sIC4uLigoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1uJGNvbHVtbnMuZmxhdE1hcChkID0+IGQuZ2V0RmxhdENvbHVtbnMoKSkpXTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgJ2NvbHVtbi5nZXRGbGF0Q29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBnZXRMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCBvcmRlckNvbHVtbnMgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uczI7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1uczIgPSBjb2x1bW4uY29sdW1ucykgIT0gbnVsbCAmJiBfY29sdW1uJGNvbHVtbnMyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbGVhZkNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtjb2x1bW5dO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAnY29sdW1uLmdldExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pXG4gIH07XG4gIGZvciAoY29uc3QgZmVhdHVyZSBvZiB0YWJsZS5fZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNvbHVtbiA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlQ29sdW1uKGNvbHVtbiwgdGFibGUpO1xuICB9XG5cbiAgLy8gWWVzLCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGFibGUgdG8gdWtub3duLCBiZWNhdXNlIHdlIGtub3cgbW9yZSB0aGFuIHRoZSBjb21waWxlciBoZXJlLlxuICByZXR1cm4gY29sdW1uO1xufVxuXG4vL1xuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkaWQ7XG4gIGNvbnN0IGlkID0gKF9vcHRpb25zJGlkID0gb3B0aW9ucy5pZCkgIT0gbnVsbCA/IF9vcHRpb25zJGlkIDogY29sdW1uLmlkO1xuICBsZXQgaGVhZGVyID0ge1xuICAgIGlkLFxuICAgIGNvbHVtbixcbiAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICBpc1BsYWNlaG9sZGVyOiAhIW9wdGlvbnMuaXNQbGFjZWhvbGRlcixcbiAgICBwbGFjZWhvbGRlcklkOiBvcHRpb25zLnBsYWNlaG9sZGVySWQsXG4gICAgZGVwdGg6IG9wdGlvbnMuZGVwdGgsXG4gICAgc3ViSGVhZGVyczogW10sXG4gICAgY29sU3BhbjogMCxcbiAgICByb3dTcGFuOiAwLFxuICAgIGhlYWRlckdyb3VwOiBudWxsLFxuICAgIGdldExlYWZIZWFkZXJzOiAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmSGVhZGVycyA9IFtdO1xuICAgICAgY29uc3QgcmVjdXJzZUhlYWRlciA9IGggPT4ge1xuICAgICAgICBpZiAoaC5zdWJIZWFkZXJzICYmIGguc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoLnN1YkhlYWRlcnMubWFwKHJlY3Vyc2VIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxlYWZIZWFkZXJzLnB1c2goaCk7XG4gICAgICB9O1xuICAgICAgcmVjdXJzZUhlYWRlcihoZWFkZXIpO1xuICAgICAgcmV0dXJuIGxlYWZIZWFkZXJzO1xuICAgIH0sXG4gICAgZ2V0Q29udGV4dDogKCkgPT4gKHtcbiAgICAgIHRhYmxlLFxuICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICBjb2x1bW5cbiAgICB9KVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUhlYWRlciA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlSGVhZGVyKGhlYWRlciwgdGFibGUpO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcjtcbn1cbmNvbnN0IEhlYWRlcnMgPSB7XG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgLy8gSGVhZGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyLCBfcmlnaHQkbWFwJGZpbHRlcjtcbiAgICAgIGNvbnN0IGxlZnRDb2x1bW5zID0gKF9sZWZ0JG1hcCRmaWx0ZXIgPSBsZWZ0ID09IG51bGwgPyB2b2lkIDAgOiBsZWZ0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfbGVmdCRtYXAkZmlsdGVyIDogW107XG4gICAgICBjb25zdCByaWdodENvbHVtbnMgPSAoX3JpZ2h0JG1hcCRmaWx0ZXIgPSByaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9yaWdodCRtYXAkZmlsdGVyIDogW107XG4gICAgICBjb25zdCBjZW50ZXJDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiAhKGxlZnQgIT0gbnVsbCAmJiBsZWZ0LmluY2x1ZGVzKGNvbHVtbi5pZCkpICYmICEocmlnaHQgIT0gbnVsbCAmJiByaWdodC5pbmNsdWRlcyhjb2x1bW4uaWQpKSk7XG4gICAgICBjb25zdCBoZWFkZXJHcm91cHMgPSBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBbLi4ubGVmdENvbHVtbnMsIC4uLmNlbnRlckNvbHVtbnMsIC4uLnJpZ2h0Q29sdW1uc10sIHRhYmxlKTtcbiAgICAgIHJldHVybiBoZWFkZXJHcm91cHM7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0SGVhZGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZWFmQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCB0YWJsZSwgJ2NlbnRlcicpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldENlbnRlckhlYWRlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyMjtcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyMiA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ2xlZnQnKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWZ0SGVhZGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9yaWdodCRtYXAkZmlsdGVyMjtcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfcmlnaHQkbWFwJGZpbHRlcjIgPSByaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9yaWdodCRtYXAkZmlsdGVyMiA6IFtdO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIG9yZGVyZWRMZWFmQ29sdW1ucywgdGFibGUsICdyaWdodCcpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFJpZ2h0SGVhZGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTQgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRm9vdGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTU7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0TGVmdEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlZnRGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTY7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyRm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTc7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UmlnaHRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTg7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBOCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGbGF0IEhlYWRlcnNcblxuICAgIHRhYmxlLmdldEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBOTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E5ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTkgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKCldLCBsZWZ0ID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Lm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlZnRGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTA7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTAgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTAgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTE7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTEgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTEgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExlYWYgSGVhZGVyc1xuXG4gICAgdGFibGUuZ2V0Q2VudGVyTGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycygpXSwgZmxhdEhlYWRlcnMgPT4ge1xuICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xuICAgICAgICB2YXIgX2hlYWRlciRzdWJIZWFkZXJzO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJMZWFmSGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTM7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTMgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczI7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMyID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMi5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVmdExlYWZIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNDtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNCA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMzO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFJpZ2h0TGVhZkhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTE1O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTE1ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTE1IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKCksIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpLCB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgKGxlZnQsIGNlbnRlciwgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfbGVmdCQwJGhlYWRlcnMsIF9sZWZ0JCwgX2NlbnRlciQwJGhlYWRlcnMsIF9jZW50ZXIkLCBfcmlnaHQkMCRoZWFkZXJzLCBfcmlnaHQkO1xuICAgICAgcmV0dXJuIFsuLi4oKF9sZWZ0JDAkaGVhZGVycyA9IChfbGVmdCQgPSBsZWZ0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2xlZnQkLmhlYWRlcnMpICE9IG51bGwgPyBfbGVmdCQwJGhlYWRlcnMgOiBbXSksIC4uLigoX2NlbnRlciQwJGhlYWRlcnMgPSAoX2NlbnRlciQgPSBjZW50ZXJbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfY2VudGVyJC5oZWFkZXJzKSAhPSBudWxsID8gX2NlbnRlciQwJGhlYWRlcnMgOiBbXSksIC4uLigoX3JpZ2h0JDAkaGVhZGVycyA9IChfcmlnaHQkID0gcmlnaHRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcmlnaHQkLmhlYWRlcnMpICE9IG51bGwgPyBfcmlnaHQkMCRoZWFkZXJzIDogW10pXS5tYXAoaGVhZGVyID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlci5nZXRMZWFmSGVhZGVycygpO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlYWZIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNiA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgY29sdW1uc1RvR3JvdXAsIHRhYmxlLCBoZWFkZXJGYW1pbHkpIHtcbiAgdmFyIF9oZWFkZXJHcm91cHMkMCRoZWFkZSwgX2hlYWRlckdyb3VwcyQ7XG4gIC8vIEZpbmQgdGhlIG1heCBkZXB0aCBvZiB0aGUgY29sdW1uczpcbiAgLy8gYnVpbGQgdGhlIGxlYWYgY29sdW1uIHJvd1xuICAvLyBidWlsZCBlYWNoIGJ1ZmZlciByb3cgZ29pbmcgdXBcbiAgLy8gICAgcGxhY2Vob2xkZXIgZm9yIG5vbi1leGlzdGVudCBsZXZlbFxuICAvLyAgICByZWFsIGNvbHVtbiBmb3IgZXhpc3RpbmcgbGV2ZWxcblxuICBsZXQgbWF4RGVwdGggPSAwO1xuICBjb25zdCBmaW5kTWF4RGVwdGggPSBmdW5jdGlvbiAoY29sdW1ucywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAxO1xuICAgIH1cbiAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XG4gICAgY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUoKSkuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1ucztcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBmaW5kTWF4RGVwdGgoY29sdW1uLmNvbHVtbnMsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH07XG4gIGZpbmRNYXhEZXB0aChhbGxDb2x1bW5zKTtcbiAgbGV0IGhlYWRlckdyb3VwcyA9IFtdO1xuICBjb25zdCBjcmVhdGVIZWFkZXJHcm91cCA9IChoZWFkZXJzVG9Hcm91cCwgZGVwdGgpID0+IHtcbiAgICAvLyBUaGUgaGVhZGVyIGdyb3VwIHdlIGFyZSBjcmVhdGluZ1xuICAgIGNvbnN0IGhlYWRlckdyb3VwID0ge1xuICAgICAgZGVwdGgsXG4gICAgICBpZDogW2hlYWRlckZhbWlseSwgYCR7ZGVwdGh9YF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgIGhlYWRlcnM6IFtdXG4gICAgfTtcblxuICAgIC8vIFRoZSBwYXJlbnQgY29sdW1ucyB3ZSdyZSBnb2luZyB0byBzY2FuIG5leHRcbiAgICBjb25zdCBwZW5kaW5nUGFyZW50SGVhZGVycyA9IFtdO1xuXG4gICAgLy8gU2NhbiBlYWNoIGNvbHVtbiBmb3IgcGFyZW50c1xuICAgIGhlYWRlcnNUb0dyb3VwLmZvckVhY2goaGVhZGVyVG9Hcm91cCA9PiB7XG4gICAgICAvLyBXaGF0IGlzIHRoZSBsYXRlc3QgKGxhc3QpIHBhcmVudCBjb2x1bW4/XG5cbiAgICAgIGNvbnN0IGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgPSBbLi4ucGVuZGluZ1BhcmVudEhlYWRlcnNdLnJldmVyc2UoKVswXTtcbiAgICAgIGNvbnN0IGlzTGVhZkhlYWRlciA9IGhlYWRlclRvR3JvdXAuY29sdW1uLmRlcHRoID09PSBoZWFkZXJHcm91cC5kZXB0aDtcbiAgICAgIGxldCBjb2x1bW47XG4gICAgICBsZXQgaXNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgICAgaWYgKGlzTGVhZkhlYWRlciAmJiBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgbmV3XG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIHJlcGVhdGVkXG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uO1xuICAgICAgICBpc1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyICYmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLmNvbHVtbikgPT09IGNvbHVtbikge1xuICAgICAgICAvLyBUaGlzIGNvbHVtbiBpcyByZXBlYXRlZC4gQWRkIGl0IGFzIGEgc3ViIGhlYWRlciB0byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgaGVhZGVyLiBMZXQncyBjcmVhdGUgaXRcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICAgICAgICBpZDogW2hlYWRlckZhbWlseSwgZGVwdGgsIGNvbHVtbi5pZCwgaGVhZGVyVG9Hcm91cCA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVyVG9Hcm91cC5pZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgICAgICBpc1BsYWNlaG9sZGVyLFxuICAgICAgICAgIHBsYWNlaG9sZGVySWQ6IGlzUGxhY2Vob2xkZXIgPyBgJHtwZW5kaW5nUGFyZW50SGVhZGVycy5maWx0ZXIoZCA9PiBkLmNvbHVtbiA9PT0gY29sdW1uKS5sZW5ndGh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBpbmRleDogcGVuZGluZ1BhcmVudEhlYWRlcnMubGVuZ3RoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyVG9Hcm91cCBhcyBhIHN1YkhlYWRlciBvZiB0aGUgbmV3IGhlYWRlclxuICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBoZWFkZXIgdG8gdGhlIHBlbmRpbmdQYXJlbnRIZWFkZXJzIHRvIGdldCBncm91cGVkXG4gICAgICAgIC8vIGluIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIHBlbmRpbmdQYXJlbnRIZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlckdyb3VwLmhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIGhlYWRlclRvR3JvdXAuaGVhZGVyR3JvdXAgPSBoZWFkZXJHcm91cDtcbiAgICB9KTtcbiAgICBoZWFkZXJHcm91cHMucHVzaChoZWFkZXJHcm91cCk7XG4gICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgY3JlYXRlSGVhZGVyR3JvdXAocGVuZGluZ1BhcmVudEhlYWRlcnMsIGRlcHRoIC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBib3R0b21IZWFkZXJzID0gY29sdW1uc1RvR3JvdXAubWFwKChjb2x1bW4sIGluZGV4KSA9PiBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwge1xuICAgIGRlcHRoOiBtYXhEZXB0aCxcbiAgICBpbmRleFxuICB9KSk7XG4gIGNyZWF0ZUhlYWRlckdyb3VwKGJvdHRvbUhlYWRlcnMsIG1heERlcHRoIC0gMSk7XG4gIGhlYWRlckdyb3Vwcy5yZXZlcnNlKCk7XG5cbiAgLy8gaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzLmZpbHRlcihoZWFkZXJHcm91cCA9PiB7XG4gIC8vICAgcmV0dXJuICFoZWFkZXJHcm91cC5oZWFkZXJzLmV2ZXJ5KGhlYWRlciA9PiBoZWFkZXIuaXNQbGFjZWhvbGRlcilcbiAgLy8gfSlcblxuICBjb25zdCByZWN1cnNlSGVhZGVyc0ZvclNwYW5zID0gaGVhZGVycyA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWRIZWFkZXJzID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IGhlYWRlci5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHJldHVybiBmaWx0ZXJlZEhlYWRlcnMubWFwKGhlYWRlciA9PiB7XG4gICAgICBsZXQgY29sU3BhbiA9IDA7XG4gICAgICBsZXQgcm93U3BhbiA9IDA7XG4gICAgICBsZXQgY2hpbGRSb3dTcGFucyA9IFswXTtcbiAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycyAmJiBoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2hpbGRSb3dTcGFucyA9IFtdO1xuICAgICAgICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKGhlYWRlci5zdWJIZWFkZXJzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb2xTcGFuOiBjaGlsZENvbFNwYW4sXG4gICAgICAgICAgICByb3dTcGFuOiBjaGlsZFJvd1NwYW5cbiAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICBjb2xTcGFuICs9IGNoaWxkQ29sU3BhbjtcbiAgICAgICAgICBjaGlsZFJvd1NwYW5zLnB1c2goY2hpbGRSb3dTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xTcGFuID0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbkNoaWxkUm93U3BhbiA9IE1hdGgubWluKC4uLmNoaWxkUm93U3BhbnMpO1xuICAgICAgcm93U3BhbiA9IHJvd1NwYW4gKyBtaW5DaGlsZFJvd1NwYW47XG4gICAgICBoZWFkZXIuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICBoZWFkZXIucm93U3BhbiA9IHJvd1NwYW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xTcGFuLFxuICAgICAgICByb3dTcGFuXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKChfaGVhZGVyR3JvdXBzJDAkaGVhZGUgPSAoX2hlYWRlckdyb3VwcyQgPSBoZWFkZXJHcm91cHNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyR3JvdXBzJC5oZWFkZXJzKSAhPSBudWxsID8gX2hlYWRlckdyb3VwcyQwJGhlYWRlIDogW10pO1xuICByZXR1cm4gaGVhZGVyR3JvdXBzO1xufVxuXG4vL1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0Q29sdW1uU2l6aW5nID0ge1xuICBzaXplOiAxNTAsXG4gIG1pblNpemU6IDIwLFxuICBtYXhTaXplOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxufTtcbmNvbnN0IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUgPSAoKSA9PiAoe1xuICBzdGFydE9mZnNldDogbnVsbCxcbiAgc3RhcnRTaXplOiBudWxsLFxuICBkZWx0YU9mZnNldDogbnVsbCxcbiAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcbiAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG59KTtcbmNvbnN0IENvbHVtblNpemluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiBkZWZhdWx0Q29sdW1uU2l6aW5nO1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uU2l6aW5nOiB7fSxcbiAgICAgIGNvbHVtblNpemluZ0luZm86IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUmVzaXplTW9kZTogJ29uRW5kJyxcbiAgICAgIG9uQ29sdW1uU2l6aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5TaXppbmcnLCB0YWJsZSksXG4gICAgICBvbkNvbHVtblNpemluZ0luZm9DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZ0luZm8nLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkbWluLCBfcmVmLCBfY29sdW1uJGNvbHVtbkRlZiRtYXg7XG4gICAgICBjb25zdCBjb2x1bW5TaXplID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmdbY29sdW1uLmlkXTtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCgoX2NvbHVtbiRjb2x1bW5EZWYkbWluID0gY29sdW1uLmNvbHVtbkRlZi5taW5TaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWluIDogZGVmYXVsdENvbHVtblNpemluZy5taW5TaXplLCAoX3JlZiA9IGNvbHVtblNpemUgIT0gbnVsbCA/IGNvbHVtblNpemUgOiBjb2x1bW4uY29sdW1uRGVmLnNpemUpICE9IG51bGwgPyBfcmVmIDogZGVmYXVsdENvbHVtblNpemluZy5zaXplKSwgKF9jb2x1bW4kY29sdW1uRGVmJG1heCA9IGNvbHVtbi5jb2x1bW5EZWYubWF4U2l6ZSkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJG1heCA6IGRlZmF1bHRDb2x1bW5TaXppbmcubWF4U2l6ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U3RhcnQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5zID0gIXBvc2l0aW9uID8gdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucygpIDogdGFibGUuZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMoKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29sdW1ucy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZ0NvbHVtbiA9IGNvbHVtbnNbaW5kZXggLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nQ29sdW1uLmdldFN0YXJ0KHBvc2l0aW9uKSArIHByZXZTaWJsaW5nQ29sdW1uLmdldFNpemUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgY29sdW1uLnJlc2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgW2NvbHVtbi5pZF06IF8sXG4gICAgICAgICAgLi4ucmVzdFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiByZXN0O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuUmVzaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVSZXNpemluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5SZXNpemluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzUmVzaXppbmcgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmdJbmZvLmlzUmVzaXppbmdDb2x1bW4gPT09IGNvbHVtbi5pZDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVIZWFkZXI6IChoZWFkZXIsIHRhYmxlKSA9PiB7XG4gICAgaGVhZGVyLmdldFNpemUgPSAoKSA9PiB7XG4gICAgICBsZXQgc3VtID0gMDtcbiAgICAgIGNvbnN0IHJlY3Vyc2UgPSBoZWFkZXIgPT4ge1xuICAgICAgICBpZiAoaGVhZGVyLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMuZm9yRWFjaChyZWN1cnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2hlYWRlciRjb2x1bW4kZ2V0U2l6O1xuICAgICAgICAgIHN1bSArPSAoX2hlYWRlciRjb2x1bW4kZ2V0U2l6ID0gaGVhZGVyLmNvbHVtbi5nZXRTaXplKCkpICE9IG51bGwgPyBfaGVhZGVyJGNvbHVtbiRnZXRTaXogOiAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVjdXJzZShoZWFkZXIpO1xuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuICAgIGhlYWRlci5nZXRTdGFydCA9ICgpID0+IHtcbiAgICAgIGlmIChoZWFkZXIuaW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IHByZXZTaWJsaW5nSGVhZGVyID0gaGVhZGVyLmhlYWRlckdyb3VwLmhlYWRlcnNbaGVhZGVyLmluZGV4IC0gMV07XG4gICAgICAgIHJldHVybiBwcmV2U2libGluZ0hlYWRlci5nZXRTdGFydCgpICsgcHJldlNpYmxpbmdIZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBoZWFkZXIuZ2V0UmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihoZWFkZXIuY29sdW1uLmlkKTtcbiAgICAgIGNvbnN0IGNhblJlc2l6ZSA9IGNvbHVtbiA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldENhblJlc2l6ZSgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBpZiAoIWNvbHVtbiB8fCAhY2FuUmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICBpZiAoaXNUb3VjaFN0YXJ0RXZlbnQoZSkpIHtcbiAgICAgICAgICAvLyBsZXRzIG5vdCByZXNwb25kIHRvIG11bHRpcGxlIHRvdWNoZXMgKGUuZy4gMiBvciAzIGZpbmdlcnMpXG4gICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFNpemUgPSBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgICBjb25zdCBjb2x1bW5TaXppbmdTdGFydCA9IGhlYWRlciA/IGhlYWRlci5nZXRMZWFmSGVhZGVycygpLm1hcChkID0+IFtkLmNvbHVtbi5pZCwgZC5jb2x1bW4uZ2V0U2l6ZSgpXSkgOiBbW2NvbHVtbi5pZCwgY29sdW1uLmdldFNpemUoKV1dO1xuICAgICAgICBjb25zdCBjbGllbnRYID0gaXNUb3VjaFN0YXJ0RXZlbnQoZSkgPyBNYXRoLnJvdW5kKGUudG91Y2hlc1swXS5jbGllbnRYKSA6IGUuY2xpZW50WDtcbiAgICAgICAgY29uc3QgbmV3Q29sdW1uU2l6aW5nID0ge307XG4gICAgICAgIGNvbnN0IHVwZGF0ZU9mZnNldCA9IChldmVudFR5cGUsIGNsaWVudFhQb3MpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNsaWVudFhQb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+IHtcbiAgICAgICAgICAgIHZhciBfb2xkJHN0YXJ0T2Zmc2V0LCBfb2xkJHN0YXJ0U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gY2xpZW50WFBvcyAtICgoX29sZCRzdGFydE9mZnNldCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0T2Zmc2V0KSAhPSBudWxsID8gX29sZCRzdGFydE9mZnNldCA6IDApO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFQZXJjZW50YWdlID0gTWF0aC5tYXgoZGVsdGFPZmZzZXQgLyAoKF9vbGQkc3RhcnRTaXplID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuc3RhcnRTaXplKSAhPSBudWxsID8gX29sZCRzdGFydFNpemUgOiAwKSwgLTAuOTk5OTk5KTtcbiAgICAgICAgICAgIG9sZC5jb2x1bW5TaXppbmdTdGFydC5mb3JFYWNoKF9yZWYzID0+IHtcbiAgICAgICAgICAgICAgbGV0IFtjb2x1bW5JZCwgaGVhZGVyU2l6ZV0gPSBfcmVmMztcbiAgICAgICAgICAgICAgbmV3Q29sdW1uU2l6aW5nW2NvbHVtbklkXSA9IE1hdGgucm91bmQoTWF0aC5tYXgoaGVhZGVyU2l6ZSArIGhlYWRlclNpemUgKiBkZWx0YVBlcmNlbnRhZ2UsIDApICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICBkZWx0YU9mZnNldCxcbiAgICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmNvbHVtblJlc2l6ZU1vZGUgPT09ICdvbkNoYW5nZScgfHwgZXZlbnRUeXBlID09PSAnZW5kJykge1xuICAgICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKG9sZCA9PiAoe1xuICAgICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICAgIC4uLm5ld0NvbHVtblNpemluZ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Nb3ZlID0gY2xpZW50WFBvcyA9PiB1cGRhdGVPZmZzZXQoJ21vdmUnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgY29uc3Qgb25FbmQgPSBjbGllbnRYUG9zID0+IHtcbiAgICAgICAgICB1cGRhdGVPZmZzZXQoJ2VuZCcsIGNsaWVudFhQb3MpO1xuICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgc3RhcnRTaXplOiBudWxsLFxuICAgICAgICAgICAgZGVsdGFPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IG51bGwsXG4gICAgICAgICAgICBjb2x1bW5TaXppbmdTdGFydDogW11cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IG9uTW92ZShlLmNsaWVudFgpLFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VFdmVudHMudXBIYW5kbGVyKTtcbiAgICAgICAgICAgIG9uRW5kKGUuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cEhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9lJHRvdWNoZXMkO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2hFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkVuZCgoX2UkdG91Y2hlcyQgPSBlLnRvdWNoZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZSR0b3VjaGVzJC5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhc3NpdmVJZlN1cHBvcnRlZCA9IHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpID8ge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2hFdmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlRXZlbnRzLnVwSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiAoe1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBzdGFydE9mZnNldDogY2xpZW50WCxcbiAgICAgICAgICBzdGFydFNpemUsXG4gICAgICAgICAgZGVsdGFPZmZzZXQ6IDAsXG4gICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiAwLFxuICAgICAgICAgIGNvbHVtblNpemluZ1N0YXJ0LFxuICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46IGNvbHVtbi5pZFxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8gPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblNpemluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5TaXppbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEhlYWRlclNpemVJbmZvID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMyO1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjMiA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5TaXppbmdJbmZvKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjMiA6IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldEhlYWRlckdyb3VwLCBfdGFibGUkZ2V0SGVhZGVyR3JvdXAyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0SGVhZGVyR3JvdXAgPSAoX3RhYmxlJGdldEhlYWRlckdyb3VwMiA9IHRhYmxlLmdldEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldEhlYWRlckdyb3VwMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRIZWFkZXJHcm91cCA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRMZWZ0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRMZWZ0SGVhZGVyRywgX3RhYmxlJGdldExlZnRIZWFkZXJHMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldExlZnRIZWFkZXJHID0gKF90YWJsZSRnZXRMZWZ0SGVhZGVyRzIgPSB0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0TGVmdEhlYWRlckcyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldExlZnRIZWFkZXJHIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldENlbnRlclRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0Q2VudGVySGVhZGUsIF90YWJsZSRnZXRDZW50ZXJIZWFkZTI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRDZW50ZXJIZWFkZSA9IChfdGFibGUkZ2V0Q2VudGVySGVhZGUyID0gdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q2VudGVySGVhZGUyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldENlbnRlckhlYWRlIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldFJpZ2h0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRSaWdodEhlYWRlciwgX3RhYmxlJGdldFJpZ2h0SGVhZGVyMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFJpZ2h0SGVhZGVyID0gKF90YWJsZSRnZXRSaWdodEhlYWRlcjIgPSB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFJpZ2h0SGVhZGVyMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRSaWdodEhlYWRlciA6IDA7XG4gICAgfTtcbiAgfVxufTtcbmxldCBwYXNzaXZlU3VwcG9ydGVkID0gbnVsbDtcbmZ1bmN0aW9uIHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBwYXNzaXZlU3VwcG9ydGVkID09PSAnYm9vbGVhbicpIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xuICBsZXQgc3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub29wID0gKCkgPT4ge307XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBub29wLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG5vb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICBwYXNzaXZlU3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn1cbmZ1bmN0aW9uIGlzVG91Y2hTdGFydEV2ZW50KGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnO1xufVxuXG4vL1xuXG5jb25zdCBFeHBhbmRpbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBleHBhbmRlZDoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXhwYW5kZWRDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2V4cGFuZGVkJywgdGFibGUpLFxuICAgICAgcGFnaW5hdGVFeHBhbmRlZFJvd3M6IHRydWVcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGxldCByZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgbGV0IHF1ZXVlZCA9IGZhbHNlO1xuICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRhdXRvUmUgPSB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGF1dG9SZSA6IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0RXhwYW5kZWQpICE9IG51bGwgPyBfcmVmIDogIXRhYmxlLm9wdGlvbnMubWFudWFsRXhwYW5kaW5nKSB7XG4gICAgICAgIGlmIChxdWV1ZWQpIHJldHVybjtcbiAgICAgICAgcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICB0YWJsZS5yZXNldEV4cGFuZGVkKCk7XG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUuc2V0RXhwYW5kZWQgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25FeHBhbmRlZENoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIGlmIChleHBhbmRlZCAhPSBudWxsID8gZXhwYW5kZWQgOiAhdGFibGUuZ2V0SXNBbGxSb3dzRXhwYW5kZWQoKSkge1xuICAgICAgICB0YWJsZS5zZXRFeHBhbmRlZCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlLnNldEV4cGFuZGVkKHt9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkZSwgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkZSA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5leHBhbmRlZCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkZSA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLmdldENhblNvbWVSb3dzRXhwYW5kID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5FeHBhbmQoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkKCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSB0cnVlIHx8IE9iamVjdC52YWx1ZXMoZXhwYW5kZWQpLnNvbWUoQm9vbGVhbik7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcblxuICAgICAgLy8gSWYgZXhwYW5kZWQgaXMgdHJ1ZSwgc2F2ZSBzb21lIGN5Y2xlcyBhbmQgcmV0dXJuIHRydWVcbiAgICAgIGlmICh0eXBlb2YgZXhwYW5kZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKGV4cGFuZGVkKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhbnkgcm93IGlzIG5vdCBleHBhbmRlZCwgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAodGFibGUuZ2V0Um93TW9kZWwoKS5mbGF0Um93cy5zb21lKHJvdyA9PiAhcm93LmdldElzRXhwYW5kZWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGV5IG11c3QgYWxsIGJlIGV4cGFuZGVkIDpzaHJ1ZzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdGFibGUuZ2V0RXhwYW5kZWREZXB0aCA9ICgpID0+IHtcbiAgICAgIGxldCBtYXhEZXB0aCA9IDA7XG4gICAgICBjb25zdCByb3dJZHMgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkID09PSB0cnVlID8gT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkgOiBPYmplY3Qua2V5cyh0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkKTtcbiAgICAgIHJvd0lkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXRJZCA9IGlkLnNwbGl0KCcuJyk7XG4gICAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIHNwbGl0SWQubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1heERlcHRoO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldFNvcnRlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZyB8fCAhdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cudG9nZ2xlRXhwYW5kZWQgPSBleHBhbmRlZCA9PiB7XG4gICAgICB0YWJsZS5zZXRFeHBhbmRlZChvbGQgPT4ge1xuICAgICAgICB2YXIgX2V4cGFuZGVkO1xuICAgICAgICBjb25zdCBleGlzdHMgPSBvbGQgPT09IHRydWUgPyB0cnVlIDogISEob2xkICE9IG51bGwgJiYgb2xkW3Jvdy5pZF0pO1xuICAgICAgICBsZXQgb2xkRXhwYW5kZWQgPSB7fTtcbiAgICAgICAgaWYgKG9sZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRhYmxlLmdldFJvd01vZGVsKCkucm93c0J5SWQpLmZvckVhY2gocm93SWQgPT4ge1xuICAgICAgICAgICAgb2xkRXhwYW5kZWRbcm93SWRdID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRFeHBhbmRlZCA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICBleHBhbmRlZCA9IChfZXhwYW5kZWQgPSBleHBhbmRlZCkgIT0gbnVsbCA/IF9leHBhbmRlZCA6ICFleGlzdHM7XG4gICAgICAgIGlmICghZXhpc3RzICYmIGV4cGFuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm9sZEV4cGFuZGVkLFxuICAgICAgICAgICAgW3Jvdy5pZF06IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleGlzdHMgJiYgIWV4cGFuZGVkKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgW3Jvdy5pZF06IF8sXG4gICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgICAgfSA9IG9sZEV4cGFuZGVkO1xuICAgICAgICAgIHJldHVybiByZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldElzUjtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcbiAgICAgIHJldHVybiAhISgoX3RhYmxlJG9wdGlvbnMkZ2V0SXNSID0gdGFibGUub3B0aW9ucy5nZXRJc1Jvd0V4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQocm93KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldElzUiA6IGV4cGFuZGVkID09PSB0cnVlIHx8IChleHBhbmRlZCA9PSBudWxsID8gdm9pZCAwIDogZXhwYW5kZWRbcm93LmlkXSkpO1xuICAgIH07XG4gICAgcm93LmdldENhbkV4cGFuZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRSb3csIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3JvdyRzdWJSb3dzO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRnZXRSb3cgPSB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRSb3dDYW5FeHBhbmQocm93KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldFJvdyA6ICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVFeHBhbmRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAhISgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBsZXQgaXNGdWxseUV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgIGxldCBjdXJyZW50Um93ID0gcm93O1xuICAgICAgd2hpbGUgKGlzRnVsbHlFeHBhbmRlZCAmJiBjdXJyZW50Um93LnBhcmVudElkKSB7XG4gICAgICAgIGN1cnJlbnRSb3cgPSB0YWJsZS5nZXRSb3coY3VycmVudFJvdy5wYXJlbnRJZCwgdHJ1ZSk7XG4gICAgICAgIGlzRnVsbHlFeHBhbmRlZCA9IGN1cnJlbnRSb3cuZ2V0SXNFeHBhbmRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVsbHlFeHBhbmRlZDtcbiAgICB9O1xuICAgIHJvdy5nZXRUb2dnbGVFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5FeHBhbmQgPSByb3cuZ2V0Q2FuRXhwYW5kKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkV4cGFuZCkgcmV0dXJuO1xuICAgICAgICByb3cudG9nZ2xlRXhwYW5kZWQoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgaW5jbHVkZXNTdHJpbmcgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWU7XG4gIGNvbnN0IHNlYXJjaCA9IGZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBCb29sZWFuKChfcm93JGdldFZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9TdHJpbmcoKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9Mb3dlckNhc2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUuaW5jbHVkZXMoc2VhcmNoKSk7XG59O1xuaW5jbHVkZXNTdHJpbmcuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTI7XG4gIHJldHVybiBCb29sZWFuKChfcm93JGdldFZhbHVlMiA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUyID0gX3JvdyRnZXRWYWx1ZTIudG9TdHJpbmcoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUyLmluY2x1ZGVzKGZpbHRlclZhbHVlKSk7XG59O1xuaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBlcXVhbHNTdHJpbmcgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWUzO1xuICByZXR1cm4gKChfcm93JGdldFZhbHVlMyA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUzID0gX3JvdyRnZXRWYWx1ZTMudG9TdHJpbmcoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUzLnRvTG93ZXJDYXNlKCkpID09PSAoZmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCkpO1xufTtcbmVxdWFsc1N0cmluZy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGFyckluY2x1ZGVzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlNDtcbiAgcmV0dXJuIChfcm93JGdldFZhbHVlNCA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNC5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSk7XG59O1xuYXJySW5jbHVkZXMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGFyckluY2x1ZGVzQWxsID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiAhZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xuICAgIHZhciBfcm93JGdldFZhbHVlNTtcbiAgICByZXR1cm4gISgoX3JvdyRnZXRWYWx1ZTUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsICYmIF9yb3ckZ2V0VmFsdWU1LmluY2x1ZGVzKHZhbCkpO1xuICB9KTtcbn07XG5hcnJJbmNsdWRlc0FsbC5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgYXJySW5jbHVkZXNTb21lID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiBmaWx0ZXJWYWx1ZS5zb21lKHZhbCA9PiB7XG4gICAgdmFyIF9yb3ckZ2V0VmFsdWU2O1xuICAgIHJldHVybiAoX3JvdyRnZXRWYWx1ZTYgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTYuaW5jbHVkZXModmFsKTtcbiAgfSk7XG59O1xuYXJySW5jbHVkZXNTb21lLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBlcXVhbHMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkgPT09IGZpbHRlclZhbHVlO1xufTtcbmVxdWFscy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IHdlYWtFcXVhbHMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkgPT0gZmlsdGVyVmFsdWU7XG59O1xud2Vha0VxdWFscy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGluTnVtYmVyUmFuZ2UgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgbGV0IFttaW4sIG1heF0gPSBmaWx0ZXJWYWx1ZTtcbiAgY29uc3Qgcm93VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICByZXR1cm4gcm93VmFsdWUgPj0gbWluICYmIHJvd1ZhbHVlIDw9IG1heDtcbn07XG5pbk51bWJlclJhbmdlLnJlc29sdmVGaWx0ZXJWYWx1ZSA9IHZhbCA9PiB7XG4gIGxldCBbdW5zYWZlTWluLCB1bnNhZmVNYXhdID0gdmFsO1xuICBsZXQgcGFyc2VkTWluID0gdHlwZW9mIHVuc2FmZU1pbiAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1pbikgOiB1bnNhZmVNaW47XG4gIGxldCBwYXJzZWRNYXggPSB0eXBlb2YgdW5zYWZlTWF4ICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodW5zYWZlTWF4KSA6IHVuc2FmZU1heDtcbiAgbGV0IG1pbiA9IHVuc2FmZU1pbiA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocGFyc2VkTWluKSA/IC1JbmZpbml0eSA6IHBhcnNlZE1pbjtcbiAgbGV0IG1heCA9IHVuc2FmZU1heCA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocGFyc2VkTWF4KSA/IEluZmluaXR5IDogcGFyc2VkTWF4O1xuICBpZiAobWluID4gbWF4KSB7XG4gICAgY29uc3QgdGVtcCA9IG1pbjtcbiAgICBtaW4gPSBtYXg7XG4gICAgbWF4ID0gdGVtcDtcbiAgfVxuICByZXR1cm4gW21pbiwgbWF4XTtcbn07XG5pbk51bWJlclJhbmdlLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8IHRlc3RGYWxzZXkodmFsWzBdKSAmJiB0ZXN0RmFsc2V5KHZhbFsxXSk7XG5cbi8vIEV4cG9ydFxuXG5jb25zdCBmaWx0ZXJGbnMgPSB7XG4gIGluY2x1ZGVzU3RyaW5nLFxuICBpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSxcbiAgZXF1YWxzU3RyaW5nLFxuICBhcnJJbmNsdWRlcyxcbiAgYXJySW5jbHVkZXNBbGwsXG4gIGFyckluY2x1ZGVzU29tZSxcbiAgZXF1YWxzLFxuICB3ZWFrRXF1YWxzLFxuICBpbk51bWJlclJhbmdlXG59O1xuLy8gVXRpbHNcblxuZnVuY3Rpb24gdGVzdEZhbHNleSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09ICcnO1xufVxuXG4vL1xuXG5jb25zdCBGaWx0ZXJzID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbHRlckZuOiAnYXV0bydcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uRmlsdGVyczogW10sXG4gICAgICBnbG9iYWxGaWx0ZXI6IHVuZGVmaW5lZCxcbiAgICAgIC8vIGZpbHRlcnNQcm9ncmVzczogMSxcbiAgICAgIC8vIGZhY2V0UHJvZ3Jlc3M6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtbkZpbHRlcnNDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtbkZpbHRlcnMnLCB0YWJsZSksXG4gICAgICBvbkdsb2JhbEZpbHRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ2xvYmFsRmlsdGVyJywgdGFibGUpLFxuICAgICAgZmlsdGVyRnJvbUxlYWZSb3dzOiBmYWxzZSxcbiAgICAgIG1heExlYWZSb3dGaWx0ZXJEZXB0aDogMTAwLFxuICAgICAgZ2xvYmFsRmlsdGVyRm46ICdhdXRvJyxcbiAgICAgIGdldENvbHVtbkNhbkdsb2JhbEZpbHRlcjogY29sdW1uID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRnZXRDb3JlUm93TW9kZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF0pID09IG51bGwgfHwgKF90YWJsZSRnZXRDb3JlUm93TW9kZSA9IF90YWJsZSRnZXRDb3JlUm93TW9kZS5fZ2V0QWxsQ2VsbHNCeUNvbHVtbklkKClbY29sdW1uLmlkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb3JlUm93TW9kZS5nZXRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5pbk51bWJlclJhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5hcnJJbmNsdWRlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWx0ZXJGbnMud2Vha0VxdWFscztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gOiBjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuKCkgOiAvLyBAdHMtaWdub3JlXG4gICAgICAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyID0gKF90YWJsZSRvcHRpb25zJGZpbHRlcjIgPSB0YWJsZS5vcHRpb25zLmZpbHRlckZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGZpbHRlcjJbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIgOiBmaWx0ZXJGbnNbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVDb2x1bW5GaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkdsb2JhbEZpbHRlciA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEyLCBfdGFibGUkb3B0aW9ucyRlbmFibGUzLCBfdGFibGUkb3B0aW9ucyRlbmFibGU0LCBfdGFibGUkb3B0aW9ucyRnZXRDb2w7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEyID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVHbG9iYWxGaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEyIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUzID0gdGFibGUub3B0aW9ucy5lbmFibGVHbG9iYWxGaWx0ZXIpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGU0ID0gdGFibGUub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZ2V0Q29sID0gdGFibGUub3B0aW9ucy5nZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyKGNvbHVtbikpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRDb2wgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzRmlsdGVyZWQgPSAoKSA9PiBjb2x1bW4uZ2V0RmlsdGVySW5kZXgoKSA+IC0xO1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW07XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCB8fCAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtLnZhbHVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIsIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMyA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMob2xkID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNmaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgY29uc3QgbmV3RmlsdGVyID0gZnVuY3Rpb25hbFVwZGF0ZSh2YWx1ZSwgcHJldmlvdXNmaWx0ZXIgPyBwcmV2aW91c2ZpbHRlci52YWx1ZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIG5ld0ZpbHRlciwgY29sdW1uKSkge1xuICAgICAgICAgIHZhciBfb2xkJGZpbHRlcjtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkZmlsdGVyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF9vbGQkZmlsdGVyIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RmlsdGVyT2JqID0ge1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgdmFsdWU6IG5ld0ZpbHRlclxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJldmlvdXNmaWx0ZXIpIHtcbiAgICAgICAgICB2YXIgX29sZCRtYXA7XG4gICAgICAgICAgcmV0dXJuIChfb2xkJG1hcCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0ZpbHRlck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pKSAhPSBudWxsID8gX29sZCRtYXAgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbLi4ub2xkLCBuZXdGaWx0ZXJPYmpdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3RmlsdGVyT2JqXTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gICAgLy8gKCkgPT4gW2NvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwoKV0sXG4gICAgLy8gZmFjZXRlZFJvd01vZGVsID0+IGdldFJvd01vZGVsTWluTWF4VmFsdWVzKGZhY2V0ZWRSb3dNb2RlbCwgY29sdW1uLmlkKSxcbiAgfSxcblxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICByb3cuY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgIH07XG4gICAgdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMywgX3RhYmxlJG9wdGlvbnMkZmlsdGVyNDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZ2xvYmFsRmlsdGVyRm46IGdsb2JhbEZpbHRlckZuXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGdsb2JhbEZpbHRlckZuKSA/IGdsb2JhbEZpbHRlckZuIDogZ2xvYmFsRmlsdGVyRm4gPT09ICdhdXRvJyA/IHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbigpIDogLy8gQHRzLWlnbm9yZVxuICAgICAgKF90YWJsZSRvcHRpb25zJGZpbHRlcjMgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyNCA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyNFtnbG9iYWxGaWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIzIDogZmlsdGVyRm5zW2dsb2JhbEZpbHRlckZuXTtcbiAgICB9O1xuICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMgPSB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZUZuID0gb2xkID0+IHtcbiAgICAgICAgdmFyIF9mdW5jdGlvbmFsVXBkYXRlO1xuICAgICAgICByZXR1cm4gKF9mdW5jdGlvbmFsVXBkYXRlID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQpKSA9PSBudWxsID8gdm9pZCAwIDogX2Z1bmN0aW9uYWxVcGRhdGUuZmlsdGVyKGZpbHRlciA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGZpbHRlci5pZCk7XG4gICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCBmaWx0ZXIudmFsdWUsIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGFibGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSh1cGRhdGVGbik7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIgPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRHbG9iYWxGaWx0ZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyKGRlZmF1bHRTdGF0ZSA/IHVuZGVmaW5lZCA6IHRhYmxlLmluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRDb2x1bW5GaWx0ZXJzID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCB2YWx1ZSwgY29sdW1uKSB7XG4gIHJldHVybiAoZmlsdGVyRm4gJiYgZmlsdGVyRm4uYXV0b1JlbW92ZSA/IGZpbHRlckZuLmF1dG9SZW1vdmUodmFsdWUsIGNvbHVtbikgOiBmYWxzZSkgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZTtcbn1cblxuY29uc3Qgc3VtID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICAvLyBJdCdzIGZhc3RlciB0byBqdXN0IGFkZCB0aGUgYWdncmVnYXRpb25zIHRvZ2V0aGVyIGluc3RlYWQgb2ZcbiAgLy8gcHJvY2VzcyBsZWFmIG5vZGVzIGluZGl2aWR1YWxseVxuICByZXR1cm4gY2hpbGRSb3dzLnJlZHVjZSgoc3VtLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dC5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgcmV0dXJuIHN1bSArICh0eXBlb2YgbmV4dFZhbHVlID09PSAnbnVtYmVyJyA/IG5leHRWYWx1ZSA6IDApO1xuICB9LCAwKTtcbn07XG5jb25zdCBtaW4gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW47XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtaW4gPiB2YWx1ZSB8fCBtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpIHtcbiAgICAgIG1pbiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW47XG59O1xuY29uc3QgbWF4ID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWF4O1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWF4IDwgdmFsdWUgfHwgbWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XG4gICAgICBtYXggPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF4O1xufTtcbmNvbnN0IGV4dGVudCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW21pbiwgbWF4XTtcbn07XG5jb25zdCBtZWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3VtID0gMDtcbiAgbGVhZlJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGxldCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChjb3VudCkgcmV0dXJuIHN1bSAvIGNvdW50O1xuICByZXR1cm47XG59O1xuY29uc3QgbWVkaWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBpZiAoIWxlYWZSb3dzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBsZWFmUm93cy5tYXAocm93ID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpO1xuICBpZiAoIWlzTnVtYmVyQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH1cbiAgY29uc3QgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gIGNvbnN0IG51bXMgPSB2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICByZXR1cm4gdmFsdWVzLmxlbmd0aCAlIDIgIT09IDAgPyBudW1zW21pZF0gOiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xufTtcbmNvbnN0IHVuaXF1ZSA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnZhbHVlcygpKTtcbn07XG5jb25zdCB1bmlxdWVDb3VudCA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS5zaXplO1xufTtcbmNvbnN0IGNvdW50ID0gKF9jb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIGxlYWZSb3dzLmxlbmd0aDtcbn07XG5jb25zdCBhZ2dyZWdhdGlvbkZucyA9IHtcbiAgc3VtLFxuICBtaW4sXG4gIG1heCxcbiAgZXh0ZW50LFxuICBtZWFuLFxuICBtZWRpYW4sXG4gIHVuaXF1ZSxcbiAgdW5pcXVlQ291bnQsXG4gIGNvdW50XG59O1xuXG4vL1xuXG5jb25zdCBHcm91cGluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhZ2dyZWdhdGVkQ2VsbDogcHJvcHMgPT4ge1xuICAgICAgICB2YXIgX3RvU3RyaW5nLCBfcHJvcHMkZ2V0VmFsdWU7XG4gICAgICAgIHJldHVybiAoX3RvU3RyaW5nID0gKF9wcm9wcyRnZXRWYWx1ZSA9IHByb3BzLmdldFZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ2V0VmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF90b1N0cmluZyA6IG51bGw7XG4gICAgICB9LFxuICAgICAgYWdncmVnYXRpb25GbjogJ2F1dG8nXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdyb3VwaW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Hcm91cGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ3JvdXBpbmcnLCB0YWJsZSksXG4gICAgICBncm91cGVkQ29sdW1uTW9kZTogJ3Jlb3JkZXInXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVHcm91cGluZyA9ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIGdyb3VwaW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmluY2x1ZGVzKGNvbHVtbi5pZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi4ob2xkICE9IG51bGwgPyBvbGQgOiBbXSksIGNvbHVtbi5pZF07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5Hcm91cCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMiwgX3JlZjMsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTtcbiAgICAgIHJldHVybiAoX3JlZiA9IChfcmVmMiA9IChfcmVmMyA9IChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgIT0gbnVsbCA/IF9yZWYzIDogdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZykgIT0gbnVsbCA/IF9yZWYyIDogdHJ1ZSkgIT0gbnVsbCA/IF9yZWYgOiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzR3JvdXBlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXA7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRncm91cCA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRHcm91cGVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwMiA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyLmluZGV4T2YoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Hcm91cCA9IGNvbHVtbi5nZXRDYW5Hcm91cCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5Hcm91cCkgcmV0dXJuO1xuICAgICAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5zdW07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5leHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRhZ2dyZWcsIF90YWJsZSRvcHRpb25zJGFnZ3JlZzI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbikgPyBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gOiBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbigpIDogKF90YWJsZSRvcHRpb25zJGFnZ3JlZyA9IChfdGFibGUkb3B0aW9ucyRhZ2dyZWcyID0gdGFibGUub3B0aW9ucy5hZ2dyZWdhdGlvbkZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGFnZ3JlZzJbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGFnZ3JlZyA6IGFnZ3JlZ2F0aW9uRm5zW2NvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRHcm91cGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkdyb3VwaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRHcm91cGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRnLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRnID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmdyb3VwaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRnIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRHcm91cGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsR3JvdXBpbmcgfHwgIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmdldElzR3JvdXBlZCA9ICgpID0+ICEhcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgcm93LmdldEdyb3VwaW5nVmFsdWUgPSBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgICAgfVxuICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZShyb3cub3JpZ2luYWwpO1xuICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfTtcbiAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUgPSB7fTtcbiAgfSxcbiAgY3JlYXRlQ2VsbDogKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSkgPT4ge1xuICAgIGNlbGwuZ2V0SXNHcm91cGVkID0gKCkgPT4gY29sdW1uLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5pZCA9PT0gcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgY2VsbC5nZXRJc1BsYWNlaG9sZGVyID0gKCkgPT4gIWNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmdldElzR3JvdXBlZCgpO1xuICAgIGNlbGwuZ2V0SXNBZ2dyZWdhdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc1BsYWNlaG9sZGVyKCkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkge1xuICBpZiAoIShncm91cGluZyAhPSBudWxsICYmIGdyb3VwaW5nLmxlbmd0aCkgfHwgIWdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gICAgcmV0dXJuIGxlYWZDb2x1bW5zO1xuICB9XG4gIGNvbnN0IG5vbkdyb3VwaW5nQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2wgPT4gIWdyb3VwaW5nLmluY2x1ZGVzKGNvbC5pZCkpO1xuICBpZiAoZ3JvdXBlZENvbHVtbk1vZGUgPT09ICdyZW1vdmUnKSB7XG4gICAgcmV0dXJuIG5vbkdyb3VwaW5nQ29sdW1ucztcbiAgfVxuICBjb25zdCBncm91cGluZ0NvbHVtbnMgPSBncm91cGluZy5tYXAoZyA9PiBsZWFmQ29sdW1ucy5maW5kKGNvbCA9PiBjb2wuaWQgPT09IGcpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbLi4uZ3JvdXBpbmdDb2x1bW5zLCAuLi5ub25Hcm91cGluZ0NvbHVtbnNdO1xufVxuXG4vL1xuXG5jb25zdCBPcmRlcmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbk9yZGVyOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5PcmRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uT3JkZXInLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtbk9yZGVyID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtbk9yZGVyID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5PcmRlcihkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uT3JkZXIpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4gPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbk9yZGVyLCB0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5vcHRpb25zLmdyb3VwZWRDb2x1bW5Nb2RlXSwgKGNvbHVtbk9yZGVyLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpID0+IGNvbHVtbnMgPT4ge1xuICAgICAgLy8gU29ydCBncm91cGVkIGNvbHVtbnMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW4gbGlzdFxuICAgICAgLy8gYmVmb3JlIHRoZSBoZWFkZXJzIGFyZSBidWlsdFxuICAgICAgbGV0IG9yZGVyZWRDb2x1bW5zID0gW107XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG9yZGVyLCByZXR1cm4gdGhlIG5vcm1hbCBjb2x1bW5zXG4gICAgICBpZiAoIShjb2x1bW5PcmRlciAhPSBudWxsICYmIGNvbHVtbk9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sdW1uT3JkZXJDb3B5ID0gWy4uLmNvbHVtbk9yZGVyXTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmRlciwgbWFrZSBhIGNvcHkgb2YgdGhlIGNvbHVtbnNcbiAgICAgICAgY29uc3QgY29sdW1uc0NvcHkgPSBbLi4uY29sdW1uc107XG5cbiAgICAgICAgLy8gQW5kIG1ha2UgYSBuZXcgb3JkZXJlZCBhcnJheSBvZiB0aGUgY29sdW1uc1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgY29sdW1ucyBhbmQgcGxhY2UgdGhlbSBpbiBvcmRlciBpbnRvIHRoZSBuZXcgYXJyYXlcbiAgICAgICAgd2hpbGUgKGNvbHVtbnNDb3B5Lmxlbmd0aCAmJiBjb2x1bW5PcmRlckNvcHkubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uSWQgPSBjb2x1bW5PcmRlckNvcHkuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZEluZGV4ID0gY29sdW1uc0NvcHkuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gdGFyZ2V0Q29sdW1uSWQpO1xuICAgICAgICAgIGlmIChmb3VuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIG9yZGVyZWRDb2x1bW5zLnB1c2goY29sdW1uc0NvcHkuc3BsaWNlKGZvdW5kSW5kZXgsIDEpWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IFsuLi5vcmRlcmVkQ29sdW1ucywgLi4uY29sdW1uc0NvcHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhvcmRlcmVkQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRPcmRlckNvbHVtbnNGbidcbiAgICAgIC8vIGRlYnVnOiAoKSA9PiB0YWJsZS5vcHRpb25zLmRlYnVnQWxsID8/IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZSxcbiAgICB9KTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgZGVmYXVsdFBhZ2VJbmRleCA9IDA7XG5jb25zdCBkZWZhdWx0UGFnZVNpemUgPSAxMDtcbmNvbnN0IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUgPSAoKSA9PiAoe1xuICBwYWdlSW5kZXg6IGRlZmF1bHRQYWdlSW5kZXgsXG4gIHBhZ2VTaXplOiBkZWZhdWx0UGFnZVNpemVcbn0pO1xuY29uc3QgUGFnaW5hdGlvbiA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAuLi5nZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCksXG4gICAgICAgIC4uLihzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUucGFnaW5hdGlvbilcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblBhZ2luYXRpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3BhZ2luYXRpb24nLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGxldCByZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgbGV0IHF1ZXVlZCA9IGZhbHNlO1xuICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJG9wdGlvbnMkYXV0b1JlO1xuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkYXV0b1JlID0gdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhdXRvUmUgOiB0YWJsZS5vcHRpb25zLmF1dG9SZXNldFBhZ2VJbmRleCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uKSB7XG4gICAgICAgIGlmIChxdWV1ZWQpIHJldHVybjtcbiAgICAgICAgcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICB0YWJsZS5yZXNldFBhZ2VJbmRleCgpO1xuICAgICAgICAgIHF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2luYXRpb24gPSB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IHNhZmVVcGRhdGVyID0gb2xkID0+IHtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQpO1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUGFnaW5hdGlvbkNoYW5nZShzYWZlVXBkYXRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2luYXRpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24oZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcCA9IHRhYmxlLmluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwIDogZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2VJbmRleCA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBsZXQgcGFnZUluZGV4ID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQucGFnZUluZGV4KTtcbiAgICAgICAgY29uc3QgbWF4UGFnZUluZGV4ID0gdHlwZW9mIHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAndW5kZWZpbmVkJyB8fCB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCA9PT0gLTEgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50IC0gMTtcbiAgICAgICAgcGFnZUluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUluZGV4LCBtYXhQYWdlSW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHAyLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0UGFnZUluZGV4KGRlZmF1bHRTdGF0ZSA/IGRlZmF1bHRQYWdlSW5kZXggOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChfdGFibGUkaW5pdGlhbFN0YXRlID0gX3RhYmxlJGluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5wYWdlSW5kZXgpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAyIDogZGVmYXVsdFBhZ2VJbmRleCk7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2VTaXplID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHAzLCBfdGFibGUkaW5pdGlhbFN0YXRlMjtcbiAgICAgIHRhYmxlLnNldFBhZ2VTaXplKGRlZmF1bHRTdGF0ZSA/IGRlZmF1bHRQYWdlU2l6ZSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAzID0gKF90YWJsZSRpbml0aWFsU3RhdGUyID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlMi5wYWdlU2l6ZSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDMgOiBkZWZhdWx0UGFnZVNpemUpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZVNpemUgPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgICAgY29uc3QgcGFnZVNpemUgPSBNYXRoLm1heCgxLCBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlU2l6ZSkpO1xuICAgICAgICBjb25zdCB0b3BSb3dJbmRleCA9IG9sZC5wYWdlU2l6ZSAqIG9sZC5wYWdlSW5kZXg7XG4gICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IE1hdGguZmxvb3IodG9wUm93SW5kZXggLyBwYWdlU2l6ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICBwYWdlU2l6ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlQ291bnQgPSB1cGRhdGVyID0+IHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRwYWdlQ287XG4gICAgICBsZXQgbmV3UGFnZUNvdW50ID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCAoX3RhYmxlJG9wdGlvbnMkcGFnZUNvID0gdGFibGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRwYWdlQ28gOiAtMSk7XG4gICAgICBpZiAodHlwZW9mIG5ld1BhZ2VDb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbmV3UGFnZUNvdW50ID0gTWF0aC5tYXgoLTEsIG5ld1BhZ2VDb3VudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIHBhZ2VDb3VudDogbmV3UGFnZUNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRhYmxlLmdldFBhZ2VPcHRpb25zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UGFnZUNvdW50KCldLCBwYWdlQ291bnQgPT4ge1xuICAgICAgbGV0IHBhZ2VPcHRpb25zID0gW107XG4gICAgICBpZiAocGFnZUNvdW50ICYmIHBhZ2VDb3VudCA+IDApIHtcbiAgICAgICAgcGFnZU9wdGlvbnMgPSBbLi4ubmV3IEFycmF5KHBhZ2VDb3VudCldLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlT3B0aW9ucztcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRQYWdlT3B0aW9ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0Q2FuUHJldmlvdXNQYWdlID0gKCkgPT4gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VJbmRleCA+IDA7XG4gICAgdGFibGUuZ2V0Q2FuTmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VJbmRleFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbjtcbiAgICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRhYmxlLmdldFBhZ2VDb3VudCgpO1xuICAgICAgaWYgKHBhZ2VDb3VudCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlSW5kZXggPCBwYWdlQ291bnQgLSAxO1xuICAgIH07XG4gICAgdGFibGUucHJldmlvdXNQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4gb2xkIC0gMSk7XG4gICAgfTtcbiAgICB0YWJsZS5uZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IHtcbiAgICAgICAgcmV0dXJuIG9sZCArIDE7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24gfHwgIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFBhZ2VDb3VudCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRwYWdlQ28yO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRwYWdlQ28yID0gdGFibGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRwYWdlQ28yIDogTWF0aC5jZWlsKHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoIC8gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VTaXplKTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlID0gKCkgPT4gKHtcbiAgbGVmdDogW10sXG4gIHJpZ2h0OiBbXVxufSk7XG5jb25zdCBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlID0gKCkgPT4gKHtcbiAgdG9wOiBbXSxcbiAgYm90dG9tOiBbXVxufSk7XG5jb25zdCBQaW5uaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUGlubmluZzogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpLFxuICAgICAgcm93UGlubmluZzogZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblBpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblBpbm5pbmcnLCB0YWJsZSksXG4gICAgICBvblJvd1Bpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1Bpbm5pbmcnLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnBpbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkbGVmdDMsIF9vbGQkcmlnaHQzO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0LCBfb2xkJHJpZ2h0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAoKF9vbGQkbGVmdCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBbLi4uKChfb2xkJHJpZ2h0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksIC4uLmNvbHVtbklkc11cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbGVmdDIsIF9vbGQkcmlnaHQyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBbLi4uKChfb2xkJGxlZnQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDIgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXSxcbiAgICAgICAgICAgIHJpZ2h0OiAoKF9vbGQkcmlnaHQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksXG4gICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCk7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMuc29tZShkID0+IHtcbiAgICAgICAgdmFyIF9kJGNvbHVtbkRlZiRlbmFibGVQaSwgX3JlZiwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgICByZXR1cm4gKChfZCRjb2x1bW5EZWYkZW5hYmxlUGkgPSBkLmNvbHVtbkRlZi5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX2QkY29sdW1uRGVmJGVuYWJsZVBpIDogdHJ1ZSkgJiYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWYgOiB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGNvbnN0IGlzTGVmdCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQuaW5jbHVkZXMoZCkpO1xuICAgICAgY29uc3QgaXNSaWdodCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNMZWZ0ID8gJ2xlZnQnIDogaXNSaWdodCA/ICdyaWdodCcgOiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0sIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTI7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGNvbHVtbi5nZXRJc1Bpbm5lZCgpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtMltwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLmluZGV4T2YoY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA6IC0xIDogMDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnBpbiA9IChwb3NpdGlvbiwgaW5jbHVkZUxlYWZSb3dzLCBpbmNsdWRlUGFyZW50Um93cykgPT4ge1xuICAgICAgY29uc3QgbGVhZlJvd0lkcyA9IGluY2x1ZGVMZWFmUm93cyA/IHJvdy5nZXRMZWFmUm93cygpLm1hcChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3QgcGFyZW50Um93SWRzID0gaW5jbHVkZVBhcmVudFJvd3MgPyByb3cuZ2V0UGFyZW50Um93cygpLm1hcChfcmVmMyA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3Qgcm93SWRzID0gbmV3IFNldChbLi4ucGFyZW50Um93SWRzLCByb3cuaWQsIC4uLmxlYWZSb3dJZHNdKTtcbiAgICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkdG9wMywgX29sZCRib3R0b20zO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdmFyIF9vbGQkdG9wLCBfb2xkJGJvdHRvbTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiAoKF9vbGQkdG9wID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgICBib3R0b206IFsuLi4oKF9vbGQkYm90dG9tID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20gOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AyLCBfb2xkJGJvdHRvbTI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogWy4uLigoX29sZCR0b3AyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AyIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLCAuLi5BcnJheS5mcm9tKHJvd0lkcyldLFxuICAgICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMiA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6ICgoX29sZCR0b3AzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AzIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLFxuICAgICAgICAgIGJvdHRvbTogKChfb2xkJGJvdHRvbTMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbTMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmNDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5hYmxlUm93UGlubmluZyxcbiAgICAgICAgZW5hYmxlUGlubmluZ1xuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIGVuYWJsZVJvd1Bpbm5pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZVJvd1Bpbm5pbmcocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3JlZjQgPSBlbmFibGVSb3dQaW5uaW5nICE9IG51bGwgPyBlbmFibGVSb3dQaW5uaW5nIDogZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWY0IDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IFtyb3cuaWRdO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbVxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZztcbiAgICAgIGNvbnN0IGlzVG9wID0gcm93SWRzLnNvbWUoZCA9PiB0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHRvcC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc0JvdHRvbSA9IHJvd0lkcy5zb21lKGQgPT4gYm90dG9tID09IG51bGwgPyB2b2lkIDAgOiBib3R0b20uaW5jbHVkZXMoZCkpO1xuICAgICAgcmV0dXJuIGlzVG9wID8gJ3RvcCcgOiBpc0JvdHRvbSA/ICdib3R0b20nIDogZmFsc2U7XG4gICAgfTtcbiAgICByb3cuZ2V0UGlubmVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJF9nZXRQaW5uZWRSb3dzLCBfdmlzaWJsZVBpbm5lZFJvd0lkcyQ7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJvdy5nZXRJc1Bpbm5lZCgpO1xuICAgICAgaWYgKCFwb3NpdGlvbikgcmV0dXJuIC0xO1xuICAgICAgY29uc3QgdmlzaWJsZVBpbm5lZFJvd0lkcyA9IChfdGFibGUkX2dldFBpbm5lZFJvd3MgPSB0YWJsZS5fZ2V0UGlubmVkUm93cyhwb3NpdGlvbikpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkX2dldFBpbm5lZFJvd3MubWFwKF9yZWY1ID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjU7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChfdmlzaWJsZVBpbm5lZFJvd0lkcyQgPSB2aXNpYmxlUGlubmVkUm93SWRzID09IG51bGwgPyB2b2lkIDAgOiB2aXNpYmxlUGlubmVkUm93SWRzLmluZGV4T2Yocm93LmlkKSkgIT0gbnVsbCA/IF92aXNpYmxlUGlubmVkUm93SWRzJCA6IC0xO1xuICAgIH07XG4gICAgcm93LmdldENlbnRlclZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBsZWZ0QW5kUmlnaHQgPSBbLi4uKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSksIC4uLihyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSldO1xuICAgICAgcmV0dXJuIGFsbENlbGxzLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5jb2x1bW4uaWQpKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsLF0sIChhbGxDZWxscywgbGVmdCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAobGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvbjogJ2xlZnQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldExlZnRWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENlbGxzLCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uUGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblBpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuY29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbztcbiAgICAgIGNvbnN0IHBpbm5pbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9waW5uaW5nU3RhdGUkbGVmdCwgX3Bpbm5pbmdTdGF0ZSRyaWdodDtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKChfcGlubmluZ1N0YXRlJGxlZnQgPSBwaW5uaW5nU3RhdGUubGVmdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkbGVmdC5sZW5ndGgpIHx8ICgoX3Bpbm5pbmdTdGF0ZSRyaWdodCA9IHBpbm5pbmdTdGF0ZS5yaWdodCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcmlnaHQubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQm9vbGVhbigoX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpby5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgcmV0dXJuIChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVmdExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTQgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRMZWFmQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTUgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5maWx0ZXIoZCA9PiAhbGVmdEFuZFJpZ2h0LmluY2x1ZGVzKGQuaWQpKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJMZWFmQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTYgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5zZXRSb3dQaW5uaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblJvd1Bpbm5pbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dQaW5uaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHIsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1Bpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnJvd1Bpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1Bpbm5lZCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfcGlubmluZ1N0YXRlJHBvc2l0aW8yO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSR0b3AsIF9waW5uaW5nU3RhdGUkYm90dG9tO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkdG9wID0gcGlubmluZ1N0YXRlLnRvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkdG9wLmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJGJvdHRvbSA9IHBpbm5pbmdTdGF0ZS5ib3R0b20pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJGJvdHRvbS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8yID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpbzIubGVuZ3RoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRQaW5uZWRSb3dzID0gcG9zaXRpb24gPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmdbcG9zaXRpb25dXSwgKHZpc2libGVSb3dzLCBwaW5uZWRSb3dJZHMpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRrZWVwUGk7XG4gICAgICBjb25zdCByb3dzID0gKChfdGFibGUkb3B0aW9ucyRrZWVwUGkgPSB0YWJsZS5vcHRpb25zLmtlZXBQaW5uZWRSb3dzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMka2VlcFBpIDogdHJ1ZSkgP1xuICAgICAgLy9nZXQgYWxsIHJvd3MgdGhhdCBhcmUgcGlubmVkIGV2ZW4gaWYgdGhleSB3b3VsZCBub3QgYmUgb3RoZXJ3aXNlIHZpc2libGVcbiAgICAgIC8vYWNjb3VudCBmb3IgZXhwYW5kZWQgcGFyZW50IHJvd3MsIGJ1dCBub3QgcGFnaW5hdGlvbiBvciBmaWx0ZXJpbmdcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkKCkgPyByb3cgOiBudWxsO1xuICAgICAgfSkgOlxuICAgICAgLy9lbHNlIGdldCBvbmx5IHZpc2libGUgcm93cyB0aGF0IGFyZSBwaW5uZWRcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4gdmlzaWJsZVJvd3MuZmluZChyb3cgPT4gcm93LmlkID09PSByb3dJZCkpO1xuICAgICAgcmV0dXJuIHJvd3MuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICB9KSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBgcm93LmdldCR7cG9zaXRpb24gPT09ICd0b3AnID8gJ1RvcCcgOiAnQm90dG9tJ31Sb3dzYCxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTcgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNyA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgdGFibGUuZ2V0VG9wUm93cyA9ICgpID0+IHRhYmxlLl9nZXRQaW5uZWRSb3dzKCd0b3AnKTtcbiAgICB0YWJsZS5nZXRCb3R0b21Sb3dzID0gKCkgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoJ2JvdHRvbScpO1xuICAgIHRhYmxlLmdldENlbnRlclJvd3MgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy50b3AsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b21dLCAoYWxsUm93cywgdG9wLCBib3R0b20pID0+IHtcbiAgICAgIGNvbnN0IHRvcEFuZEJvdHRvbSA9IG5ldyBTZXQoWy4uLih0b3AgIT0gbnVsbCA/IHRvcCA6IFtdKSwgLi4uKGJvdHRvbSAhPSBudWxsID8gYm90dG9tIDogW10pXSk7XG4gICAgICByZXR1cm4gYWxsUm93cy5maWx0ZXIoZCA9PiAhdG9wQW5kQm90dG9tLmhhcyhkLmlkKSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldENlbnRlclJvd3MnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTg7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBOCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4IDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFJvd1NlbGVjdGlvbiA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd1NlbGVjdGlvbjoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdyb3dTZWxlY3Rpb24nLCB0YWJsZSksXG4gICAgICBlbmFibGVSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZVN1YlJvd1NlbGVjdGlvbjogdHJ1ZVxuICAgICAgLy8gZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgLy8gaXNBZGRpdGl2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLm1ldGFLZXksXG4gICAgICAvLyBpc0luY2x1c2l2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLnNoaWZ0S2V5LFxuICAgIH07XG4gIH0sXG5cbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24gPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dTZWxlY3Rpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcjtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gdGFibGUuaW5pdGlhbFN0YXRlLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCgpO1xuICAgICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgLi4ub2xkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZUdyb3VwZWRGbGF0Um93cyA9IHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSBgbXV0YXRlUm93SXNTZWxlY3RlZGAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgLy8gQWxsIG9mIHRoZSByb3dzIGFyZSBmbGF0IGFscmVhZHksIHNvIGl0IHdvdWxkbid0IGJlIHdvcnRoIGl0XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAoIXJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dTZWxlY3Rpb25bcm93LmlkXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSByb3dTZWxlY3Rpb25bcm93LmlkXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93U2VsZWN0aW9uO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gdmFsdWUgPT4gdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpO1xuICAgICAgY29uc3Qgcm93U2VsZWN0aW9uID0ge1xuICAgICAgICAuLi5vbGRcbiAgICAgIH07XG4gICAgICB0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHJvd1NlbGVjdGlvbiwgcm93LmlkLCByZXNvbHZlZFZhbHVlLCB0cnVlLCB0YWJsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByb3dTZWxlY3Rpb247XG4gICAgfSk7XG5cbiAgICAvLyBhZGRSb3dTZWxlY3Rpb25SYW5nZTogcm93SWQgPT4ge1xuICAgIC8vICAgY29uc3Qge1xuICAgIC8vICAgICByb3dzLFxuICAgIC8vICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgb3B0aW9uczogeyBzZWxlY3RHcm91cGluZ1Jvd3MsIHNlbGVjdFN1YlJvd3MgfSxcbiAgICAvLyAgIH0gPSB0YWJsZVxuXG4gICAgLy8gICBjb25zdCBmaW5kU2VsZWN0ZWRSb3cgPSAocm93czogUm93W10pID0+IHtcbiAgICAvLyAgICAgbGV0IGZvdW5kXG4gICAgLy8gICAgIHJvd3MuZmluZChkID0+IHtcbiAgICAvLyAgICAgICBpZiAoZC5nZXRJc1NlbGVjdGVkKCkpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgY29uc3Qgc3ViRm91bmQgPSBmaW5kU2VsZWN0ZWRSb3coZC5zdWJSb3dzIHx8IFtdKVxuICAgIC8vICAgICAgIGlmIChzdWJGb3VuZCkge1xuICAgIC8vICAgICAgICAgZm91bmQgPSBzdWJGb3VuZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHJldHVybiBmb3VuZFxuICAgIC8vICAgfVxuXG4gICAgLy8gICBjb25zdCBmaXJzdFJvdyA9IGZpbmRTZWxlY3RlZFJvdyhyb3dzKSB8fCByb3dzWzBdXG4gICAgLy8gICBjb25zdCBsYXN0Um93ID0gcm93c0J5SWRbcm93SWRdXG5cbiAgICAvLyAgIGxldCBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge31cblxuICAgIC8vICAgY29uc3QgYWRkUm93ID0gKHJvdzogUm93KSA9PiB7XG4gICAgLy8gICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdHJ1ZSwge1xuICAgIC8vICAgICAgIHJvd3NCeUlkLFxuICAgIC8vICAgICAgIHNlbGVjdEdyb3VwaW5nUm93czogc2VsZWN0R3JvdXBpbmdSb3dzISxcbiAgICAvLyAgICAgICBzZWxlY3RTdWJSb3dzOiBzZWxlY3RTdWJSb3dzISxcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgIH1cblxuICAgIC8vICAgdGFibGUucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgLy8gICAgIGNvbnN0IGlzRmlyc3RSb3cgPSByb3cuaWQgPT09IGZpcnN0Um93LmlkXG4gICAgLy8gICAgIGNvbnN0IGlzTGFzdFJvdyA9IHJvdy5pZCA9PT0gbGFzdFJvdy5pZFxuXG4gICAgLy8gICAgIGlmIChpc0ZpcnN0Um93IHx8IGlzTGFzdFJvdykge1xuICAgIC8vICAgICAgIGlmICghaW5jbHVkZSkge1xuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IHRydWVcbiAgICAvLyAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZiAoaW5jbHVkZSkge1xuICAgIC8vICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0pXG5cbiAgICAvLyAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihzZWxlY3RlZFJvd0lkcylcbiAgICAvLyB9LFxuICAgIHRhYmxlLmdldFByZVNlbGVjdGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldENvcmVSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0U2VsZWN0ZWRSb3dNb2RlbCcsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAnZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCcsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMztcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTMgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLy9cblxuICAgIC8vIGdldEdyb3VwaW5nUm93Q2FuU2VsZWN0OiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQpXG5cbiAgICAvLyAgIGlmICghcm93KSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbihyb3cpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID8/IGZhbHNlXG4gICAgLy8gfSxcblxuICAgIHRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUm93c1NlbGVjdGVkID0gQm9vbGVhbihwcmVHcm91cGVkRmxhdFJvd3MubGVuZ3RoICYmIE9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKTtcbiAgICAgIGlmIChpc0FsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgICBpZiAocHJlR3JvdXBlZEZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSAmJiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pKSB7XG4gICAgICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWxsUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkZsYXRSb3dzID0gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICEhcGFnaW5hdGlvbkZsYXRSb3dzLmxlbmd0aDtcbiAgICAgIGlmIChpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgJiYgcGFnaW5hdGlvbkZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcbiAgICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBbGxQYWdlUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRyb3dTZTtcbiAgICAgIGNvbnN0IHRvdGFsU2VsZWN0ZWQgPSBPYmplY3Qua2V5cygoX3RhYmxlJGdldFN0YXRlJHJvd1NlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkcm93U2UgOiB7fSkubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRvdGFsU2VsZWN0ZWQgPiAwICYmIHRvdGFsU2VsZWN0ZWQgPCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3MubGVuZ3RoO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgcmV0dXJuIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpID8gZmFsc2UgOiBwYWdpbmF0aW9uRmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpLnNvbWUoZCA9PiBkLmdldElzU2VsZWN0ZWQoKSB8fCBkLmdldElzU29tZVNlbGVjdGVkKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnRvZ2dsZVNlbGVjdGVkID0gKHZhbHVlLCBvcHRzKSA9PiB7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gcm93LmdldElzU2VsZWN0ZWQoKTtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YXIgX29wdHMkc2VsZWN0Q2hpbGRyZW47XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIWlzU2VsZWN0ZWQ7XG4gICAgICAgIGlmIChyb3cuZ2V0Q2FuU2VsZWN0KCkgJiYgaXNTZWxlY3RlZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge1xuICAgICAgICAgIC4uLm9sZFxuICAgICAgICB9O1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHZhbHVlLCAoX29wdHMkc2VsZWN0Q2hpbGRyZW4gPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnNlbGVjdENoaWxkcmVuKSAhPSBudWxsID8gX29wdHMkc2VsZWN0Q2hpbGRyZW4gOiB0cnVlLCB0YWJsZSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFJvd0lkcztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbik7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNTb21lU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNTdWJSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbikgPT09ICdzb21lJztcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ2FsbCc7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5NdWx0aVNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuU2VsZWN0ID0gcm93LmdldENhblNlbGVjdCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgaWYgKCFjYW5TZWxlY3QpIHJldHVybjtcbiAgICAgICAgcm93LnRvZ2dsZVNlbGVjdGVkKChfdGFyZ2V0ID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgbXV0YXRlUm93SXNTZWxlY3RlZCA9IChzZWxlY3RlZFJvd0lkcywgaWQsIHZhbHVlLCBpbmNsdWRlQ2hpbGRyZW4sIHRhYmxlKSA9PiB7XG4gIHZhciBfcm93JHN1YlJvd3M7XG4gIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhpZCk7XG5cbiAgLy8gY29uc3QgaXNHcm91cGVkID0gcm93LmdldElzR3JvdXBlZCgpXG5cbiAgLy8gaWYgKCAvLyBUT0RPOiBlbmZvcmNlIGdyb3VwaW5nIHJvdyBzZWxlY3Rpb24gcnVsZXNcbiAgLy8gICAhaXNHcm91cGVkIHx8XG4gIC8vICAgKGlzR3JvdXBlZCAmJiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKVxuICAvLyApIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFyb3cuZ2V0Q2FuTXVsdGlTZWxlY3QoKSkge1xuICAgICAgT2JqZWN0LmtleXMoc2VsZWN0ZWRSb3dJZHMpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1trZXldKTtcbiAgICB9XG4gICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgc2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHNlbGVjdGVkUm93SWRzW2lkXTtcbiAgfVxuICAvLyB9XG5cbiAgaWYgKGluY2x1ZGVDaGlsZHJlbiAmJiAoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cygpKSB7XG4gICAgcm93LnN1YlJvd3MuZm9yRWFjaChyb3cgPT4gbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkpO1xuICB9XG59O1xuZnVuY3Rpb24gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCkge1xuICBjb25zdCByb3dTZWxlY3Rpb24gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbjtcbiAgY29uc3QgbmV3U2VsZWN0ZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdTZWxlY3RlZFJvd3NCeUlkID0ge307XG5cbiAgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG4gIGNvbnN0IHJlY3Vyc2VSb3dzID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzMjtcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIG5ld1NlbGVjdGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdTZWxlY3RlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICB9XG4gICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCkge1xuICAgICAgICByb3cgPSB7XG4gICAgICAgICAgLi4ucm93LFxuICAgICAgICAgIHN1YlJvd3M6IHJlY3Vyc2VSb3dzKHJvdy5zdWJSb3dzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH1cbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZVJvd3Mocm93TW9kZWwucm93cyksXG4gICAgZmxhdFJvd3M6IG5ld1NlbGVjdGVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld1NlbGVjdGVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24pIHtcbiAgdmFyIF9zZWxlY3Rpb24kcm93JGlkO1xuICByZXR1cm4gKF9zZWxlY3Rpb24kcm93JGlkID0gc2VsZWN0aW9uW3Jvdy5pZF0pICE9IG51bGwgPyBfc2VsZWN0aW9uJHJvdyRpZCA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTdWJSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbiwgdGFibGUpIHtcbiAgdmFyIF9yb3ckc3ViUm93czM7XG4gIGlmICghKChfcm93JHN1YlJvd3MzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMy5sZW5ndGgpKSByZXR1cm4gZmFsc2U7XG4gIGxldCBhbGxDaGlsZHJlblNlbGVjdGVkID0gdHJ1ZTtcbiAgbGV0IHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuICByb3cuc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgd2Uga25vdyBib3RoIG9mIHRoZXNlXG4gICAgaWYgKHNvbWVTZWxlY3RlZCAmJiAhYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3ViUm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBpZiAoaXNSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbikpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayByb3cgc2VsZWN0aW9uIG9mIG5lc3RlZCBzdWJyb3dzXG4gICAgaWYgKHN1YlJvdy5zdWJSb3dzICYmIHN1YlJvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9IGlzU3ViUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pO1xuICAgICAgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdhbGwnKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdzb21lJykge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFsbENoaWxkcmVuU2VsZWN0ZWQgPyAnYWxsJyA6IHNvbWVTZWxlY3RlZCA/ICdzb21lJyA6IGZhbHNlO1xufVxuXG5jb25zdCByZVNwbGl0QWxwaGFOdW1lcmljID0gLyhbMC05XSspL2dtO1xuY29uc3QgYWxwaGFudW1lcmljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSk7XG59O1xuY29uc3QgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XG59O1xuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHQgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xufTtcblxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXG5jb25zdCB0ZXh0Q2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpKTtcbn07XG5jb25zdCBkYXRldGltZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICBjb25zdCBhID0gcm93QS5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gIGNvbnN0IGIgPSByb3dCLmdldFZhbHVlKGNvbHVtbklkKTtcblxuICAvLyBDYW4gaGFuZGxlIG51bGxpc2ggdmFsdWVzXG4gIC8vIFVzZSA+IGFuZCA8IGJlY2F1c2UgPT0gKGFuZCA9PT0pIGRvZXNuJ3Qgd29yayB3aXRoXG4gIC8vIERhdGUgb2JqZWN0cyAod291bGQgcmVxdWlyZSBjYWxsaW5nIGdldFRpbWUoKSkuXG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn07XG5jb25zdCBiYXNpYyA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpLCByb3dCLmdldFZhbHVlKGNvbHVtbklkKSk7XG59O1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBjb21wYXJlQmFzaWMoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGEpIHtcbiAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgIGlmIChpc05hTihhKSB8fCBhID09PSBJbmZpbml0eSB8fCBhID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vLyBNaXhlZCBzb3J0aW5nIGlzIHNsb3csIGJ1dCB2ZXJ5IGluY2x1c2l2ZSBvZiBtYW55IGVkZ2UgY2FzZXMuXG4vLyBJdCBoYW5kbGVzIG51bWJlcnMsIG1peGVkIGFscGhhbnVtZXJpYyBjb21iaW5hdGlvbnMsIGFuZCBldmVuXG4vLyBudWxsLCB1bmRlZmluZWQsIGFuZCBJbmZpbml0eVxuZnVuY3Rpb24gY29tcGFyZUFscGhhbnVtZXJpYyhhU3RyLCBiU3RyKSB7XG4gIC8vIFNwbGl0IG9uIG51bWJlciBncm91cHMsIGJ1dCBrZWVwIHRoZSBkZWxpbWl0ZXJcbiAgLy8gVGhlbiByZW1vdmUgZmFsc2V5IHNwbGl0IHZhbHVlc1xuICBjb25zdCBhID0gYVN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IGIgPSBiU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcblxuICAvLyBXaGlsZVxuICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcbiAgICBjb25zdCBhYSA9IGEuc2hpZnQoKTtcbiAgICBjb25zdCBiYiA9IGIuc2hpZnQoKTtcbiAgICBjb25zdCBhbiA9IHBhcnNlSW50KGFhLCAxMCk7XG4gICAgY29uc3QgYm4gPSBwYXJzZUludChiYiwgMTApO1xuICAgIGNvbnN0IGNvbWJvID0gW2FuLCBibl0uc29ydCgpO1xuXG4gICAgLy8gQm90aCBhcmUgc3RyaW5nXG4gICAgaWYgKGlzTmFOKGNvbWJvWzBdKSkge1xuICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoYmIgPiBhYSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBPbmUgaXMgYSBzdHJpbmcsIG9uZSBpcyBhIG51bWJlclxuICAgIGlmIChpc05hTihjb21ib1sxXSkpIHtcbiAgICAgIHJldHVybiBpc05hTihhbikgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgLy8gQm90aCBhcmUgbnVtYmVyc1xuICAgIGlmIChhbiA+IGJuKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGJuID4gYW4pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG59XG5cbi8vIEV4cG9ydHNcblxuY29uc3Qgc29ydGluZ0ZucyA9IHtcbiAgYWxwaGFudW1lcmljLFxuICBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlLFxuICB0ZXh0LFxuICB0ZXh0Q2FzZVNlbnNpdGl2ZSxcbiAgZGF0ZXRpbWUsXG4gIGJhc2ljXG59O1xuXG4vL1xuXG5jb25zdCBTb3J0aW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZzogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZ0ZuOiAnYXV0bycsXG4gICAgICBzb3J0VW5kZWZpbmVkOiAxXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Tb3J0aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdzb3J0aW5nJywgdGFibGUpLFxuICAgICAgaXNNdWx0aVNvcnRFdmVudDogZSA9PiB7XG4gICAgICAgIHJldHVybiBlLnNoaWZ0S2V5O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5zbGljZSgxMCk7XG4gICAgICBsZXQgaXNTdHJpbmcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIGZpcnN0Um93cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJvdyA9PSBudWxsID8gdm9pZCAwIDogcm93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5kYXRldGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlzU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodmFsdWUuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuYWxwaGFudW1lcmljO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nRm5zLnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc29ydGluZ0Zucy5iYXNpYztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvU29ydERpciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnYXNjJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHNvcnRpbiwgX3RhYmxlJG9wdGlvbnMkc29ydGluMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4pID8gY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4oKSA6IChfdGFibGUkb3B0aW9ucyRzb3J0aW4gPSAoX3RhYmxlJG9wdGlvbnMkc29ydGluMiA9IHRhYmxlLm9wdGlvbnMuc29ydGluZ0ZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJHNvcnRpbjJbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkc29ydGluIDogc29ydGluZ0Zuc1tjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl07XG4gICAgfTtcbiAgICBjb2x1bW4udG9nZ2xlU29ydGluZyA9IChkZXNjLCBtdWx0aSkgPT4ge1xuICAgICAgLy8gaWYgKGNvbHVtbi5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgLy8gICBjb2x1bW4uY29sdW1ucy5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgICAvLyAgICAgaWYgKGMuaWQpIHtcbiAgICAgIC8vICAgICAgIHRhYmxlLnRvZ2dsZUNvbHVtblNvcnRpbmcoYy5pZCwgdW5kZWZpbmVkLCBtdWx0aSB8fCAhIWkpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9KVxuICAgICAgLy8gICByZXR1cm5cbiAgICAgIC8vIH1cblxuICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBvdXRzaWRlIG9mIHRhYmxlLnNldFNvcnRpbmcgdG8gYmUgaW4gc3luYyB3aXRoIHJlcmVuZGVyXG4gICAgICBjb25zdCBuZXh0U29ydGluZ09yZGVyID0gY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIoKTtcbiAgICAgIGNvbnN0IGhhc01hbnVhbFZhbHVlID0gdHlwZW9mIGRlc2MgIT09ICd1bmRlZmluZWQnICYmIGRlc2MgIT09IG51bGw7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIHNvcnRpbmcgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU29ydGluZyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgbGV0IG5ld1NvcnRpbmcgPSBbXTtcblxuICAgICAgICAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XG4gICAgICAgIGxldCBzb3J0QWN0aW9uO1xuICAgICAgICBsZXQgbmV4dERlc2MgPSBoYXNNYW51YWxWYWx1ZSA/IGRlc2MgOiBuZXh0U29ydGluZ09yZGVyID09PSAnZGVzYyc7XG5cbiAgICAgICAgLy8gTXVsdGktbW9kZVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgJiYgbXVsdGkpIHtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9ybWFsIG1vZGVcbiAgICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBleGlzdGluZ0luZGV4ICE9PSBvbGQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0b2dnbGUgc3RhdGVzIHRoYXQgd2lsbCByZW1vdmUgdGhlIHNvcnRpbmdcbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gSWYgd2UgYXJlIFwiYWN0dWFsbHlcIiB0b2dnbGluZyAobm90IGEgbWFudWFsIHNldCB2YWx1ZSksIHNob3VsZCB3ZSByZW1vdmUgdGhlIHNvcnRpbmc/XG4gICAgICAgICAgaWYgKCFoYXNNYW51YWxWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSXMgb3VyIGludGVudGlvbiB0byByZW1vdmU/XG4gICAgICAgICAgICBpZiAoIW5leHRTb3J0aW5nT3JkZXIpIHtcbiAgICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZW1vdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TXVsO1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbLi4ub2xkLCB7XG4gICAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICB9XTtcbiAgICAgICAgICAvLyBUYWtlIGxhdGVzdCBuIGNvbHVtbnNcbiAgICAgICAgICBuZXdTb3J0aW5nLnNwbGljZSgwLCBuZXdTb3J0aW5nLmxlbmd0aCAtICgoX3RhYmxlJG9wdGlvbnMkbWF4TXVsID0gdGFibGUub3B0aW9ucy5tYXhNdWx0aVNvcnRDb2xDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heE11bCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAvLyBUaGlzIGZsaXBzIChvciBzZXRzKSB0aGVcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gW3tcbiAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTb3J0aW5nO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJHNvcjtcbiAgICAgIGNvbnN0IHNvcnREZXNjRmlyc3QgPSAoX3JlZiA9IChfY29sdW1uJGNvbHVtbkRlZiRzb3IgPSBjb2x1bW4uY29sdW1uRGVmLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRzb3IgOiB0YWJsZS5vcHRpb25zLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfcmVmIDogY29sdW1uLmdldEF1dG9Tb3J0RGlyKCkgPT09ICdkZXNjJztcbiAgICAgIHJldHVybiBzb3J0RGVzY0ZpcnN0ID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlciA9IG11bHRpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBjb25zdCBmaXJzdFNvcnREaXJlY3Rpb24gPSBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyKCk7XG4gICAgICBjb25zdCBpc1NvcnRlZCA9IGNvbHVtbi5nZXRJc1NvcnRlZCgpO1xuICAgICAgaWYgKCFpc1NvcnRlZCkge1xuICAgICAgICByZXR1cm4gZmlyc3RTb3J0RGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzU29ydGVkICE9PSBmaXJzdFNvcnREaXJlY3Rpb24gJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmdSZW1vdmFsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKFxuICAgICAgLy8gSWYgZW5hYmxlU29ydFJlbW92ZSwgZW5hYmxlIGluIGdlbmVyYWxcbiAgICAgIG11bHRpID8gKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUmVtb3ZlKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUgOiB0cnVlKSAvLyBJZiBtdWx0aSwgZG9uJ3QgYWxsb3cgaWYgZW5hYmxlTXVsdGlSZW1vdmUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1NvcnRlZCA9PT0gJ2Rlc2MnID8gJ2FzYycgOiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuU29ydCA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTM7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZjIsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTI7XG4gICAgICByZXR1cm4gKF9yZWYyID0gKF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgOiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9yZWYyIDogISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1NvcnRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkc29ydGk7XG4gICAgICBjb25zdCBjb2x1bW5Tb3J0ID0gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aS5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgIHJldHVybiAhY29sdW1uU29ydCA/IGZhbHNlIDogY29sdW1uU29ydC5kZXNjID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIsIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgPSAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMyA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5jbGVhclNvcnRpbmcgPSAoKSA9PiB7XG4gICAgICAvL2NsZWFyIHNvcnRpbmcgZm9yIGp1c3QgMSBjb2x1bW5cbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+IG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggPyBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSA6IFtdKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVTb3J0aW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNvcnQgPSBjb2x1bW4uZ2V0Q2FuU29ydCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBpZiAoIWNhblNvcnQpIHJldHVybjtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVNvcnRpbmcodW5kZWZpbmVkLCBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgPyB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudChlKSA6IGZhbHNlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRTb3J0aW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRTb3J0aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5zb3J0aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRzIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFNvcnRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFNvcnRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxTb3J0aW5nIHx8ICF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgVmlzaWJpbGl0eSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblZpc2liaWxpdHk6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblZpc2liaWxpdHknLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPSB2YWx1ZSA9PiB7XG4gICAgICBpZiAoY29sdW1uLmdldENhbkhpZGUoKSkge1xuICAgICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KG9sZCA9PiAoe1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBbY29sdW1uLmlkXTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogIWNvbHVtbi5nZXRJc1Zpc2libGUoKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNWaXNpYmxlID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bSwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0yW2NvbHVtbi5pZF0pICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkY29sdW0gOiB0cnVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkhpZGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUhpZGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eShlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eV0sIGNlbGxzID0+IHtcbiAgICAgIHJldHVybiBjZWxscy5maWx0ZXIoY2VsbCA9PiBjZWxsLmNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdyb3cuX2dldEFsbFZpc2libGVDZWxscycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByb3cuZ2V0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldExlZnRWaXNpYmxlQ2VsbHMoKSwgcm93LmdldENlbnRlclZpc2libGVDZWxscygpLCByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiBbLi4ubGVmdCwgLi4uY2VudGVyLCAuLi5yaWdodF0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ3Jvdy5nZXRWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgY29uc3QgbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kID0gKGtleSwgZ2V0Q29sdW1ucykgPT4ge1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gW2dldENvbHVtbnMoKSwgZ2V0Q29sdW1ucygpLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlKCkpLm1hcChkID0+IGQuaWQpLmpvaW4oJ18nKV0sIGNvbHVtbnMgPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5maWx0ZXIoZCA9PiBkLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogZC5nZXRJc1Zpc2libGUoKSk7XG4gICAgICB9LCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMztcbiAgICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFZpc2libGVGbGF0Q29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUZsYXRDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5ID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5WaXNpYmlsaXR5ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5WaXNpYmlsaXR5KSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUgPSB2YWx1ZSA9PiB7XG4gICAgICB2YXIgX3ZhbHVlO1xuICAgICAgdmFsdWUgPSAoX3ZhbHVlID0gdmFsdWUpICE9IG51bGwgPyBfdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSgpO1xuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSh0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnJlZHVjZSgob2JqLCBjb2x1bW4pID0+ICh7XG4gICAgICAgIC4uLm9iaixcbiAgICAgICAgW2NvbHVtbi5pZF06ICF2YWx1ZSA/ICEoY29sdW1uLmdldENhbkhpZGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0Q2FuSGlkZSgpKSA6IHZhbHVlXG4gICAgICB9KSwge30pKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUgPSAoKSA9PiAhdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiAhKGNvbHVtbi5nZXRJc1Zpc2libGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpKTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSA9ICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuc29tZShjb2x1bW4gPT4gY29sdW1uLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxDb2x1bW5zVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgZmVhdHVyZXMgPSBbSGVhZGVycywgVmlzaWJpbGl0eSwgT3JkZXJpbmcsIFBpbm5pbmcsIEZpbHRlcnMsIFNvcnRpbmcsIEdyb3VwaW5nLCBFeHBhbmRpbmcsIFBhZ2luYXRpb24sIFJvd1NlbGVjdGlvbiwgQ29sdW1uU2l6aW5nXTtcblxuLy9cblxuZnVuY3Rpb24gY3JlYXRlVGFibGUob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkaW5pdGlhbFN0YXRlO1xuICBpZiAob3B0aW9ucy5kZWJ1Z0FsbCB8fCBvcHRpb25zLmRlYnVnVGFibGUpIHtcbiAgICBjb25zb2xlLmluZm8oJ0NyZWF0aW5nIFRhYmxlIEluc3RhbmNlLi4uJyk7XG4gIH1cbiAgbGV0IHRhYmxlID0ge1xuICAgIF9mZWF0dXJlczogZmVhdHVyZXNcbiAgfTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB0YWJsZS5fZmVhdHVyZXMucmVkdWNlKChvYmosIGZlYXR1cmUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnModGFibGUpKTtcbiAgfSwge30pO1xuICBjb25zdCBtZXJnZU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgICBpZiAodGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLm1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9O1xuICBjb25zdCBjb3JlSW5pdGlhbFN0YXRlID0ge307XG4gIGxldCBpbml0aWFsU3RhdGUgPSB7XG4gICAgLi4uY29yZUluaXRpYWxTdGF0ZSxcbiAgICAuLi4oKF9vcHRpb25zJGluaXRpYWxTdGF0ZSA9IG9wdGlvbnMuaW5pdGlhbFN0YXRlKSAhPSBudWxsID8gX29wdGlvbnMkaW5pdGlhbFN0YXRlIDoge30pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIHZhciBfZmVhdHVyZSRnZXRJbml0aWFsU3Q7XG4gICAgaW5pdGlhbFN0YXRlID0gKF9mZWF0dXJlJGdldEluaXRpYWxTdCA9IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZShpbml0aWFsU3RhdGUpKSAhPSBudWxsID8gX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IDogaW5pdGlhbFN0YXRlO1xuICB9KTtcbiAgY29uc3QgcXVldWVkID0gW107XG4gIGxldCBxdWV1ZWRUaW1lb3V0ID0gZmFsc2U7XG4gIGNvbnN0IGNvcmVJbnN0YW5jZSA9IHtcbiAgICBfZmVhdHVyZXM6IGZlYXR1cmVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIF9xdWV1ZTogY2IgPT4ge1xuICAgICAgcXVldWVkLnB1c2goY2IpO1xuICAgICAgaWYgKCFxdWV1ZWRUaW1lb3V0KSB7XG4gICAgICAgIHF1ZXVlZFRpbWVvdXQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFNjaGVkdWxlIGEgbWljcm90YXNrIHRvIHJ1biB0aGUgcXVldWVkIGNhbGxiYWNrcyBhZnRlclxuICAgICAgICAvLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIChyZW5kZXIsIGV0YykgaGFzIGZpbmlzaGVkLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB3aGlsZSAocXVldWVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVldWVkLnNoaWZ0KCkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldFN0YXRlKHRhYmxlLmluaXRpYWxTdGF0ZSk7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHRhYmxlLm9wdGlvbnMpO1xuICAgICAgdGFibGUub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICB9LFxuICAgIGdldFN0YXRlOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5zdGF0ZTtcbiAgICB9LFxuICAgIHNldFN0YXRlOiB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSh1cGRhdGVyKTtcbiAgICB9LFxuICAgIF9nZXRSb3dJZDogKHJvdywgaW5kZXgsIHBhcmVudCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdztcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZ2V0Um93ID0gdGFibGUub3B0aW9ucy5nZXRSb3dJZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRSb3dJZChyb3csIGluZGV4LCBwYXJlbnQpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogYCR7cGFyZW50ID8gW3BhcmVudC5pZCwgaW5kZXhdLmpvaW4oJy4nKSA6IGluZGV4fWA7XG4gICAgfSxcbiAgICBnZXRDb3JlUm93TW9kZWw6ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldENvcmVSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRDb3JlUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB9LFxuICAgIC8vIFRoZSBmaW5hbCBjYWxscyBzdGFydCBhdCB0aGUgYm90dG9tIG9mIHRoZSBtb2RlbCxcbiAgICAvLyBleHBhbmRlZCByb3dzLCB3aGljaCB0aGVuIHdvcmsgdGhlaXIgd2F5IHVwXG5cbiAgICBnZXRSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgIH0sXG4gICAgZ2V0Um93OiAoaWQsIHNlYXJjaEFsbCkgPT4ge1xuICAgICAgY29uc3Qgcm93ID0gKHNlYXJjaEFsbCA/IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpIDogdGFibGUuZ2V0Um93TW9kZWwoKSkucm93c0J5SWRbaWRdO1xuICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvdyBleHBlY3RlZCBhbiBJRCwgYnV0IGdvdCAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdztcbiAgICB9LFxuICAgIF9nZXREZWZhdWx0Q29sdW1uRGVmOiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRlZmF1bHRDb2x1bW5dLCBkZWZhdWx0Q29sdW1uID0+IHtcbiAgICAgIHZhciBfZGVmYXVsdENvbHVtbjtcbiAgICAgIGRlZmF1bHRDb2x1bW4gPSAoX2RlZmF1bHRDb2x1bW4gPSBkZWZhdWx0Q29sdW1uKSAhPSBudWxsID8gX2RlZmF1bHRDb2x1bW4gOiB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcjogcHJvcHMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29sdW1uRGVmID0gcHJvcHMuaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWY7XG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmb290ZXI6IHByb3BzID0+IHByb3BzLmhlYWRlci5jb2x1bW4uaWQsXG4gICAgICAgIGNlbGw6IHByb3BzID0+IHtcbiAgICAgICAgICB2YXIgX3Byb3BzJHJlbmRlclZhbHVlJHRvLCBfcHJvcHMkcmVuZGVyVmFsdWU7XG4gICAgICAgICAgcmV0dXJuIChfcHJvcHMkcmVuZGVyVmFsdWUkdG8gPSAoX3Byb3BzJHJlbmRlclZhbHVlID0gcHJvcHMucmVuZGVyVmFsdWUoKSkgPT0gbnVsbCB8fCBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRyZW5kZXJWYWx1ZS50b1N0cmluZygpKSAhPSBudWxsID8gX3Byb3BzJHJlbmRlclZhbHVlJHRvIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLi4udGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdENvbHVtbkRlZigpKTtcbiAgICAgICAgfSwge30pLFxuICAgICAgICAuLi5kZWZhdWx0Q29sdW1uXG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfSxcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldERlZmF1bHRDb2x1bW5EZWYnXG4gICAgfSksXG4gICAgX2dldENvbHVtbkRlZnM6ICgpID0+IHRhYmxlLm9wdGlvbnMuY29sdW1ucyxcbiAgICBnZXRBbGxDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0Q29sdW1uRGVmcygpXSwgY29sdW1uRGVmcyA9PiB7XG4gICAgICBjb25zdCByZWN1cnNlQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2x1bW5EZWZzLCBwYXJlbnQsIGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5EZWZzLm1hcChjb2x1bW5EZWYgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KTtcbiAgICAgICAgICBjb25zdCBncm91cGluZ0NvbHVtbkRlZiA9IGNvbHVtbkRlZjtcbiAgICAgICAgICBjb2x1bW4uY29sdW1ucyA9IGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMgPyByZWN1cnNlQ29sdW1ucyhncm91cGluZ0NvbHVtbkRlZi5jb2x1bW5zLCBjb2x1bW4sIGRlcHRoICsgMSkgOiBbXTtcbiAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVjdXJzZUNvbHVtbnMoY29sdW1uRGVmcyk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0QWxsQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBnZXRBbGxGbGF0Q29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpXSwgYWxsQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW4uZ2V0RmxhdENvbHVtbnMoKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEFsbEZsYXRDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pLFxuICAgIF9nZXRBbGxGbGF0Q29sdW1uc0J5SWQ6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbEZsYXRDb2x1bW5zKCldLCBmbGF0Q29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gZmxhdENvbHVtbnMucmVkdWNlKChhY2MsIGNvbHVtbikgPT4ge1xuICAgICAgICBhY2NbY29sdW1uLmlkXSA9IGNvbHVtbjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRBbGxGbGF0Q29sdW1uc0J5SWQnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTQ7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0IDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSksXG4gICAgZ2V0QWxsTGVhZkNvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCAoYWxsQ29sdW1ucywgb3JkZXJDb2x1bW5zKSA9PiB7XG4gICAgICBsZXQgbGVhZkNvbHVtbnMgPSBhbGxDb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEFsbExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTUgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGdldENvbHVtbjogY29sdW1uSWQgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuX2dldEFsbEZsYXRDb2x1bW5zQnlJZCgpW2NvbHVtbklkXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb2x1bW4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW1RhYmxlXSBDb2x1bW4gd2l0aCBpZCAnJHtjb2x1bW5JZH0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odGFibGUsIGNvcmVJbnN0YW5jZSk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRhYmxlLl9mZWF0dXJlc1tpbmRleF07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVRhYmxlKHRhYmxlKTtcbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNlbGwodGFibGUsIHJvdywgY29sdW1uLCBjb2x1bW5JZCkge1xuICBjb25zdCBnZXRSZW5kZXJWYWx1ZSA9ICgpID0+IHtcbiAgICB2YXIgX2NlbGwkZ2V0VmFsdWU7XG4gICAgcmV0dXJuIChfY2VsbCRnZXRWYWx1ZSA9IGNlbGwuZ2V0VmFsdWUoKSkgIT0gbnVsbCA/IF9jZWxsJGdldFZhbHVlIDogdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICB9O1xuICBjb25zdCBjZWxsID0ge1xuICAgIGlkOiBgJHtyb3cuaWR9XyR7Y29sdW1uLmlkfWAsXG4gICAgcm93LFxuICAgIGNvbHVtbixcbiAgICBnZXRWYWx1ZTogKCkgPT4gcm93LmdldFZhbHVlKGNvbHVtbklkKSxcbiAgICByZW5kZXJWYWx1ZTogZ2V0UmVuZGVyVmFsdWUsXG4gICAgZ2V0Q29udGV4dDogbWVtbygoKSA9PiBbdGFibGUsIGNvbHVtbiwgcm93LCBjZWxsXSwgKHRhYmxlLCBjb2x1bW4sIHJvdywgY2VsbCkgPT4gKHtcbiAgICAgIHRhYmxlLFxuICAgICAgY29sdW1uLFxuICAgICAgcm93LFxuICAgICAgY2VsbDogY2VsbCxcbiAgICAgIGdldFZhbHVlOiBjZWxsLmdldFZhbHVlLFxuICAgICAgcmVuZGVyVmFsdWU6IGNlbGwucmVuZGVyVmFsdWVcbiAgICB9KSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnY2VsbC5nZXRDb250ZXh0JyxcbiAgICAgIGRlYnVnOiAoKSA9PiB0YWJsZS5vcHRpb25zLmRlYnVnQWxsXG4gICAgfSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVDZWxsID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDZWxsKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNlbGw7XG59XG5cbmNvbnN0IGNyZWF0ZVJvdyA9ICh0YWJsZSwgaWQsIG9yaWdpbmFsLCByb3dJbmRleCwgZGVwdGgsIHN1YlJvd3MsIHBhcmVudElkKSA9PiB7XG4gIGxldCByb3cgPSB7XG4gICAgaWQsXG4gICAgaW5kZXg6IHJvd0luZGV4LFxuICAgIG9yaWdpbmFsLFxuICAgIGRlcHRoLFxuICAgIHBhcmVudElkLFxuICAgIF92YWx1ZXNDYWNoZToge30sXG4gICAgX3VuaXF1ZVZhbHVlc0NhY2hlOiB7fSxcbiAgICBnZXRWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fdmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uYWNjZXNzb3JGbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmFjY2Vzc29yRm4ocm93Lm9yaWdpbmFsLCByb3dJbmRleCk7XG4gICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfSxcbiAgICBnZXRVbmlxdWVWYWx1ZXM6IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX3VuaXF1ZVZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmFjY2Vzc29yRm4pKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbHVtbi5jb2x1bW5EZWYuZ2V0VW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gW3Jvdy5nZXRWYWx1ZShjb2x1bW5JZCldO1xuICAgICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5jb2x1bW5EZWYuZ2V0VW5pcXVlVmFsdWVzKHJvdy5vcmlnaW5hbCwgcm93SW5kZXgpO1xuICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgIH0sXG4gICAgcmVuZGVyVmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgIHZhciBfcm93JGdldFZhbHVlO1xuICAgICAgcmV0dXJuIChfcm93JGdldFZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9yb3ckZ2V0VmFsdWUgOiB0YWJsZS5vcHRpb25zLnJlbmRlckZhbGxiYWNrVmFsdWU7XG4gICAgfSxcbiAgICBzdWJSb3dzOiBzdWJSb3dzICE9IG51bGwgPyBzdWJSb3dzIDogW10sXG4gICAgZ2V0TGVhZlJvd3M6ICgpID0+IGZsYXR0ZW5CeShyb3cuc3ViUm93cywgZCA9PiBkLnN1YlJvd3MpLFxuICAgIGdldFBhcmVudFJvdzogKCkgPT4gcm93LnBhcmVudElkID8gdGFibGUuZ2V0Um93KHJvdy5wYXJlbnRJZCwgdHJ1ZSkgOiB1bmRlZmluZWQsXG4gICAgZ2V0UGFyZW50Um93czogKCkgPT4ge1xuICAgICAgbGV0IHBhcmVudFJvd3MgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50Um93ID0gcm93O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Um93ID0gY3VycmVudFJvdy5nZXRQYXJlbnRSb3coKTtcbiAgICAgICAgaWYgKCFwYXJlbnRSb3cpIGJyZWFrO1xuICAgICAgICBwYXJlbnRSb3dzLnB1c2gocGFyZW50Um93KTtcbiAgICAgICAgY3VycmVudFJvdyA9IHBhcmVudFJvdztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRSb3dzLnJldmVyc2UoKTtcbiAgICB9LFxuICAgIGdldEFsbENlbGxzOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpXSwgbGVhZkNvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGxlYWZDb2x1bW5zLm1hcChjb2x1bW4gPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2VsbCh0YWJsZSwgcm93LCBjb2x1bW4sIGNvbHVtbi5pZCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0QWxsQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSksXG4gICAgX2dldEFsbENlbGxzQnlDb2x1bW5JZDogbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCldLCBhbGxDZWxscyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ2VsbHMucmVkdWNlKChhY2MsIGNlbGwpID0+IHtcbiAgICAgICAgYWNjW2NlbGwuY29sdW1uLmlkXSA9IGNlbGw7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdyb3cuZ2V0QWxsQ2VsbHNCeUNvbHVtbklkJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pXG4gIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGUuX2ZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRhYmxlLl9mZWF0dXJlc1tpXTtcbiAgICBmZWF0dXJlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVSb3cgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVJvdyhyb3csIHRhYmxlKTtcbiAgfVxuICByZXR1cm4gcm93O1xufTtcblxuLy8gdHlwZSBQZXJzb24gPSB7XG4vLyAgIGZpcnN0TmFtZTogc3RyaW5nXG4vLyAgIGxhc3ROYW1lOiBzdHJpbmdcbi8vICAgYWdlOiBudW1iZXJcbi8vICAgdmlzaXRzOiBudW1iZXJcbi8vICAgc3RhdHVzOiBzdHJpbmdcbi8vICAgcHJvZ3Jlc3M6IG51bWJlclxuLy8gICBjcmVhdGVkQXQ6IERhdGVcbi8vICAgbmVzdGVkOiB7XG4vLyAgICAgZm9vOiBbXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGJhcjogJ2Jhcidcbi8vICAgICAgIH1cbi8vICAgICBdXG4vLyAgICAgYmFyOiB7IHN1YkJhcjogYm9vbGVhbiB9W11cbi8vICAgICBiYXo6IHtcbi8vICAgICAgIGZvbzogJ2Zvbydcbi8vICAgICAgIGJhcjoge1xuLy8gICAgICAgICBiYXo6ICdiYXonXG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbi8vIGNvbnN0IHRlc3Q6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmZvby4wLmJhcidcbi8vIGNvbnN0IHRlc3QyOiBEZWVwS2V5czxQZXJzb24+ID0gJ25lc3RlZC5iYXInXG5cbi8vIGNvbnN0IGhlbHBlciA9IGNyZWF0ZUNvbHVtbkhlbHBlcjxQZXJzb24+KClcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvby4wLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5iYXInLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbkhlbHBlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBhY2Nlc3NvcjogKGFjY2Vzc29yLCBjb2x1bW4pID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzb3IgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgYWNjZXNzb3JGbjogYWNjZXNzb3JcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgYWNjZXNzb3JLZXk6IGFjY2Vzc29yXG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlzcGxheTogY29sdW1uID0+IGNvbHVtbixcbiAgICBncm91cDogY29sdW1uID0+IGNvbHVtblxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb3JlUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRhdGFdLCBkYXRhID0+IHtcbiAgICBjb25zdCByb3dNb2RlbCA9IHtcbiAgICAgIHJvd3M6IFtdLFxuICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgcm93c0J5SWQ6IHt9XG4gICAgfTtcbiAgICBjb25zdCBhY2Nlc3NSb3dzID0gZnVuY3Rpb24gKG9yaWdpbmFsUm93cywgZGVwdGgsIHBhcmVudFJvdykge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBleHBlbnNpdmUgY2hlY2sgYXQgc2NhbGUsIHNvIHdlIHNob3VsZCBtb3ZlIGl0IHNvbWV3aGVyZSBlbHNlLCBidXQgd2hlcmU/XG4gICAgICAgIC8vIGlmICghaWQpIHtcbiAgICAgICAgLy8gICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRSb3dJZCBleHBlY3RlZCBhbiBJRCwgYnV0IGdvdCAke2lkfWApXG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgcm93XG4gICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgdGFibGUuX2dldFJvd0lkKG9yaWdpbmFsUm93c1tpXSwgaSwgcGFyZW50Um93KSwgb3JpZ2luYWxSb3dzW2ldLCBpLCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFJvdy5pZCk7XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBldmVyeSByb3cgaW4gYSBmbGF0IGFycmF5XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBieSBpdHMgSURcbiAgICAgICAgcm93TW9kZWwucm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgLy8gUHVzaCB0YWJsZSByb3cgaW50byBwYXJlbnRcbiAgICAgICAgcm93cy5wdXNoKHJvdyk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBzdWJyb3dzXG4gICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmdldFN1YlJvd3MpIHtcbiAgICAgICAgICB2YXIgX3JvdyRvcmlnaW5hbFN1YlJvd3M7XG4gICAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cyA9IHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cyhvcmlnaW5hbFJvd3NbaV0sIGkpO1xuXG4gICAgICAgICAgLy8gVGhlbiByZWN1cnNpdmVseSBhY2Nlc3MgdGhlbVxuICAgICAgICAgIGlmICgoX3JvdyRvcmlnaW5hbFN1YlJvd3MgPSByb3cub3JpZ2luYWxTdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckb3JpZ2luYWxTdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBhY2Nlc3NSb3dzKHJvdy5vcmlnaW5hbFN1YlJvd3MsIGRlcHRoICsgMSwgcm93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgcm93TW9kZWwucm93cyA9IGFjY2Vzc1Jvd3MoZGF0YSk7XG4gICAgcmV0dXJuIHJvd01vZGVsO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0Um93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJSb3dzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKSB7XG4gIGlmICh0YWJsZS5vcHRpb25zLmZpbHRlckZyb21MZWFmUm93cykge1xuICAgIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpO1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWE7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEgPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heExlYSA6IDEwMDtcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBmcm9tIGNoaWxkcmVuIHVwIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgIG5ld1Jvdy5jb2x1bW5GaWx0ZXJzID0gcm93LmNvbHVtbkZpbHRlcnM7XG4gICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSAmJiAhbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSB8fCBuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWEyO1xuICBjb25zdCBuZXdGaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQgPSB7fTtcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA6IDEwMDtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIC8vIEZpbHRlciBmcm9tIHBhcmVudHMgZG93bndhcmQgZmlyc3RcblxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gYW55IHN1YlJvd3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXTtcbiAgICAgIGNvbnN0IHBhc3MgPSBmaWx0ZXJSb3cocm93KTtcbiAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgfVxuICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGaWx0ZXJlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMsIHRhYmxlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyXSwgKHJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzW2ldLmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzID0gW107XG4gICAgY29uc3QgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzID0gW107XG4gICAgKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCA/IGNvbHVtbkZpbHRlcnMgOiBbXSkuZm9yRWFjaChkID0+IHtcbiAgICAgIHZhciBfZmlsdGVyRm4kcmVzb2x2ZUZpbHQ7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oZC5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgaWYgKCFmaWx0ZXJGbikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlckZuJyBmb3IgY29sdW1uIHdpdGggdGhlIElEOiAke2NvbHVtbi5pZH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLnB1c2goe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgZmlsdGVyRm4sXG4gICAgICAgIHJlc29sdmVkVmFsdWU6IChfZmlsdGVyRm4kcmVzb2x2ZUZpbHQgPSBmaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShkLnZhbHVlKSkgIT0gbnVsbCA/IF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA6IGQudmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSBjb2x1bW5GaWx0ZXJzLm1hcChkID0+IGQuaWQpO1xuICAgIGNvbnN0IGdsb2JhbEZpbHRlckZuID0gdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4oKTtcbiAgICBjb25zdCBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIoKSk7XG4gICAgaWYgKGdsb2JhbEZpbHRlciAmJiBnbG9iYWxGaWx0ZXJGbiAmJiBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgZmlsdGVyYWJsZUlkcy5wdXNoKCdfX2dsb2JhbF9fJyk7XG4gICAgICBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgdmFyIF9nbG9iYWxGaWx0ZXJGbiRyZXNvbDtcbiAgICAgICAgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLnB1c2goe1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgZmlsdGVyRm46IGdsb2JhbEZpbHRlckZuLFxuICAgICAgICAgIHJlc29sdmVkVmFsdWU6IChfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgPSBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShnbG9iYWxGaWx0ZXIpKSAhPSBudWxsID8gX2dsb2JhbEZpbHRlckZuJHJlc29sIDogZ2xvYmFsRmlsdGVyXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjdXJyZW50Q29sdW1uRmlsdGVyO1xuICAgIGxldCBjdXJyZW50R2xvYmFsRmlsdGVyO1xuXG4gICAgLy8gRmxhZyB0aGUgcHJlZmlsdGVyZWQgcm93IG1vZGVsIHdpdGggZWFjaCBmaWx0ZXIgc3RhdGVcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCByb3cgPSByb3dNb2RlbC5mbGF0Um93c1tqXTtcbiAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzID0ge307XG4gICAgICBpZiAocmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkQ29sdW1uRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRDb2x1bW5GaWx0ZXIgPSByZXNvbHZlZENvbHVtbkZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50Q29sdW1uRmlsdGVyLmlkO1xuXG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgY29sdW1uIGZpbHRlciBzdGF0ZVxuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzW2lkXSA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudENvbHVtbkZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkR2xvYmFsRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRHbG9iYWxGaWx0ZXIgPSByZXNvbHZlZEdsb2JhbEZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50R2xvYmFsRmlsdGVyLmlkO1xuICAgICAgICAgIC8vIFRhZyB0aGUgcm93IHdpdGggdGhlIGZpcnN0IHRydXRoeSBnbG9iYWwgZmlsdGVyIHN0YXRlXG4gICAgICAgICAgaWYgKGN1cnJlbnRHbG9iYWxGaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudEdsb2JhbEZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBGaWx0ZXIgZmluYWwgcm93cyB1c2luZyBhbGwgb2YgdGhlIGFjdGl2ZSBmaWx0ZXJzXG4gICAgcmV0dXJuIGZpbHRlclJvd3Mocm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZpbHRlcmVkUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXIsIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChwcmVSb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XG4gICAgaWYgKCFwcmVSb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCAmJiBjb2x1bW5GaWx0ZXJzLmxlbmd0aCkgJiYgIWdsb2JhbEZpbHRlcikge1xuICAgICAgcmV0dXJuIHByZVJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJhYmxlSWRzID0gWy4uLmNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCkuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uSWQpLCBnbG9iYWxGaWx0ZXIgPyAnX19nbG9iYWxfXycgOiB1bmRlZmluZWRdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbHRlclJvd3MocHJlUm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZhY2V0ZWRSb3dNb2RlbF8nICsgY29sdW1uSWQsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xuICB9LCBmYWNldGVkUm93TW9kZWwgPT4ge1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gbmV3IE1hcCgpO1xuICAgIGxldCBmYWNldGVkVW5pcXVlVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbaV0uZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2pdO1xuICAgICAgICBpZiAoZmFjZXRlZFVuaXF1ZVZhbHVlcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgdmFyIF9mYWNldGVkVW5pcXVlVmFsdWVzJDtcbiAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldCh2YWx1ZSwgKChfZmFjZXRlZFVuaXF1ZVZhbHVlcyQgPSBmYWNldGVkVW5pcXVlVmFsdWVzLmdldCh2YWx1ZSkpICE9IG51bGwgPyBfZmFjZXRlZFVuaXF1ZVZhbHVlcyQgOiAwKSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFjZXRlZFVuaXF1ZVZhbHVlcztcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXNfJyArIGNvbHVtbklkLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHt9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkTWluTWF4VmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICB2YXIgX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0O1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSAoX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0ID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0LmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSBbZmlyc3RWYWx1ZSwgZmlyc3RWYWx1ZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmICh2YWx1ZSA8IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMF0pIHtcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzBdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiBmYWNldGVkTWluTWF4VmFsdWVzWzFdKSB7XG4gICAgICAgICAgZmFjZXRlZE1pbk1heFZhbHVlc1sxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkTWluTWF4VmFsdWVzO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmFjZXRlZE1pbk1heFZhbHVlc18nICsgY29sdW1uSWQsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nLCB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXSwgKHNvcnRpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKHNvcnRpbmcgIT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3Qgc29ydGluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nO1xuICAgIGNvbnN0IHNvcnRlZEZsYXRSb3dzID0gW107XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHNvcnRpbmdzIHRoYXQgY29ycmVzcG9uZCB0byBub24gZXhpc3RpbmcgY29sdW1uc1xuICAgIGNvbnN0IGF2YWlsYWJsZVNvcnRpbmcgPSBzb3J0aW5nU3RhdGUuZmlsdGVyKHNvcnQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydC5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldENhblNvcnQoKTtcbiAgICB9KTtcbiAgICBjb25zdCBjb2x1bW5JbmZvQnlJZCA9IHt9O1xuICAgIGF2YWlsYWJsZVNvcnRpbmcuZm9yRWFjaChzb3J0RW50cnkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnRFbnRyeS5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikgcmV0dXJuO1xuICAgICAgY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXSA9IHtcbiAgICAgICAgc29ydFVuZGVmaW5lZDogY29sdW1uLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxuICAgICAgICBpbnZlcnRTb3J0aW5nOiBjb2x1bW4uY29sdW1uRGVmLmludmVydFNvcnRpbmcsXG4gICAgICAgIHNvcnRpbmdGbjogY29sdW1uLmdldFNvcnRpbmdGbigpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHNvcnREYXRhID0gcm93cyA9PiB7XG4gICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxuICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgY29uc3Qgc29ydGVkRGF0YSA9IHJvd3MubWFwKHJvdyA9PiAoe1xuICAgICAgICAuLi5yb3dcbiAgICAgIH0pKTtcbiAgICAgIHNvcnRlZERhdGEuc29ydCgocm93QSwgcm93QikgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2YWlsYWJsZVNvcnRpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgX3NvcnRFbnRyeSRkZXNjO1xuICAgICAgICAgIGNvbnN0IHNvcnRFbnRyeSA9IGF2YWlsYWJsZVNvcnRpbmdbaV07XG4gICAgICAgICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF07XG4gICAgICAgICAgY29uc3QgaXNEZXNjID0gKF9zb3J0RW50cnkkZGVzYyA9IHNvcnRFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogc29ydEVudHJ5LmRlc2MpICE9IG51bGwgPyBfc29ydEVudHJ5JGRlc2MgOiBmYWxzZTtcbiAgICAgICAgICBsZXQgc29ydEludCA9IDA7XG5cbiAgICAgICAgICAvLyBBbGwgc29ydGluZyBpbnRzIHNob3VsZCBhbHdheXMgcmV0dXJuIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAgIGlmIChjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFWYWx1ZSA9IHJvd0EuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGJWYWx1ZSA9IHJvd0IuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGFVbmRlZmluZWQgPSBhVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJVbmRlZmluZWQgPSBiVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhVW5kZWZpbmVkIHx8IGJVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc29ydEludCA9IGFVbmRlZmluZWQgJiYgYlVuZGVmaW5lZCA/IDAgOiBhVW5kZWZpbmVkID8gY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkIDogLWNvbHVtbkluZm8uc29ydFVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvcnRJbnQgPT09IDApIHtcbiAgICAgICAgICAgIHNvcnRJbnQgPSBjb2x1bW5JbmZvLnNvcnRpbmdGbihyb3dBLCByb3dCLCBzb3J0RW50cnkuaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHNvcnRpbmcgaXMgbm9uLXplcm8sIHRha2UgY2FyZSBvZiBkZXNjIGFuZCBpbnZlcnNpb25cbiAgICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbkluZm8uaW52ZXJ0U29ydGluZykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dBLmluZGV4IC0gcm93Qi5pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc3ViLXJvd3MsIHNvcnQgdGhlbVxuICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICAgIHNvcnRlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93LnN1YlJvd3MgPSBzb3J0RGF0YShyb3cuc3ViUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRlZERhdGE7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogc29ydERhdGEocm93TW9kZWwucm93cyksXG4gICAgICBmbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgICB9O1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0U29ydGVkUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRHcm91cGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKV0sIChncm91cGluZywgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICFncm91cGluZy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgdGhlIGdyb3VwaW5nIGxpc3QgZG93biB0byBjb2x1bW5zIHRoYXQgZXhpc3RcbiAgICBjb25zdCBleGlzdGluZ0dyb3VwaW5nID0gZ3JvdXBpbmcuZmlsdGVyKGNvbHVtbklkID0+IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpO1xuICAgIGNvbnN0IGdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgIGNvbnN0IGdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgIC8vIGNvbnN0IG9ubHlHcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZEZsYXRSb3dzOiBSb3dbXSA9IFtdO1xuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG5cbiAgICAvLyBSZWN1cnNpdmVseSBncm91cCB0aGUgZGF0YVxuICAgIGNvbnN0IGdyb3VwVXBSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCwgcGFyZW50SWQpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEdyb3VwaW5nIGRlcHRoIGhhcyBiZWVuIGJlZW4gbWV0XG4gICAgICAvLyBTdG9wIGdyb3VwaW5nIGFuZCBzaW1wbHkgcmV3cml0ZSB0aGQgZGVwdGggYW5kIHJvdyByZWxhdGlvbnNoaXBzXG4gICAgICBpZiAoZGVwdGggPj0gZXhpc3RpbmdHcm91cGluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICAgICAgcm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBncm91cGVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBpZiAocm93LnN1YlJvd3MpIHtcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvdy5zdWJSb3dzLCBkZXB0aCArIDEsIHJvdy5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uSWQgPSBleGlzdGluZ0dyb3VwaW5nW2RlcHRoXTtcblxuICAgICAgLy8gR3JvdXAgdGhlIHJvd3MgdG9nZXRoZXIgZm9yIHRoaXMgbGV2ZWxcbiAgICAgIGNvbnN0IHJvd0dyb3Vwc01hcCA9IGdyb3VwQnkocm93cywgY29sdW1uSWQpO1xuXG4gICAgICAvLyBQZWZvcm0gYWdncmVnYXRpb25zIGZvciBlYWNoIGdyb3VwXG4gICAgICBjb25zdCBhZ2dyZWdhdGVkR3JvdXBlZFJvd3MgPSBBcnJheS5mcm9tKHJvd0dyb3Vwc01hcC5lbnRyaWVzKCkpLm1hcCgoX3JlZiwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IFtncm91cGluZ1ZhbHVlLCBncm91cGVkUm93c10gPSBfcmVmO1xuICAgICAgICBsZXQgaWQgPSBgJHtjb2x1bW5JZH06JHtncm91cGluZ1ZhbHVlfWA7XG4gICAgICAgIGlkID0gcGFyZW50SWQgPyBgJHtwYXJlbnRJZH0+JHtpZH1gIDogaWQ7XG5cbiAgICAgICAgLy8gRmlyc3QsIFJlY3Vyc2UgdG8gZ3JvdXAgc3ViIHJvd3MgYmVmb3JlIGFnZ3JlZ2F0aW9uXG4gICAgICAgIGNvbnN0IHN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkoZ3JvdXBlZFJvd3MsIGRlcHRoICsgMSwgaWQpO1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIGxlYWYgcm93cyBvZiB0aGUgcm93cyBpbiB0aGlzIGdyb3VwXG4gICAgICAgIGNvbnN0IGxlYWZSb3dzID0gZGVwdGggPyBmbGF0dGVuQnkoZ3JvdXBlZFJvd3MsIHJvdyA9PiByb3cuc3ViUm93cykgOiBncm91cGVkUm93cztcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCBpZCwgbGVhZlJvd3NbMF0ub3JpZ2luYWwsIGluZGV4LCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRJZCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocm93LCB7XG4gICAgICAgICAgZ3JvdXBpbmdDb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgICAgZ3JvdXBpbmdWYWx1ZSxcbiAgICAgICAgICBzdWJSb3dzLFxuICAgICAgICAgIGxlYWZSb3dzLFxuICAgICAgICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICAgICAgICAvLyBEb24ndCBhZ2dyZWdhdGUgY29sdW1ucyB0aGF0IGFyZSBpbiB0aGUgZ3JvdXBpbmdcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0dyb3VwaW5nLmluY2x1ZGVzKGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGdyb3VwZWRSb3dzWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ncm91cGVkUm93cyQwJGdldFZhbDtcbiAgICAgICAgICAgICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IChfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgPSBncm91cGVkUm93c1swXS5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFnZ3JlZ2F0ZSB0aGUgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgICAgICAgY29uc3QgYWdncmVnYXRlRm4gPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuKCk7XG4gICAgICAgICAgICBpZiAoYWdncmVnYXRlRm4pIHtcbiAgICAgICAgICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGFnZ3JlZ2F0ZUZuKGNvbHVtbklkLCBsZWFmUm93cywgZ3JvdXBlZFJvd3MpO1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xuICAgICAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZ2dyZWdhdGVkR3JvdXBlZFJvd3M7XG4gICAgfTtcbiAgICBjb25zdCBncm91cGVkUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3dNb2RlbC5yb3dzLCAwKTtcbiAgICBncm91cGVkUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyBpZiAoc3ViUm93LmdldElzR3JvdXBlZD8uKCkpIHtcbiAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IGdyb3VwZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiBncm91cGVkUm93c0J5SWRcbiAgICB9O1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0R3JvdXBlZFJvd01vZGVsJyxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICB0YWJsZS5fYXV0b1Jlc2V0RXhwYW5kZWQoKTtcbiAgICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkocm93cywgY29sdW1uSWQpIHtcbiAgY29uc3QgZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiByb3dzLnJlZHVjZSgobWFwLCByb3cpID0+IHtcbiAgICBjb25zdCByZXNLZXkgPSBgJHtyb3cuZ2V0R3JvdXBpbmdWYWx1ZShjb2x1bW5JZCl9YDtcbiAgICBjb25zdCBwcmV2aW91cyA9IG1hcC5nZXQocmVzS2V5KTtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICBtYXAuc2V0KHJlc0tleSwgW3Jvd10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91cy5wdXNoKHJvdyk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH0sIGdyb3VwTWFwKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQsIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93c10sIChleHBhbmRlZCwgcm93TW9kZWwsIHBhZ2luYXRlRXhwYW5kZWRSb3dzKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCBleHBhbmRlZCAhPT0gdHJ1ZSAmJiAhT2JqZWN0LmtleXMoZXhwYW5kZWQgIT0gbnVsbCA/IGV4cGFuZGVkIDoge30pLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBpZiAoIXBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICAvLyBPbmx5IGV4cGFuZCByb3dzIGF0IHRoaXMgcG9pbnQgaWYgdGhleSBhcmUgYmVpbmcgcGFnaW5hdGVkXG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRSb3dzKHJvd01vZGVsKTtcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEV4cGFuZGVkUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBleHBhbmRSb3dzKHJvd01vZGVsKSB7XG4gIGNvbnN0IGV4cGFuZGVkUm93cyA9IFtdO1xuICBjb25zdCBoYW5kbGVSb3cgPSByb3cgPT4ge1xuICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgZXhwYW5kZWRSb3dzLnB1c2gocm93KTtcbiAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgcm93LmdldElzRXhwYW5kZWQoKSkge1xuICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgIH1cbiAgfTtcbiAgcm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gIHJldHVybiB7XG4gICAgcm93czogZXhwYW5kZWRSb3dzLFxuICAgIGZsYXRSb3dzOiByb3dNb2RlbC5mbGF0Um93cyxcbiAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFnaW5hdGlvblJvd01vZGVsKG9wdHMpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbiwgdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCksIHRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MgPyB1bmRlZmluZWQgOiB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkXSwgKHBhZ2luYXRpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlU2l6ZSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSBwYWdpbmF0aW9uO1xuICAgIGxldCB7XG4gICAgICByb3dzLFxuICAgICAgZmxhdFJvd3MsXG4gICAgICByb3dzQnlJZFxuICAgIH0gPSByb3dNb2RlbDtcbiAgICBjb25zdCBwYWdlU3RhcnQgPSBwYWdlU2l6ZSAqIHBhZ2VJbmRleDtcbiAgICBjb25zdCBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgcGFnZVNpemU7XG4gICAgcm93cyA9IHJvd3Muc2xpY2UocGFnZVN0YXJ0LCBwYWdlRW5kKTtcbiAgICBsZXQgcGFnaW5hdGVkUm93TW9kZWw7XG4gICAgaWYgKCF0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IGV4cGFuZFJvd3Moe1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IHtcbiAgICAgICAgcm93cyxcbiAgICAgICAgZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkXG4gICAgICB9O1xuICAgIH1cbiAgICBwYWdpbmF0ZWRSb3dNb2RlbC5mbGF0Um93cyA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbC5mbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICBpZiAocm93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhZ2luYXRlZFJvd01vZGVsLnJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgIHJldHVybiBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFBhZ2luYXRpb25Sb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgQ29sdW1uU2l6aW5nLCBFeHBhbmRpbmcsIEZpbHRlcnMsIEdyb3VwaW5nLCBIZWFkZXJzLCBPcmRlcmluZywgUGFnaW5hdGlvbiwgUGlubmluZywgUm93U2VsZWN0aW9uLCBTb3J0aW5nLCBWaXNpYmlsaXR5LCBhZ2dyZWdhdGlvbkZucywgYnVpbGRIZWFkZXJHcm91cHMsIGNyZWF0ZUNlbGwsIGNyZWF0ZUNvbHVtbiwgY3JlYXRlQ29sdW1uSGVscGVyLCBjcmVhdGVSb3csIGNyZWF0ZVRhYmxlLCBkZWZhdWx0Q29sdW1uU2l6aW5nLCBleHBhbmRSb3dzLCBmaWx0ZXJGbnMsIGZsYXR0ZW5CeSwgZnVuY3Rpb25hbFVwZGF0ZSwgZ2V0Q29yZVJvd01vZGVsLCBnZXRFeHBhbmRlZFJvd01vZGVsLCBnZXRGYWNldGVkTWluTWF4VmFsdWVzLCBnZXRGYWNldGVkUm93TW9kZWwsIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMsIGdldEZpbHRlcmVkUm93TW9kZWwsIGdldEdyb3VwZWRSb3dNb2RlbCwgZ2V0UGFnaW5hdGlvblJvd01vZGVsLCBnZXRTb3J0ZWRSb3dNb2RlbCwgaXNGdW5jdGlvbiwgaXNOdW1iZXJBcnJheSwgaXNSb3dTZWxlY3RlZCwgaXNTdWJSb3dTZWxlY3RlZCwgbWFrZVN0YXRlVXBkYXRlciwgbWVtbywgbm9vcCwgb3JkZXJDb2x1bW5zLCBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQsIHJlU3BsaXRBbHBoYU51bWVyaWMsIHNlbGVjdFJvd3NGbiwgc2hvdWxkQXV0b1JlbW92ZUZpbHRlciwgc29ydGluZ0ZucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbImZ1bmN0aW9uYWxVcGRhdGUiLCJ1cGRhdGVyIiwiaW5wdXQiLCJub29wIiwibWFrZVN0YXRlVXBkYXRlciIsImtleSIsImluc3RhbmNlIiwic2V0U3RhdGUiLCJvbGQiLCJpc0Z1bmN0aW9uIiwiZCIsIkZ1bmN0aW9uIiwiaXNOdW1iZXJBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwidmFsIiwiZmxhdHRlbkJ5IiwiYXJyIiwiZ2V0Q2hpbGRyZW4iLCJmbGF0IiwicmVjdXJzZSIsInN1YkFyciIsImZvckVhY2giLCJpdGVtIiwicHVzaCIsImNoaWxkcmVuIiwibGVuZ3RoIiwibWVtbyIsImdldERlcHMiLCJmbiIsIm9wdHMiLCJkZXBzIiwicmVzdWx0IiwiZGVwVGltZSIsImRlYnVnIiwiRGF0ZSIsIm5vdyIsIm5ld0RlcHMiLCJkZXBzQ2hhbmdlZCIsInNvbWUiLCJkZXAiLCJpbmRleCIsInJlc3VsdFRpbWUiLCJvbkNoYW5nZSIsImRlcEVuZFRpbWUiLCJNYXRoIiwicm91bmQiLCJyZXN1bHRFbmRUaW1lIiwicmVzdWx0RnBzUGVyY2VudGFnZSIsInBhZCIsInN0ciIsIm51bSIsIlN0cmluZyIsImNvbnNvbGUiLCJpbmZvIiwibWF4IiwibWluIiwiY3JlYXRlQ29sdW1uIiwidGFibGUiLCJjb2x1bW5EZWYiLCJkZXB0aCIsInBhcmVudCIsIl9yZWYiLCJfcmVzb2x2ZWRDb2x1bW5EZWYkaWQiLCJkZWZhdWx0Q29sdW1uIiwiX2dldERlZmF1bHRDb2x1bW5EZWYiLCJyZXNvbHZlZENvbHVtbkRlZiIsImFjY2Vzc29yS2V5IiwiaWQiLCJyZXBsYWNlIiwidW5kZWZpbmVkIiwiaGVhZGVyIiwiYWNjZXNzb3JGbiIsImluY2x1ZGVzIiwib3JpZ2luYWxSb3ciLCJzcGxpdCIsIl9yZXN1bHQiLCJwcm9jZXNzIiwid2FybiIsIkVycm9yIiwiY29sdW1uIiwiY29sdW1ucyIsImdldEZsYXRDb2x1bW5zIiwiX2NvbHVtbiRjb2x1bW5zIiwiZmxhdE1hcCIsIl90YWJsZSRvcHRpb25zJGRlYnVnQSIsIm9wdGlvbnMiLCJkZWJ1Z0FsbCIsImRlYnVnQ29sdW1ucyIsImdldExlYWZDb2x1bW5zIiwiX2dldE9yZGVyQ29sdW1uc0ZuIiwib3JkZXJDb2x1bW5zIiwiX2NvbHVtbiRjb2x1bW5zMiIsImxlYWZDb2x1bW5zIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMiIsImZlYXR1cmUiLCJfZmVhdHVyZXMiLCJjcmVhdGVIZWFkZXIiLCJfb3B0aW9ucyRpZCIsImlzUGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlcklkIiwic3ViSGVhZGVycyIsImNvbFNwYW4iLCJyb3dTcGFuIiwiaGVhZGVyR3JvdXAiLCJnZXRMZWFmSGVhZGVycyIsImxlYWZIZWFkZXJzIiwicmVjdXJzZUhlYWRlciIsImgiLCJtYXAiLCJnZXRDb250ZXh0IiwiSGVhZGVycyIsImNyZWF0ZVRhYmxlIiwiZ2V0SGVhZGVyR3JvdXBzIiwiZ2V0QWxsQ29sdW1ucyIsImdldFZpc2libGVMZWFmQ29sdW1ucyIsImdldFN0YXRlIiwiY29sdW1uUGlubmluZyIsImxlZnQiLCJyaWdodCIsImFsbENvbHVtbnMiLCJfbGVmdCRtYXAkZmlsdGVyIiwiX3JpZ2h0JG1hcCRmaWx0ZXIiLCJsZWZ0Q29sdW1ucyIsImNvbHVtbklkIiwiZmluZCIsImZpbHRlciIsIkJvb2xlYW4iLCJyaWdodENvbHVtbnMiLCJjZW50ZXJDb2x1bW5zIiwiaGVhZGVyR3JvdXBzIiwiYnVpbGRIZWFkZXJHcm91cHMiLCJkZWJ1Z0hlYWRlcnMiLCJnZXRDZW50ZXJIZWFkZXJHcm91cHMiLCJnZXRMZWZ0SGVhZGVyR3JvdXBzIiwiX2xlZnQkbWFwJGZpbHRlcjIiLCJvcmRlcmVkTGVhZkNvbHVtbnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzIiwiZ2V0UmlnaHRIZWFkZXJHcm91cHMiLCJfcmlnaHQkbWFwJGZpbHRlcjIiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0IiwiZ2V0Rm9vdGVyR3JvdXBzIiwicmV2ZXJzZSIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTUiLCJnZXRMZWZ0Rm9vdGVyR3JvdXBzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBNiIsImdldENlbnRlckZvb3Rlckdyb3VwcyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTciLCJnZXRSaWdodEZvb3Rlckdyb3VwcyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTgiLCJnZXRGbGF0SGVhZGVycyIsImhlYWRlcnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0E5IiwiZ2V0TGVmdEZsYXRIZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTAiLCJnZXRDZW50ZXJGbGF0SGVhZGVycyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTExIiwiZ2V0UmlnaHRGbGF0SGVhZGVycyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTEyIiwiZ2V0Q2VudGVyTGVhZkhlYWRlcnMiLCJmbGF0SGVhZGVycyIsIl9oZWFkZXIkc3ViSGVhZGVycyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTEzIiwiZ2V0TGVmdExlYWZIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzMiIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTE0IiwiZ2V0UmlnaHRMZWFmSGVhZGVycyIsIl9oZWFkZXIkc3ViSGVhZGVyczMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNSIsImNlbnRlciIsIl9sZWZ0JDAkaGVhZGVycyIsIl9sZWZ0JCIsIl9jZW50ZXIkMCRoZWFkZXJzIiwiX2NlbnRlciQiLCJfcmlnaHQkMCRoZWFkZXJzIiwiX3JpZ2h0JCIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTE2IiwiY29sdW1uc1RvR3JvdXAiLCJoZWFkZXJGYW1pbHkiLCJfaGVhZGVyR3JvdXBzJDAkaGVhZGUiLCJfaGVhZGVyR3JvdXBzJCIsIm1heERlcHRoIiwiZmluZE1heERlcHRoIiwiZ2V0SXNWaXNpYmxlIiwiY3JlYXRlSGVhZGVyR3JvdXAiLCJoZWFkZXJzVG9Hcm91cCIsImpvaW4iLCJwZW5kaW5nUGFyZW50SGVhZGVycyIsImhlYWRlclRvR3JvdXAiLCJsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyIiwiaXNMZWFmSGVhZGVyIiwiYm90dG9tSGVhZGVycyIsInJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMiLCJmaWx0ZXJlZEhlYWRlcnMiLCJjaGlsZFJvd1NwYW5zIiwiY2hpbGRDb2xTcGFuIiwiY2hpbGRSb3dTcGFuIiwibWluQ2hpbGRSb3dTcGFuIiwiZGVmYXVsdENvbHVtblNpemluZyIsInNpemUiLCJtaW5TaXplIiwibWF4U2l6ZSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlIiwic3RhcnRPZmZzZXQiLCJzdGFydFNpemUiLCJkZWx0YU9mZnNldCIsImRlbHRhUGVyY2VudGFnZSIsImlzUmVzaXppbmdDb2x1bW4iLCJjb2x1bW5TaXppbmdTdGFydCIsIkNvbHVtblNpemluZyIsImdldERlZmF1bHRDb2x1bW5EZWYiLCJnZXRJbml0aWFsU3RhdGUiLCJzdGF0ZSIsImNvbHVtblNpemluZyIsImNvbHVtblNpemluZ0luZm8iLCJnZXREZWZhdWx0T3B0aW9ucyIsImNvbHVtblJlc2l6ZU1vZGUiLCJvbkNvbHVtblNpemluZ0NoYW5nZSIsIm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSIsImdldFNpemUiLCJfY29sdW1uJGNvbHVtbkRlZiRtaW4iLCJfY29sdW1uJGNvbHVtbkRlZiRtYXgiLCJjb2x1bW5TaXplIiwiZ2V0U3RhcnQiLCJwb3NpdGlvbiIsImdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucyIsImZpbmRJbmRleCIsInByZXZTaWJsaW5nQ29sdW1uIiwicmVzZXRTaXplIiwic2V0Q29sdW1uU2l6aW5nIiwiX3JlZjIiLCJfIiwicmVzdCIsImdldENhblJlc2l6ZSIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYSIsIl90YWJsZSRvcHRpb25zJGVuYWJsZSIsImVuYWJsZVJlc2l6aW5nIiwiZW5hYmxlQ29sdW1uUmVzaXppbmciLCJnZXRJc1Jlc2l6aW5nIiwic3VtIiwiX2hlYWRlciRjb2x1bW4kZ2V0U2l6IiwicHJldlNpYmxpbmdIZWFkZXIiLCJnZXRSZXNpemVIYW5kbGVyIiwiZ2V0Q29sdW1uIiwiY2FuUmVzaXplIiwiZSIsInBlcnNpc3QiLCJpc1RvdWNoU3RhcnRFdmVudCIsInRvdWNoZXMiLCJjbGllbnRYIiwibmV3Q29sdW1uU2l6aW5nIiwidXBkYXRlT2Zmc2V0IiwiZXZlbnRUeXBlIiwiY2xpZW50WFBvcyIsInNldENvbHVtblNpemluZ0luZm8iLCJfb2xkJHN0YXJ0T2Zmc2V0IiwiX29sZCRzdGFydFNpemUiLCJfcmVmMyIsImhlYWRlclNpemUiLCJvbk1vdmUiLCJvbkVuZCIsIm1vdXNlRXZlbnRzIiwibW92ZUhhbmRsZXIiLCJ1cEhhbmRsZXIiLCJkb2N1bWVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0b3VjaEV2ZW50cyIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIl9lJHRvdWNoZXMkIiwicGFzc2l2ZUlmU3VwcG9ydGVkIiwicGFzc2l2ZUV2ZW50U3VwcG9ydGVkIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNldENvbHVtblNpemluZyIsImRlZmF1bHRTdGF0ZSIsIl90YWJsZSRpbml0aWFsU3RhdGUkYyIsImluaXRpYWxTdGF0ZSIsInJlc2V0SGVhZGVyU2l6ZUluZm8iLCJfdGFibGUkaW5pdGlhbFN0YXRlJGMyIiwiZ2V0VG90YWxTaXplIiwiX3RhYmxlJGdldEhlYWRlckdyb3VwIiwiX3RhYmxlJGdldEhlYWRlckdyb3VwMiIsInJlZHVjZSIsImdldExlZnRUb3RhbFNpemUiLCJfdGFibGUkZ2V0TGVmdEhlYWRlckciLCJfdGFibGUkZ2V0TGVmdEhlYWRlckcyIiwiZ2V0Q2VudGVyVG90YWxTaXplIiwiX3RhYmxlJGdldENlbnRlckhlYWRlIiwiX3RhYmxlJGdldENlbnRlckhlYWRlMiIsImdldFJpZ2h0VG90YWxTaXplIiwiX3RhYmxlJGdldFJpZ2h0SGVhZGVyIiwiX3RhYmxlJGdldFJpZ2h0SGVhZGVyMiIsInBhc3NpdmVTdXBwb3J0ZWQiLCJzdXBwb3J0ZWQiLCJ3aW5kb3ciLCJlcnIiLCJ0eXBlIiwiRXhwYW5kaW5nIiwiZXhwYW5kZWQiLCJvbkV4cGFuZGVkQ2hhbmdlIiwicGFnaW5hdGVFeHBhbmRlZFJvd3MiLCJyZWdpc3RlcmVkIiwicXVldWVkIiwiX2F1dG9SZXNldEV4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkYXV0b1JlIiwiX3F1ZXVlIiwiYXV0b1Jlc2V0QWxsIiwiYXV0b1Jlc2V0RXhwYW5kZWQiLCJtYW51YWxFeHBhbmRpbmciLCJyZXNldEV4cGFuZGVkIiwic2V0RXhwYW5kZWQiLCJ0b2dnbGVBbGxSb3dzRXhwYW5kZWQiLCJnZXRJc0FsbFJvd3NFeHBhbmRlZCIsIl90YWJsZSRpbml0aWFsU3RhdGUkZSIsIl90YWJsZSRpbml0aWFsU3RhdGUiLCJnZXRDYW5Tb21lUm93c0V4cGFuZCIsImdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCIsImZsYXRSb3dzIiwicm93IiwiZ2V0Q2FuRXhwYW5kIiwiZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciIsImdldElzU29tZVJvd3NFeHBhbmRlZCIsIk9iamVjdCIsInZhbHVlcyIsImtleXMiLCJnZXRSb3dNb2RlbCIsImdldElzRXhwYW5kZWQiLCJnZXRFeHBhbmRlZERlcHRoIiwicm93SWRzIiwicm93c0J5SWQiLCJzcGxpdElkIiwiZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCIsImdldFNvcnRlZFJvd01vZGVsIiwiZ2V0RXhwYW5kZWRSb3dNb2RlbCIsIl9nZXRFeHBhbmRlZFJvd01vZGVsIiwiY3JlYXRlUm93IiwidG9nZ2xlRXhwYW5kZWQiLCJfZXhwYW5kZWQiLCJleGlzdHMiLCJvbGRFeHBhbmRlZCIsInJvd0lkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIiwiZ2V0SXNSb3dFeHBhbmRlZCIsIl90YWJsZSRvcHRpb25zJGdldFJvdyIsIl9yb3ckc3ViUm93cyIsImdldFJvd0NhbkV4cGFuZCIsImVuYWJsZUV4cGFuZGluZyIsInN1YlJvd3MiLCJnZXRJc0FsbFBhcmVudHNFeHBhbmRlZCIsImlzRnVsbHlFeHBhbmRlZCIsImN1cnJlbnRSb3ciLCJwYXJlbnRJZCIsImdldFJvdyIsImdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciIsImNhbkV4cGFuZCIsImluY2x1ZGVzU3RyaW5nIiwiZmlsdGVyVmFsdWUiLCJfcm93JGdldFZhbHVlIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJnZXRWYWx1ZSIsInRvU3RyaW5nIiwiYXV0b1JlbW92ZSIsInRlc3RGYWxzZXkiLCJpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSIsIl9yb3ckZ2V0VmFsdWUyIiwiZXF1YWxzU3RyaW5nIiwiX3JvdyRnZXRWYWx1ZTMiLCJhcnJJbmNsdWRlcyIsIl9yb3ckZ2V0VmFsdWU0IiwiYXJySW5jbHVkZXNBbGwiLCJfcm93JGdldFZhbHVlNSIsImFyckluY2x1ZGVzU29tZSIsIl9yb3ckZ2V0VmFsdWU2IiwiZXF1YWxzIiwid2Vha0VxdWFscyIsImluTnVtYmVyUmFuZ2UiLCJyb3dWYWx1ZSIsInJlc29sdmVGaWx0ZXJWYWx1ZSIsInVuc2FmZU1pbiIsInVuc2FmZU1heCIsInBhcnNlZE1pbiIsInBhcnNlRmxvYXQiLCJwYXJzZWRNYXgiLCJpc05hTiIsIkluZmluaXR5IiwidGVtcCIsImZpbHRlckZucyIsIkZpbHRlcnMiLCJmaWx0ZXJGbiIsImNvbHVtbkZpbHRlcnMiLCJnbG9iYWxGaWx0ZXIiLCJvbkNvbHVtbkZpbHRlcnNDaGFuZ2UiLCJvbkdsb2JhbEZpbHRlckNoYW5nZSIsImZpbHRlckZyb21MZWFmUm93cyIsIm1heExlYWZSb3dGaWx0ZXJEZXB0aCIsImdsb2JhbEZpbHRlckZuIiwiZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyIiwiX3RhYmxlJGdldENvcmVSb3dNb2RlIiwidmFsdWUiLCJnZXRDb3JlUm93TW9kZWwiLCJfZ2V0QWxsQ2VsbHNCeUNvbHVtbklkIiwiZ2V0QXV0b0ZpbHRlckZuIiwiZmlyc3RSb3ciLCJnZXRGaWx0ZXJGbiIsIl90YWJsZSRvcHRpb25zJGZpbHRlciIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjIiLCJnZXRDYW5GaWx0ZXIiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUyIiwiZW5hYmxlQ29sdW1uRmlsdGVyIiwiZW5hYmxlQ29sdW1uRmlsdGVycyIsImVuYWJsZUZpbHRlcnMiLCJnZXRDYW5HbG9iYWxGaWx0ZXIiLCJfY29sdW1uJGNvbHVtbkRlZiRlbmEyIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTQiLCJfdGFibGUkb3B0aW9ucyRnZXRDb2wiLCJlbmFibGVHbG9iYWxGaWx0ZXIiLCJnZXRJc0ZpbHRlcmVkIiwiZ2V0RmlsdGVySW5kZXgiLCJnZXRGaWx0ZXJWYWx1ZSIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bSIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTIiLCJfdGFibGUkZ2V0U3RhdGUkY29sdW0zIiwic2V0RmlsdGVyVmFsdWUiLCJzZXRDb2x1bW5GaWx0ZXJzIiwicHJldmlvdXNmaWx0ZXIiLCJuZXdGaWx0ZXIiLCJzaG91bGRBdXRvUmVtb3ZlRmlsdGVyIiwiX29sZCRmaWx0ZXIiLCJuZXdGaWx0ZXJPYmoiLCJfb2xkJG1hcCIsIl9nZXRGYWNldGVkUm93TW9kZWwiLCJnZXRGYWNldGVkUm93TW9kZWwiLCJnZXRQcmVGaWx0ZXJlZFJvd01vZGVsIiwiX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJnZXRGYWNldGVkVW5pcXVlVmFsdWVzIiwiTWFwIiwiX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJnZXRGYWNldGVkTWluTWF4VmFsdWVzIiwiY29sdW1uRmlsdGVyc01ldGEiLCJnZXRHbG9iYWxBdXRvRmlsdGVyRm4iLCJnZXRHbG9iYWxGaWx0ZXJGbiIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjMiLCJfdGFibGUkb3B0aW9ucyRmaWx0ZXI0IiwiZ2V0QWxsTGVhZkNvbHVtbnMiLCJ1cGRhdGVGbiIsIl9mdW5jdGlvbmFsVXBkYXRlIiwic2V0R2xvYmFsRmlsdGVyIiwicmVzZXRHbG9iYWxGaWx0ZXIiLCJyZXNldENvbHVtbkZpbHRlcnMiLCJnZXRGaWx0ZXJlZFJvd01vZGVsIiwiX2dldEZpbHRlcmVkUm93TW9kZWwiLCJtYW51YWxGaWx0ZXJpbmciLCJfZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsIiwiZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsIiwiX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJnZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzIiwiX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJnZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzIiwiX2xlYWZSb3dzIiwiY2hpbGRSb3dzIiwibmV4dCIsIm5leHRWYWx1ZSIsImV4dGVudCIsIm1lYW4iLCJsZWFmUm93cyIsImNvdW50IiwibWVkaWFuIiwibWlkIiwiZmxvb3IiLCJudW1zIiwic29ydCIsImEiLCJiIiwidW5pcXVlIiwiZnJvbSIsIlNldCIsInVuaXF1ZUNvdW50IiwiX2NvbHVtbklkIiwiYWdncmVnYXRpb25GbnMiLCJHcm91cGluZyIsImFnZ3JlZ2F0ZWRDZWxsIiwicHJvcHMiLCJfdG9TdHJpbmciLCJfcHJvcHMkZ2V0VmFsdWUiLCJhZ2dyZWdhdGlvbkZuIiwiZ3JvdXBpbmciLCJvbkdyb3VwaW5nQ2hhbmdlIiwiZ3JvdXBlZENvbHVtbk1vZGUiLCJ0b2dnbGVHcm91cGluZyIsInNldEdyb3VwaW5nIiwiZ2V0Q2FuR3JvdXAiLCJlbmFibGVHcm91cGluZyIsImdldElzR3JvdXBlZCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cCIsImdldEdyb3VwZWRJbmRleCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cDIiLCJpbmRleE9mIiwiZ2V0VG9nZ2xlR3JvdXBpbmdIYW5kbGVyIiwiY2FuR3JvdXAiLCJnZXRBdXRvQWdncmVnYXRpb25GbiIsInByb3RvdHlwZSIsImNhbGwiLCJnZXRBZ2dyZWdhdGlvbkZuIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnMiIsInJlc2V0R3JvdXBpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJGciLCJnZXRQcmVHcm91cGVkUm93TW9kZWwiLCJnZXRHcm91cGVkUm93TW9kZWwiLCJfZ2V0R3JvdXBlZFJvd01vZGVsIiwibWFudWFsR3JvdXBpbmciLCJncm91cGluZ0NvbHVtbklkIiwiZ2V0R3JvdXBpbmdWYWx1ZSIsIl9ncm91cGluZ1ZhbHVlc0NhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJvcmlnaW5hbCIsImNyZWF0ZUNlbGwiLCJjZWxsIiwiZ2V0SXNQbGFjZWhvbGRlciIsImdldElzQWdncmVnYXRlZCIsIm5vbkdyb3VwaW5nQ29sdW1ucyIsImNvbCIsImdyb3VwaW5nQ29sdW1ucyIsImciLCJPcmRlcmluZyIsImNvbHVtbk9yZGVyIiwib25Db2x1bW5PcmRlckNoYW5nZSIsInNldENvbHVtbk9yZGVyIiwicmVzZXRDb2x1bW5PcmRlciIsIm9yZGVyZWRDb2x1bW5zIiwiY29sdW1uT3JkZXJDb3B5IiwiY29sdW1uc0NvcHkiLCJ0YXJnZXRDb2x1bW5JZCIsInNoaWZ0IiwiZm91bmRJbmRleCIsInNwbGljZSIsImRlZmF1bHRQYWdlSW5kZXgiLCJkZWZhdWx0UGFnZVNpemUiLCJnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlIiwicGFnZUluZGV4IiwicGFnZVNpemUiLCJQYWdpbmF0aW9uIiwicGFnaW5hdGlvbiIsIm9uUGFnaW5hdGlvbkNoYW5nZSIsIl9hdXRvUmVzZXRQYWdlSW5kZXgiLCJhdXRvUmVzZXRQYWdlSW5kZXgiLCJtYW51YWxQYWdpbmF0aW9uIiwicmVzZXRQYWdlSW5kZXgiLCJzZXRQYWdpbmF0aW9uIiwic2FmZVVwZGF0ZXIiLCJuZXdTdGF0ZSIsInJlc2V0UGFnaW5hdGlvbiIsIl90YWJsZSRpbml0aWFsU3RhdGUkcCIsInNldFBhZ2VJbmRleCIsIm1heFBhZ2VJbmRleCIsInBhZ2VDb3VudCIsIl90YWJsZSRpbml0aWFsU3RhdGUkcDIiLCJyZXNldFBhZ2VTaXplIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyIsIl90YWJsZSRpbml0aWFsU3RhdGUyIiwic2V0UGFnZVNpemUiLCJ0b3BSb3dJbmRleCIsInNldFBhZ2VDb3VudCIsIl90YWJsZSRvcHRpb25zJHBhZ2VDbyIsIm5ld1BhZ2VDb3VudCIsImdldFBhZ2VPcHRpb25zIiwiZ2V0UGFnZUNvdW50IiwicGFnZU9wdGlvbnMiLCJmaWxsIiwiaSIsImRlYnVnVGFibGUiLCJnZXRDYW5QcmV2aW91c1BhZ2UiLCJnZXRDYW5OZXh0UGFnZSIsInByZXZpb3VzUGFnZSIsIm5leHRQYWdlIiwiZ2V0UGFnaW5hdGlvblJvd01vZGVsIiwiX2dldFBhZ2luYXRpb25Sb3dNb2RlbCIsIl90YWJsZSRvcHRpb25zJHBhZ2VDbzIiLCJjZWlsIiwicm93cyIsImdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUiLCJnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlIiwidG9wIiwiYm90dG9tIiwiUGlubmluZyIsInJvd1Bpbm5pbmciLCJvbkNvbHVtblBpbm5pbmdDaGFuZ2UiLCJvblJvd1Bpbm5pbmdDaGFuZ2UiLCJwaW4iLCJjb2x1bW5JZHMiLCJzZXRDb2x1bW5QaW5uaW5nIiwiX29sZCRsZWZ0MyIsIl9vbGQkcmlnaHQzIiwiX29sZCRsZWZ0IiwiX29sZCRyaWdodCIsIl9vbGQkbGVmdDIiLCJfb2xkJHJpZ2h0MiIsImdldENhblBpbiIsIl9kJGNvbHVtbkRlZiRlbmFibGVQaSIsImVuYWJsZVBpbm5pbmciLCJlbmFibGVDb2x1bW5QaW5uaW5nIiwiZ2V0SXNQaW5uZWQiLCJsZWFmQ29sdW1uSWRzIiwiaXNMZWZ0IiwiaXNSaWdodCIsImdldFBpbm5lZEluZGV4IiwiaW5jbHVkZUxlYWZSb3dzIiwiaW5jbHVkZVBhcmVudFJvd3MiLCJsZWFmUm93SWRzIiwiZ2V0TGVhZlJvd3MiLCJwYXJlbnRSb3dJZHMiLCJnZXRQYXJlbnRSb3dzIiwic2V0Um93UGlubmluZyIsIl9vbGQkdG9wMyIsIl9vbGQkYm90dG9tMyIsIl9vbGQkdG9wIiwiX29sZCRib3R0b20iLCJoYXMiLCJfb2xkJHRvcDIiLCJfb2xkJGJvdHRvbTIiLCJfcmVmNCIsImVuYWJsZVJvd1Bpbm5pbmciLCJpc1RvcCIsImlzQm90dG9tIiwiX3RhYmxlJF9nZXRQaW5uZWRSb3dzIiwiX3Zpc2libGVQaW5uZWRSb3dJZHMkIiwidmlzaWJsZVBpbm5lZFJvd0lkcyIsIl9nZXRQaW5uZWRSb3dzIiwiX3JlZjUiLCJnZXRDZW50ZXJWaXNpYmxlQ2VsbHMiLCJfZ2V0QWxsVmlzaWJsZUNlbGxzIiwiYWxsQ2VsbHMiLCJsZWZ0QW5kUmlnaHQiLCJkZWJ1Z1Jvd3MiLCJnZXRMZWZ0VmlzaWJsZUNlbGxzIiwiY2VsbHMiLCJnZXRSaWdodFZpc2libGVDZWxscyIsInJlc2V0Q29sdW1uUGlubmluZyIsImdldElzU29tZUNvbHVtbnNQaW5uZWQiLCJfcGlubmluZ1N0YXRlJHBvc2l0aW8iLCJwaW5uaW5nU3RhdGUiLCJfcGlubmluZ1N0YXRlJGxlZnQiLCJfcGlubmluZ1N0YXRlJHJpZ2h0IiwiZ2V0TGVmdExlYWZDb2x1bW5zIiwiZ2V0UmlnaHRMZWFmQ29sdW1ucyIsImdldENlbnRlckxlYWZDb2x1bW5zIiwicmVzZXRSb3dQaW5uaW5nIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRyIiwiZ2V0SXNTb21lUm93c1Bpbm5lZCIsIl9waW5uaW5nU3RhdGUkcG9zaXRpbzIiLCJfcGlubmluZ1N0YXRlJHRvcCIsIl9waW5uaW5nU3RhdGUkYm90dG9tIiwidmlzaWJsZVJvd3MiLCJwaW5uZWRSb3dJZHMiLCJfdGFibGUkb3B0aW9ucyRrZWVwUGkiLCJrZWVwUGlubmVkUm93cyIsImdldFRvcFJvd3MiLCJnZXRCb3R0b21Sb3dzIiwiZ2V0Q2VudGVyUm93cyIsImFsbFJvd3MiLCJ0b3BBbmRCb3R0b20iLCJSb3dTZWxlY3Rpb24iLCJyb3dTZWxlY3Rpb24iLCJvblJvd1NlbGVjdGlvbkNoYW5nZSIsImVuYWJsZVJvd1NlbGVjdGlvbiIsImVuYWJsZU11bHRpUm93U2VsZWN0aW9uIiwiZW5hYmxlU3ViUm93U2VsZWN0aW9uIiwic2V0Um93U2VsZWN0aW9uIiwicmVzZXRSb3dTZWxlY3Rpb24iLCJ0b2dnbGVBbGxSb3dzU2VsZWN0ZWQiLCJnZXRJc0FsbFJvd3NTZWxlY3RlZCIsInByZUdyb3VwZWRGbGF0Um93cyIsImdldENhblNlbGVjdCIsInRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJyZXNvbHZlZFZhbHVlIiwiZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkIiwibXV0YXRlUm93SXNTZWxlY3RlZCIsImdldFByZVNlbGVjdGVkUm93TW9kZWwiLCJnZXRTZWxlY3RlZFJvd01vZGVsIiwicm93TW9kZWwiLCJzZWxlY3RSb3dzRm4iLCJnZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwiLCJnZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCIsImlzQWxsUm93c1NlbGVjdGVkIiwicGFnaW5hdGlvbkZsYXRSb3dzIiwiaXNBbGxQYWdlUm93c1NlbGVjdGVkIiwiZ2V0SXNTb21lUm93c1NlbGVjdGVkIiwiX3RhYmxlJGdldFN0YXRlJHJvd1NlIiwidG90YWxTZWxlY3RlZCIsImdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQiLCJnZXRJc1NlbGVjdGVkIiwiZ2V0SXNTb21lU2VsZWN0ZWQiLCJnZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRIYW5kbGVyIiwidGFyZ2V0IiwiY2hlY2tlZCIsImdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyIiwidG9nZ2xlU2VsZWN0ZWQiLCJpc1NlbGVjdGVkIiwiX29wdHMkc2VsZWN0Q2hpbGRyZW4iLCJzZWxlY3RlZFJvd0lkcyIsInNlbGVjdENoaWxkcmVuIiwiaXNSb3dTZWxlY3RlZCIsImlzU3ViUm93U2VsZWN0ZWQiLCJnZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCIsImdldENhblNlbGVjdFN1YlJvd3MiLCJnZXRDYW5NdWx0aVNlbGVjdCIsImdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlciIsImNhblNlbGVjdCIsIl90YXJnZXQiLCJpbmNsdWRlQ2hpbGRyZW4iLCJuZXdTZWxlY3RlZEZsYXRSb3dzIiwibmV3U2VsZWN0ZWRSb3dzQnlJZCIsInJlY3Vyc2VSb3dzIiwiX3JvdyRzdWJSb3dzMiIsInNlbGVjdGlvbiIsIl9zZWxlY3Rpb24kcm93JGlkIiwiX3JvdyRzdWJSb3dzMyIsImFsbENoaWxkcmVuU2VsZWN0ZWQiLCJzb21lU2VsZWN0ZWQiLCJzdWJSb3ciLCJzdWJSb3dDaGlsZHJlblNlbGVjdGVkIiwicmVTcGxpdEFscGhhTnVtZXJpYyIsImFscGhhbnVtZXJpYyIsInJvd0EiLCJyb3dCIiwiY29tcGFyZUFscGhhbnVtZXJpYyIsImFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUiLCJ0ZXh0IiwiY29tcGFyZUJhc2ljIiwidGV4dENhc2VTZW5zaXRpdmUiLCJkYXRldGltZSIsImJhc2ljIiwiYVN0ciIsImJTdHIiLCJhYSIsImJiIiwiYW4iLCJwYXJzZUludCIsImJuIiwiY29tYm8iLCJzb3J0aW5nRm5zIiwiU29ydGluZyIsInNvcnRpbmciLCJzb3J0aW5nRm4iLCJzb3J0VW5kZWZpbmVkIiwib25Tb3J0aW5nQ2hhbmdlIiwiaXNNdWx0aVNvcnRFdmVudCIsInNoaWZ0S2V5IiwiZ2V0QXV0b1NvcnRpbmdGbiIsImZpcnN0Um93cyIsInNsaWNlIiwiaXNTdHJpbmciLCJnZXRBdXRvU29ydERpciIsImdldFNvcnRpbmdGbiIsIl90YWJsZSRvcHRpb25zJHNvcnRpbiIsIl90YWJsZSRvcHRpb25zJHNvcnRpbjIiLCJ0b2dnbGVTb3J0aW5nIiwiZGVzYyIsIm11bHRpIiwibmV4dFNvcnRpbmdPcmRlciIsImdldE5leHRTb3J0aW5nT3JkZXIiLCJoYXNNYW51YWxWYWx1ZSIsInNldFNvcnRpbmciLCJleGlzdGluZ1NvcnRpbmciLCJleGlzdGluZ0luZGV4IiwibmV3U29ydGluZyIsInNvcnRBY3Rpb24iLCJuZXh0RGVzYyIsImdldENhbk11bHRpU29ydCIsIl90YWJsZSRvcHRpb25zJG1heE11bCIsIm1heE11bHRpU29ydENvbENvdW50IiwiZ2V0Rmlyc3RTb3J0RGlyIiwiX2NvbHVtbiRjb2x1bW5EZWYkc29yIiwic29ydERlc2NGaXJzdCIsImZpcnN0U29ydERpcmVjdGlvbiIsImlzU29ydGVkIiwiZ2V0SXNTb3J0ZWQiLCJlbmFibGVTb3J0aW5nUmVtb3ZhbCIsImVuYWJsZU11bHRpUmVtb3ZlIiwiZ2V0Q2FuU29ydCIsImVuYWJsZVNvcnRpbmciLCJlbmFibGVNdWx0aVNvcnQiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkiLCJjb2x1bW5Tb3J0IiwiZ2V0U29ydEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMiIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aTMiLCJjbGVhclNvcnRpbmciLCJnZXRUb2dnbGVTb3J0aW5nSGFuZGxlciIsImNhblNvcnQiLCJyZXNldFNvcnRpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHMiLCJnZXRQcmVTb3J0ZWRSb3dNb2RlbCIsIl9nZXRTb3J0ZWRSb3dNb2RlbCIsIm1hbnVhbFNvcnRpbmciLCJWaXNpYmlsaXR5IiwiY29sdW1uVmlzaWJpbGl0eSIsIm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSIsInRvZ2dsZVZpc2liaWxpdHkiLCJnZXRDYW5IaWRlIiwic2V0Q29sdW1uVmlzaWJpbGl0eSIsImVuYWJsZUhpZGluZyIsImdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyIiwiZ2V0QWxsQ2VsbHMiLCJnZXRWaXNpYmxlQ2VsbHMiLCJtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QiLCJnZXRDb2x1bW5zIiwiZ2V0VmlzaWJsZUZsYXRDb2x1bW5zIiwiZ2V0QWxsRmxhdENvbHVtbnMiLCJnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMiLCJyZXNldENvbHVtblZpc2liaWxpdHkiLCJ0b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSIsIl92YWx1ZSIsImdldElzQWxsQ29sdW1uc1Zpc2libGUiLCJvYmoiLCJnZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSIsImdldFRvZ2dsZUFsbENvbHVtbnNWaXNpYmlsaXR5SGFuZGxlciIsImZlYXR1cmVzIiwiX29wdGlvbnMkaW5pdGlhbFN0YXRlIiwiZGVmYXVsdE9wdGlvbnMiLCJhc3NpZ24iLCJtZXJnZU9wdGlvbnMiLCJjb3JlSW5pdGlhbFN0YXRlIiwiX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IiwicXVldWVkVGltZW91dCIsImNvcmVJbnN0YW5jZSIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY2F0Y2giLCJlcnJvciIsInNldFRpbWVvdXQiLCJyZXNldCIsInNldE9wdGlvbnMiLCJuZXdPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9nZXRSb3dJZCIsImdldFJvd0lkIiwiX2dldENvcmVSb3dNb2RlbCIsInNlYXJjaEFsbCIsIl9kZWZhdWx0Q29sdW1uIiwiX3Byb3BzJHJlbmRlclZhbHVlJHRvIiwiX3Byb3BzJHJlbmRlclZhbHVlIiwicmVuZGVyVmFsdWUiLCJfZ2V0Q29sdW1uRGVmcyIsImNvbHVtbkRlZnMiLCJyZWN1cnNlQ29sdW1ucyIsImdyb3VwaW5nQ29sdW1uRGVmIiwiX2dldEFsbEZsYXRDb2x1bW5zQnlJZCIsImZsYXRDb2x1bW5zIiwiYWNjIiwiZ2V0UmVuZGVyVmFsdWUiLCJfY2VsbCRnZXRWYWx1ZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJyb3dJbmRleCIsIl92YWx1ZXNDYWNoZSIsIl91bmlxdWVWYWx1ZXNDYWNoZSIsImdldFVuaXF1ZVZhbHVlcyIsImdldFBhcmVudFJvdyIsInBhcmVudFJvd3MiLCJwYXJlbnRSb3ciLCJjcmVhdGVDb2x1bW5IZWxwZXIiLCJhY2Nlc3NvciIsImRpc3BsYXkiLCJncm91cCIsImRhdGEiLCJhY2Nlc3NSb3dzIiwib3JpZ2luYWxSb3dzIiwiZ2V0U3ViUm93cyIsIl9yb3ckb3JpZ2luYWxTdWJSb3dzIiwib3JpZ2luYWxTdWJSb3dzIiwiZmlsdGVyUm93cyIsImZpbHRlclJvd0ltcGwiLCJmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyIsImZpbHRlclJvd01vZGVsRnJvbVJvb3QiLCJyb3dzVG9GaWx0ZXIiLCJmaWx0ZXJSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEiLCJuZXdGaWx0ZXJlZEZsYXRSb3dzIiwibmV3RmlsdGVyZWRSb3dzQnlJZCIsInJlY3Vyc2VGaWx0ZXJSb3dzIiwibmV3Um93IiwiX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiIsInBhc3MiLCJyZXNvbHZlZENvbHVtbkZpbHRlcnMiLCJyZXNvbHZlZEdsb2JhbEZpbHRlcnMiLCJfZmlsdGVyRm4kcmVzb2x2ZUZpbHQiLCJmaWx0ZXJhYmxlSWRzIiwiZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucyIsIl9nbG9iYWxGaWx0ZXJGbiRyZXNvbCIsImN1cnJlbnRDb2x1bW5GaWx0ZXIiLCJjdXJyZW50R2xvYmFsRmlsdGVyIiwiaiIsImZpbHRlck1ldGEiLCJfX2dsb2JhbF9fIiwiZmlsdGVyUm93c0ltcGwiLCJwcmVSb3dNb2RlbCIsIl90YWJsZSRnZXRDb2x1bW4iLCJmYWNldGVkUm93TW9kZWwiLCJmYWNldGVkVW5pcXVlVmFsdWVzIiwiX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkIiwic2V0IiwiZ2V0IiwiX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0IiwiZmlyc3RWYWx1ZSIsImZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJzb3J0aW5nU3RhdGUiLCJzb3J0ZWRGbGF0Um93cyIsImF2YWlsYWJsZVNvcnRpbmciLCJjb2x1bW5JbmZvQnlJZCIsInNvcnRFbnRyeSIsImludmVydFNvcnRpbmciLCJzb3J0RGF0YSIsInNvcnRlZERhdGEiLCJfc29ydEVudHJ5JGRlc2MiLCJjb2x1bW5JbmZvIiwiaXNEZXNjIiwic29ydEludCIsImFWYWx1ZSIsImJWYWx1ZSIsImFVbmRlZmluZWQiLCJiVW5kZWZpbmVkIiwiZXhpc3RpbmdHcm91cGluZyIsImdyb3VwZWRGbGF0Um93cyIsImdyb3VwZWRSb3dzQnlJZCIsImdyb3VwVXBSZWN1cnNpdmVseSIsInJvd0dyb3Vwc01hcCIsImdyb3VwQnkiLCJhZ2dyZWdhdGVkR3JvdXBlZFJvd3MiLCJlbnRyaWVzIiwiZ3JvdXBpbmdWYWx1ZSIsImdyb3VwZWRSb3dzIiwiX2dyb3VwZWRSb3dzJDAkZ2V0VmFsIiwiYWdncmVnYXRlRm4iLCJncm91cE1hcCIsInJlc0tleSIsInByZXZpb3VzIiwiZXhwYW5kUm93cyIsImV4cGFuZGVkUm93cyIsImhhbmRsZVJvdyIsInBhZ2VTdGFydCIsInBhZ2VFbmQiLCJwYWdpbmF0ZWRSb3dNb2RlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;